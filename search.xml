<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dangling meta character ‘+‘ near index 1异常</title>
    <url>/2020/12/15/Dangling-meta-character-%E2%80%98-%E2%80%98-near-index-1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>  Java引用MongoTemplate操作时，报错Dangling meta character ‘+’ near index 1异常的原因和解决方法</p>
</blockquote>
<span id="more"></span>

<p>MongoTemple操作报错Dangling meta character ‘+’ near index 1异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = <span class="keyword">new</span> Query();</span><br><span class="line">String searchValue = <span class="string">&quot;XQ03B13-FZL023+1+008-LW-LH-01B&quot;</span>;</span><br><span class="line">Criteria criteriaName = Criteria.where(<span class="string">&quot;name&quot;</span>).regex(searchValue);</span><br></pre></td></tr></table></figure>

<p>代码这样写，regex的时候会报Dangling meta character ‘+’ near index 1，简单查了一下，发现当searchValue中包含 + 等特殊字符，需要转义一下。<br>转义可以转义成 [+] 或者 +<br>得到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = <span class="keyword">new</span> Query();</span><br><span class="line">String searchValue = <span class="string">&quot;XQ03B13-FZL023+1+008-LW-LH-01B&quot;</span>;</span><br><span class="line">searchValue = searchValue.replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;[+]&quot;</span>);</span><br><span class="line">Criteria criteriaName = Criteria.where(<span class="string">&quot;name&quot;</span>).regex(searchValue);</span><br></pre></td></tr></table></figure>

<p>雷霆嘎巴，查询成功，真不戳！</p>
]]></content>
  </entry>
  <entry>
    <title>2021年终总结</title>
    <url>/2022/01/06/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="岳杨2021年终总结答辩"><a href="#岳杨2021年终总结答辩" class="headerlink" title="岳杨2021年终总结答辩"></a>岳杨2021年终总结答辩</h1><h3 id="整体概括"><a href="#整体概括" class="headerlink" title="整体概括"></a>整体概括</h3><p>我将描述<code>2021年6月21日</code>入职以来，<code>2021年12月31日</code>为截止日期的个人情况，包含个人工作业绩、学习到的经验、工作中思考的问题以及接下来一年的规划。</p>
<hr>
<p>答辩过程将会涉及以下内容：</p>
<ol>
<li>工作业绩：<ol>
<li> 完成了哪些工作</li>
<li> 取得了哪些成绩</li>
<li> 目标计划与结果</li>
</ol>
</li>
<li>个人成长<ol>
<li> 有哪些收获</li>
<li> 节约了哪些成本</li>
<li> 哪些方面提升了效率</li>
</ol>
</li>
<li>问题分析<ol>
<li> 面临的哪些问题</li>
<li> 有什么应对措施</li>
</ol>
</li>
<li>未来计划<ol>
<li> 下一步的安排</li>
<li> 需要的资源支持</li>
<li> 初步的评价指标</li>
</ol>
</li>
</ol>
<hr>
<h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><h4 id="工作业绩"><a href="#工作业绩" class="headerlink" title="工作业绩"></a>工作业绩</h4><h5 id="完成了哪些工作"><a href="#完成了哪些工作" class="headerlink" title="完成了哪些工作"></a>完成了哪些工作</h5><p>这一年，我只参与了<code>MeFlow产品迭代</code>和<code>MeFlow三一项目</code>的开发和维护工作。</p>
<p>MeFlow产品迭代过程中，这不到半年时间里我完成了如下迭代版本的方案设计和开发工作：</p>
<p><code>模板库模块</code>、<code>审批模块</code>、<code>权限模块</code>、<code>单双屏比对</code>、<code>评审模块</code>、<code>人员选择器优化</code>、<code>字段池优化</code>、<code>工作台模块</code></p>
<p>其中比较关键的模块有：审批模块、权限模块、评审模块、工作台模块。</p>
<p>期间完成了MeFlow项目中代码命名规范化、ContractObj重构（和王旭）、文件比对和模板比对的优化等。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> ContractObj重构前使用相对较困难，有较多的重复代码，重构后比较好用，减少了大量的冗余代码。</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 比对优化前比对十分钟，优化后两三分钟。</span><br></pre></td></tr></table></figure>



<p>MeFlow三一项目中，我参与了三一项目的需求研发和大部分维护工作，完成需求有以下：</p>
<p><code>三一系统集成</code>、<code>页面改版需求</code>、<code>单点登录</code>、<code>外部发起审批版本</code>、<code>外部发起审批变更版本</code>、<code>三一GSP接口等需求的开发</code></p>
<p><a href="https://powerlawai.feishu.cn/docs/doccnPBFJozuIJ9nDSDEXMaQUKR">三一待解决问题</a></p>
<p>三一现阶段后端问题基本得到解决</p>
<h5 id="取得了哪些成绩"><a href="#取得了哪些成绩" class="headerlink" title="取得了哪些成绩"></a>取得了哪些成绩</h5><p>MeFlow产品每次迭代版本都能及时上线，没有延期</p>
<p>MeFlow三一项目的解决了几乎所有属于代码层面的问题</p>
<p>MeFlow签约的客户越来越多，当然这个与大家的努力息息相关</p>
<h5 id="目标计划与结果"><a href="#目标计划与结果" class="headerlink" title="目标计划与结果"></a>目标计划与结果</h5><ul>
<li><p>  来到公司后的根本目标是提升公司的产品价值，衍生出来的小目标就是完成好需求、维护好项目、提升个人水平。目前来看需求完成情况为预期的<code>90%</code>，维护好项目为预期的<code>100%</code>，提升个人水平完成情况为预期的<code>67%</code>。</p>
</li>
<li><p>  需求完成与预期差距主要体现在：用现在的眼光去看之前的设计和逻辑，会发现之前完成需求只是满足了<code>基本满足需求</code>这一条件，与<code>高质量、高效的、安全的</code>目标还有差距，我觉得这需要通过时间沉淀来追赶这样的差距。</p>
</li>
<li><p>  提升个人水平与预期差距主要体现在学习过后没有形成书面记录，没有将自己学习到的分享给大家。</p>
</li>
</ul>
<hr>
<h4 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h4><ul>
<li><p>  编程水平提升，知识面变宽变广</p>
</li>
<li><p>  各个开发工具的熟练使用：Charles，Telepresence</p>
</li>
<li><p>性格上：</p>
<ul>
<li>  保持着对程序设计的热情，使命感</li>
<li>  责任心进一步提升，能够真正将程序设计当成自己的事情去认真对待</li>
<li>  更加的细心，考虑的更加广泛、周到，比起刚到公司可以说是有较大提升</li>
</ul>
</li>
<li><p>  能有效的输出开发过程中的文档和发版文档</p>
</li>
</ul>
<hr>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><h5 id="面临的哪些问题和挑战"><a href="#面临的哪些问题和挑战" class="headerlink" title="面临的哪些问题和挑战"></a>面临的哪些问题和挑战</h5><ol>
<li> 根据我2021年的程序开发的经历来看，面临较多的问题就是对需求分析的不够到位不够深刻，进而在设计和开发过程中种种疏漏，最终导致开发、联调、测试、上线的过程不够顺利，虽然最终能够按时上线，但经常需要加班加点的去赶进度修问题。</li>
<li> 在与各方沟通的过程中，有时会出现一种相对绝对的言论，虽然已经在刻意的去避免，但是确实还是因为说话说的不对导致沟通不顺利。</li>
<li> 目前项目交付总是以DL为期望去完成交付任务，并且接近DL时手忙脚乱，降低整体的效率。</li>
<li> 没有给自己安排好时间，经常出现的问题就是多个时间线同时进行。</li>
</ol>
<h5 id="有什么应对措施"><a href="#有什么应对措施" class="headerlink" title="有什么应对措施"></a>有什么应对措施</h5><ol>
<li> 首先，可以花费更多精力和心思去考虑一个产品需求，克服那种”不可见的产出容易懈怠”的心理。其次，能与产品团队和后端团队共同讨论后再做出相对更合理的技术选型和决策，将技术返讲及时的坚定地落实下去。</li>
<li> 养成习惯来避免以一种绝对的语气或者态度去描述事物。</li>
<li> 缩短项目交付周期，形成稳定的项目部署脚本。</li>
</ol>
<hr>
<h4 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h4><h5 id="下一步的安排"><a href="#下一步的安排" class="headerlink" title="下一步的安排"></a>下一步的安排</h5><p>下一小步的安排是：能继续保持现有的活力，提高质量、提高效率的完成产品需求，维护好项目。</p>
<p>未来一年的安排：</p>
<ol>
<li> 与MeFlow整个团队共同完成2022年公司OKR，且不以完成OKR为最终目标的进行不断创新和努力。</li>
<li> 提升对程序设计的视野和深度，为幂律的产品提供更优秀的设计和更高质量的代码。</li>
<li> 随着MeFlow承接项目越来越多，能够肩负起一部分项目的开发和维护工作，并以<code>客户第一，责任担当，创造价值</code>的价值观反馈于客户。</li>
<li> 在个人学习成长的同时，优化自己的学习习惯，形成文档产出和知识分享，为小伙伴提供自己的学习分享：先预计三次（大概 __ ）。</li>
<li> 对于自身，提升自身技能的深度与广度，对每一种技术每一类知识都能了解到位。</li>
</ol>
<p>擦神：整合一部分之前的代码，梳理之前的业务。</p>
]]></content>
  </entry>
  <entry>
    <title>Git基本命令总结</title>
    <url>/2020/08/27/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>  日常使用Git操作，随笔整理持续更新</p>
</blockquote>
<span id="more"></span>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init -- 在当前目录下初始化一个git仓库, 如果是基本项目开发基本用不到这个命令</span><br></pre></td></tr></table></figure>

<h3 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git colne &lt;url&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加工作区文件到暂存区"><a href="#添加工作区文件到暂存区" class="headerlink" title="添加工作区文件到暂存区"></a>添加工作区文件到暂存区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;fileName&gt; -- 指定一个文件添加到暂存区</span><br><span class="line">git add . -- 常用, 将当前目录下的所有改动的文件添加到暂存区</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  工作区：项目目录下除了<code>.git</code>文件夹以外的区域，简单来说就是你的项目文件区域</p>
</blockquote>
<h3 id="查看工作状态"><a href="#查看工作状态" class="headerlink" title="查看工作状态"></a>查看工作状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status -- 查看当前工作区和暂存区的文件状态</span><br></pre></td></tr></table></figure>

<h3 id="提交暂存区文件到本地仓库"><a href="#提交暂存区文件到本地仓库" class="headerlink" title="提交暂存区文件到本地仓库"></a>提交暂存区文件到本地仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;本次提交的描述内容&quot;</span><br></pre></td></tr></table></figure>

<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard ] [HEAD]-- 将暂存区的文件取消暂存</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <code>--mixed</code>为默认参数，重置暂存区的文件与上一次提交保持一致，工作区内容不变。可以理解成把工作区的文件和上次一提交的文件重新比对。效果上就像把暂存区的文件重新拿到工作区。</p>
<p>  <code>--soft</code>为回退到上一个版本。</p>
<p>  <code>--hard</code>为撤销工作区中所有未提交的内容，将暂存区和工作区都回到上一次版本，并删除之前的所有信息。就把这个参数理解成回到某个版本”最初的样子”。效果上就像时间回溯到了上一个版本提交之前，重新开发上一个版本一样。</p>
</blockquote>
<blockquote>
<p>  其实<code>git reset</code>操作用好了还是挺有用的，比如你当前项目改了一堆没用的地方，你都不想要了，就可以：</p>
<p>  <code>git reset --hard HEAR</code>将当前工作区和暂存区恢复成当前版本”最初的样子”，本地代码瞬间全没了！妙~~~啊！(\狗头)</p>
</blockquote>
<h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h3 id="推送本地仓库到远程仓库"><a href="#推送本地仓库到远程仓库" class="headerlink" title="推送本地仓库到远程仓库"></a>推送本地仓库到远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; -- 最原始的命令</span><br><span class="line">git push -- 常用, 将当前分支推送到远程绑定的对应分支</span><br></pre></td></tr></table></figure>

<h3 id="更新远端分支"><a href="#更新远端分支" class="headerlink" title="更新远端分支"></a>更新远端分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote update origin -p</span><br></pre></td></tr></table></figure>

<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="查看本地所有分支"><a href="#查看本地所有分支" class="headerlink" title="查看本地所有分支"></a>查看本地所有分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a -- 展示的列表中*符号说明当前代码处于哪个分支</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  有时候远端的分支刷新了，你本地获取分支列表发现，”啊哈，分支列表和远端对应不上！”。这时候不用慌，是因为这个列表是保存在本地的，并不是从远端实时获取的，你需要做的就是刷新这个保存在本地的列表与远端同步：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote update origin -p -- 用远端来更新本地仓库</span><br></pre></td></tr></table></figure>

<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch &lt;name&gt; -- 从当前分支创建了名称为 dev 的分支</span><br></pre></td></tr></table></figure>

<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt; -- 切换到本地目标分支</span><br><span class="line">git checkout -b &lt;newBranchName&gt; -- 从当前分支创建一个新分支并切换到新分支上</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <code>git checkout -b</code>操作可以在任一分支的任何状态执行，执行成功之后，会将所有操作复制到新的分支上，并且会切换到新分支，如果新分支提交了修改，则原有分支的操作会撤销掉。</p>
</blockquote>
<h3 id="合并某分支到当前分支"><a href="#合并某分支到当前分支" class="headerlink" title="合并某分支到当前分支"></a>合并某分支到当前分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge &lt;branchName&gt; -- 合并目标分支到当前分支</span><br></pre></td></tr></table></figure>

<h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branchName&gt; -- 删除本地的目标分支</span><br></pre></td></tr></table></figure>

<h3 id="重新定基操作"><a href="#重新定基操作" class="headerlink" title="重新定基操作"></a>重新定基操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase &lt;branchName&gt; -- 以本地目标分支为基准，合并代码</span><br></pre></td></tr></table></figure>

<p>首先，说明一下rebase的作用：将目标分支的开发呈现一条直线，没有其他分支合并进来的节点，展示起来比较清晰。</p>
<p>那么能来点实际吗？——彳亍</p>
<p>git rebase相关流程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b [本地开发分支名] origin/[远程分支名] -- 以目标分支为基准创建新分支并关联远端分支</span><br><span class="line">....... -- 修改代码的操作</span><br><span class="line">git add . -- 添加所有本次修改的文件添加到暂存区</span><br><span class="line">git commit -m &quot;注释内容&quot; -- 提交代码，保存本地分支</span><br><span class="line">git checkout [主分支] -- 切换分支，这个分支是目标基点的分支，简单来说，就是把现在的代码变成从&quot;这个分支开始进行开发&quot;的分支</span><br><span class="line">git pull -- 拉取主分支代码，此时本地仓库主分支代码为最新代码，本地开发分支有所有修改的代码</span><br><span class="line">git checkout [本地开发分支] // 切回本地开发分支，准备rebase</span><br><span class="line">git rebase [主分支] -i HEAD~2 // 将当前分支合并提交到目标分支</span><br><span class="line">// rebase过程可能会出现冲突，解决冲突后继续rebase过程</span><br><span class="line">git rebase [主分支] --continue // 继续rebase过程</span><br><span class="line">git push // 推送远端</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  当然，如果你不愿意在提交代码的时候进行<code>rebase</code>操作，你可以将<code>git commit</code>暂存操作换乘<code>git stash</code>暂存，这将使你的<code>rebase</code>过程变的无比顺利</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>当进行了一个阶段的开发工作之后，就会需要对代码进行<code>提交</code>操作，推送到远端分支，这部分工作当然可以交给IDE来完成，不过我更推荐使用命令的形式，来更多的理解<code>git的工作原理</code></p>
<blockquote>
<p>  流程：暂存代码<code>-&gt;</code>提交到本地仓库<code>-&gt;</code>推送到远端分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 暂存代码：所有变化提交到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 提交到本地仓库，这步需要简介且明确的写出本次提交的所有内容</span></span><br><span class="line">git commit -m &quot;本次提交内容的注释说明&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 推送到远端分支</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; # 如果你看过了前面的内容后，应该可以轻松地简化这行命令</span><br></pre></td></tr></table></figure>

<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>如果你充分理解了分支操作的本质，就会对冲突的解决应对自如，这里还是给出拉取代码时出现代码冲突情况的解决办法：</p>
<blockquote>
<p>  流程：暂存(压栈)<code>-&gt;</code>拉取代码<code>-&gt;</code>释放代码（弹栈）<code>-&gt;</code>手动合并冲突代码</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果本地代码与线上代码有冲突，git pull 是会报错，如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> error: Your <span class="built_in">local</span> changes to <span class="string">&#x27;-----&#x27;</span> would be overwritten by merge. Aborting.Please, commit your changes or stash them before you can merge.</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那么接下来，将是你需要做的几步：</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 将本地代码暂存，将工作区代码恢复到上一个版本</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 拉取代码，将工作区代码更新为远端最新版本</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 释放代码，也就是弹栈，将之前暂存的代码取出</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 手动合并代码，如果使用ide工具进行，这项工作将变的更加容易</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看代码状态，会展示你这次合并代码过程中又对哪些文件进行了修改</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 之后就是继续进行开发工作，再对新代码进行add、commit操作啦~^v^</span></span><br></pre></td></tr></table></figure>

<h3 id="将本地项目提交到远程仓库（远程仓库是空项目）"><a href="#将本地项目提交到远程仓库（远程仓库是空项目）" class="headerlink" title="将本地项目提交到远程仓库（远程仓库是空项目）"></a>将本地项目提交到远程仓库（远程仓库是空项目）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 先进入项目文件夹</span></span><br><span class="line">cd 当前项目的完整路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 初始化这个目录变成git可以管理的仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 暂存并提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Init Project&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 关联到远程库</span></span><br><span class="line">git remote add origin &lt;你的远程库地址&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）</span></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang</title>
    <url>/2021/06/16/Golang/</url>
    <content><![CDATA[<blockquote>
<p>本文目的是记录我从Java开发转Golang开发的学习经历，分享一下学习过程来帮助想要Java转Golang的朋友一起进步一起学习！</p>
</blockquote>
<span id="more"></span> 

<h1 id="0、安装配置"><a href="#0、安装配置" class="headerlink" title="0、安装配置"></a>0、安装配置</h1><p>下载地址：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<p>下载好了用<code>go version</code>来校验</p>
<p>配置环境：GOPATH、Path</p>
<p>配置好了用<code>go env</code>来校验</p>
<h1 id="1、Golang基础"><a href="#1、Golang基础" class="headerlink" title="1、Golang基础"></a>1、Golang基础</h1><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul>
<li>天生支持并发</li>
<li>企业级编程语言（Golang、Java）</li>
<li>零值机制：天生就有初始值，不用考虑空值情况</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build</span><br><span class="line"><span class="keyword">go</span> build -o <span class="string">&quot;***.exe&quot;</span></span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span> install</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">16</span> <span class="comment">// 声明并赋值</span></span><br><span class="line"><span class="comment">// 类型推导</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span> = <span class="string">&quot;string1&quot;</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;string2&quot;</span> <span class="comment">// 上面可直接写成这样</span></span><br><span class="line"><span class="comment">// 简短变量声明，只能在函数中使用，不能在全局使用</span></span><br><span class="line">s3 := <span class="string">&quot;string3&quot;</span> <span class="comment">// 上面的简写</span></span><br><span class="line"><span class="comment">// 匿名变量(就是一个下划线) -&gt; _ : 匿名变量不占用命名空间，不会分配内存（Lua里叫哑元变量）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;yueyang&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x, _ := foo()</span><br><span class="line">    _, y := foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>函数外每个语句必须以关键字开始（var、func、const等）</li>
<li>:= 不能用于函数外</li>
<li>_用于占位符，表示忽略值</li>
<li>函数内声明变量不使用，编译不能通过（似乎不同版本有不同的要求）</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是恒定不变的值，使用关键字const</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个声明</span></span><br><span class="line"><span class="keyword">const</span> pai = <span class="number">3.1415926</span></span><br><span class="line"><span class="comment">// 批量声明</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	statusOK = <span class="number">200</span></span><br><span class="line">    notFound = <span class="number">404</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 这种批量声明方式，没有赋值的常量默认和上面那个值一样</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="number">200</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br><span class="line"><span class="comment">// iota: 常量计数器, iota将在const关键字出现时重置为0，const中每新增一行常量声明将使iota计数一次（iota可以理解成const语句块的行索引）。使用iota简化定义，在定义枚举时很有用</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    n2		  <span class="comment">// 1</span></span><br><span class="line">    n3		  <span class="comment">// 2</span></span><br><span class="line">    n4		  <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    a2		  <span class="comment">// 1</span></span><br><span class="line">    _		  <span class="comment">// 2</span></span><br><span class="line">    a3		  <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	b1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    b2 = <span class="number">100</span>  <span class="comment">// 100</span></span><br><span class="line">    b3 = <span class="literal">iota</span> <span class="comment">// 2</span></span><br><span class="line">    b4		  <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 多个常量声明在一行</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    c1, c2 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// d1:0+1, d2:0+2</span></span><br><span class="line">    c3, c4 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// d3:1+1, d4:1+2</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// iota的应用，举个例子</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_ = <span class="literal">iota</span></span><br><span class="line">    KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型有整型、浮点型、布尔型、字符串、数组、切片、结构体、函数、map、通道等</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>int8、int16、int32、int64、uint8、uint16、uint32、uint64</p>
<p>特殊整型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uinit</td>
<td align="center">32位操作系统上就是uint32，64位操作系统上就是uint64</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是int32，64位操作系统上就是int64</td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h4 id="八进制-amp-十六进制"><a href="#八进制-amp-十六进制" class="headerlink" title="八进制&amp;十六进制"></a>八进制&amp;十六进制</h4><p>Go语言中无法直接使用二进制，关于八进制和十六进制实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">101</span> <span class="comment">// 十进制</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, num1) <span class="comment">// 输出十进制数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, num1) <span class="comment">// 输出二进制数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, num1) <span class="comment">// 输出八进制数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, num1) <span class="comment">// 输出十六进制数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, num1) <span class="comment">// 输出数据类型</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">077</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">0x123456789abcdef</span> <span class="comment">// 十六进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制声明int8类型</span></span><br><span class="line"><span class="keyword">var</span> num4 <span class="keyword">int8</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure>



<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float32、float64</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f1 := <span class="number">1.2345</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f1) <span class="comment">// float64 默认go语言中小数都是float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p><code>complex128</code>和<code>complex64</code></p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>Go语言中使用<code>bool</code>类型声明布尔型，只有<code>true</code>和<code>false</code>两个值</p>
<p>注意事项：</p>
<ul>
<li>布尔型默认值是<code>false</code></li>
<li>不允许将整型强转为布尔型</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go语言中字符串内部实现使用<code>UTF-8</code>编码，字符串的值为双引号的内容。</p>
<p>Go语言单引号包裹的是字符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">&quot;嘻嘻&quot;</span></span><br><span class="line">s2 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">s3 := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">s4 := <span class="string">&#x27;岳&#x27;</span></span><br><span class="line"><span class="comment">// 字节：1字节 = 8Bit（8个二进制位）</span></span><br><span class="line"><span class="comment">// 定义多行字符串，使用``</span></span><br><span class="line">s5 := <span class="string">`床前明月光</span></span><br><span class="line"><span class="string">疑是地上霜</span></span><br><span class="line"><span class="string">举头望明月</span></span><br><span class="line"><span class="string">低头思故乡</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">求长度</td>
<td align="center">len（str）</td>
</tr>
<tr>
<td align="center">拼接字符串</td>
<td align="center">加号或者fmt.Sprintf()</td>
</tr>
<tr>
<td align="center">分割</td>
<td align="center">strings.Split</td>
</tr>
<tr>
<td align="center">是否包含</td>
<td align="center">strings.contains</td>
</tr>
<tr>
<td align="center">前后缀判断</td>
<td align="center">strings.HasPrefix/strings.HasSuffix</td>
</tr>
<tr>
<td align="center">子串出现的位置</td>
<td align="center">strings.Index()/strings.LastIndex()</td>
</tr>
<tr>
<td align="center">join操作</td>
<td align="center">strings.Join(a []string, sep string)</td>
</tr>
</tbody></table>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>组成字符串的元素称为<code>字符</code>，Go语言字符有两种：</p>
<ol>
<li><code>uint8</code>，或者叫<code>byte</code>类型，代表了ASCII码的一个字符</li>
<li><code>rune</code>，代表一个<code>UTF-8</code>字符，当需要表示中文、日语或者其他复合字符时，就需要用到<code>rune</code>类型。<code>rune</code>类型实际上是一个<code>int32</code></li>
</ol>
<h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>字符串是无法直接修改的，如果修改，可以转换成字符切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s1 := <span class="string">&quot;岳小杨超可爱&quot;</span></span><br><span class="line">    s2 := []<span class="keyword">rune</span>(s1)</span><br><span class="line">    s2[<span class="number">2</span>] = <span class="string">&#x27;羊&#x27;</span></span><br><span class="line">    fmt.Printf(<span class="keyword">string</span>(s2)) <span class="comment">// 将s2强制转换成string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的长度是数组类型的一部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>如果不初始化，默认元素为零值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> nums1 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> nums2 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="keyword">var</span> nums3 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [1, 2, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 方式四</span></span><br><span class="line"><span class="keyword">var</span> nums4 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">4</span>:<span class="number">2</span>&#125; <span class="comment">// [1, 0, 0, 0, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">names := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;岳杨&quot;</span>, <span class="string">&quot;幂律&quot;</span>, <span class="string">&quot;GO语言&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(names); i++ &#123;</span><br><span class="line">    fmt.Println(names[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> names &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 数组是值类型</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 证明数组是值类型</span></span><br><span class="line">nums1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">nums2 := num1</span><br><span class="line">nums2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b1, b2) <span class="comment">// [1, 2, 3] [100, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片<code>Slice</code>是一个拥有相通类型元素的可变长度的序列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums1 []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> nums2 []<span class="keyword">int</span></span><br><span class="line">fmt.Println(nums1 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">fmt.Println(nums2 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">nums1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">nums2 = []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Println(nums1 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">fmt.Println(nums2 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125; <span class="comment">// 切片</span></span><br><span class="line">nums2 := [<span class="number">7</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 数组</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %d\n&quot;</span>, <span class="built_in">len</span>(nums1), <span class="built_in">cap</span>(nums1))</span><br></pre></td></tr></table></figure>

<h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums1 := [<span class="number">7</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 数组</span></span><br><span class="line">nums2 := nums1[<span class="number">0</span>, <span class="number">4</span>] <span class="comment">// [0, 1, 2, 3] // 数组得到切片，左闭右开</span></span><br><span class="line">nums3 := nums1[<span class="number">1</span>:]</span><br><span class="line">nums4 := nums1[:<span class="number">4</span>]</span><br><span class="line">nums5 := nums1[:]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、切片是引用类型，真正的数组都是保存在底层的数组里。</p>
<p>2、一个<code>nil</code>的切片是没有底层数组的。</p>
<p>3、判断切片为空应该判断<code>len() == 0</code>。</p>
<p>4、<code>nil</code>的切片就算没有底层数组，也可以进行<code>append</code>操作，<code>append</code>会自动为<code>nil</code>切片创建空间。</p>
</blockquote>
<h4 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>) <span class="comment">// 参数：切片类型，长度，容量</span></span><br></pre></td></tr></table></figure>

<h4 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">nums1[<span class="number">3</span>] = <span class="number">4</span> <span class="comment">// 错误写法，切片超过容量导致编译错误：索引越界</span></span><br><span class="line">fmt.Println(nums1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;%v %d %d&quot;</span>, nums1, <span class="built_in">len</span>(nums1), <span class="built_in">cap</span>(nums1)) <span class="comment">// [1, 2, 3] len=3 cap=3</span></span><br><span class="line">nums1 = <span class="built_in">append</span>(nums1, <span class="number">4</span>) <span class="comment">// 调用append函数必须用原来的切片变量接收返回值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;%v %d %d&quot;</span>, nums1, <span class="built_in">len</span>(nums1), <span class="built_in">cap</span>(nums1)) <span class="comment">// [1, 2, 3, 4] len=4 cap=6</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用<code>append</code>函数必须用原来的切片变量接收返回值，底层涉及到数组的重新分配内存空间</p>
<p><code>append</code>函数会为空切片创建内存空间，并且会对容量不够的切片进行扩容操作</p>
</blockquote>
<h2 id="fmt包"><a href="#fmt包" class="headerlink" title="fmt包"></a>fmt包</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, num)</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;String&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, str)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典用法</span></span><br><span class="line"><span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 特殊用法</span></span><br><span class="line"><span class="keyword">if</span> age := <span class="number">19</span>; age &gt; <span class="number">18</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;青年&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件语句;结束语句 &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    <span class="keyword">break</span> <span class="comment">// 跳出for循环</span></span><br><span class="line">    <span class="keyword">continue</span> <span class="comment">// 跳过for循环</span></span><br><span class="line">    <span class="keyword">goto</span> breakLabel<span class="comment">// 跳出到标签</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">breakLabel: <span class="comment">// 标签</span></span><br><span class="line">fmt.Println(<span class="string">&quot;跳出来了，嘻嘻&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;yueyang&quot;</span></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d, %c\n&quot;</span>, i, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> 值&#123;</span><br><span class="line">    <span class="keyword">case</span> 值:</span><br><span class="line">    	<span class="comment">// 操作</span></span><br><span class="line">    <span class="keyword">case</span> 值:</span><br><span class="line">    	<span class="comment">// 操作</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	<span class="comment">// 操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> 初始化; 值&#123;</span><br><span class="line">    <span class="keyword">case</span> 值,值,值:</span><br><span class="line">    	<span class="comment">// 操作</span></span><br><span class="line">    	<span class="keyword">fallthrough</span> <span class="comment">// 向下穿透一个</span></span><br><span class="line">    <span class="keyword">case</span> 值,值,值:</span><br><span class="line">    	<span class="comment">// 操作</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	<span class="comment">// 操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>&amp;</code>按位与</p>
<p><code>|</code>按位或</p>
<p><code>^</code>按位异或</p>
<p><code>&lt;&lt;</code>左移</p>
<p><code>&gt;&gt;</code>右移</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>取地址操作符<code>&amp;</code></p>
<p>取值操作符<code>*</code></p>
<p>注意事项：</p>
<ul>
<li>  引用类型变量不仅要声明还要分配内存空间</li>
</ul>
<p>那么就引入了两个初始化方式<code>new</code> <code>make</code></p>
<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p><code>new</code>函数不太常用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span> // 接收一个类型，返回该类型的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="make函数-1"><a href="#make函数-1" class="headerlink" title="make函数"></a>make函数</h3><p>make也是用于内存分配的，区别于new，make函数只作用于slice、map、chan类型的内存创建，由于这些类型本身就是引用类型，make返回的就是类型本身。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span> // 接收一个类型和容量大小，返回类型本身</span></span><br></pre></td></tr></table></figure>

<p>make函数是不可替代的函数，slice、map、chan都需要make函数初始化才能进行操作。</p>
<h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><ol>
<li> 两者都是用来创建内存的</li>
<li> new用于类型的内存分配，内存对应的值为类型的零值，返回的是指向类型的指针</li>
<li> make作用于slice、map、chan类型，返回类型本身</li>
</ol>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>类型定义和类型别名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a NewInt</span><br><span class="line">    <span class="keyword">var</span> b MyInt</span><br><span class="line">    fmt.Println(<span class="string">&quot;%T&quot;</span>, a) <span class="comment">// main.NewInt</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;%T&quot;</span>, b) <span class="comment">// int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言通过<code>struct</code>来面向对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	person.name = <span class="string">&quot;yueyang&quot;</span></span><br><span class="line">	person.age = <span class="number">24</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, person) <span class="comment">// &#123;yueyang, 24&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, person) <span class="comment">// main.Person&#123;name:&quot;yueyang&quot;, age:24&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">	user.Name = <span class="string">&quot;yueyang&quot;</span></span><br><span class="line">	user.Age = <span class="number">24</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user) <span class="comment">// struct &#123; Name string; Age int &#125;&#123;Name:&quot;yueyang&quot;, Age:24&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="built_in">new</span>(Person)</span><br><span class="line">    fmt.Printf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2、Golang标准库"><a href="#2、Golang标准库" class="headerlink" title="2、Golang标准库"></a>2、Golang标准库</h1><h2 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h2><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换成整形</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Itoa"><a href="#Itoa" class="headerlink" title="Itoa()"></a>Itoa()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将整形转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析字符串成布尔类型, 可以接受1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False; 否则返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(value <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">bool</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析整形</span></span><br><span class="line"><span class="comment">// s: 要解析的字符串</span></span><br><span class="line"><span class="comment">// base: 指定进制数（2到36）</span></span><br><span class="line"><span class="comment">// bitSize: 要转换的无溢出整形类型0、8、16、32、64分别代表int、int8、int16、int32、int64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似于ParseInt(), 区别在于不能接受正负号, 返回uint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似于ParseInt(), 函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字符串true或者false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回i的base进制的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FormatInt()的无符号整数版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h1 id="3、异常机制"><a href="#3、异常机制" class="headerlink" title="3、异常机制"></a>3、异常机制</h1><blockquote>
<p>  go中追求简洁优雅，使用多返回值来返回错误解决异常情况。只有在除数为零时，才会真正的使用异常机制，<code>defer</code>、<code>panic</code>、<code>recover</code></p>
</blockquote>
<p>底层实现看<a href="https://blog.csdn.net/shidantong/article/details/106341159">这篇文章</a></p>
<blockquote>
<p>  调用 defer 关键字会立刻对函数中引用的外部参数进行拷贝</p>
</blockquote>
<h1 id="4、Golang第三方包"><a href="#4、Golang第三方包" class="headerlink" title="4、Golang第三方包"></a>4、Golang第三方包</h1><h2 id="github-com-gin-gonic-gin"><a href="#github-com-gin-gonic-gin" class="headerlink" title="github.com/gin-gonic/gin"></a>github.com/gin-gonic/gin</h2><p>gin包提供golang一个基本web框架</p>
<p>gin.Context实现了Golang标准库中的net/http下Handler接口中的唯一方法ServeHttp(ReponseWriter, *Request)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Handler responds to an HTTP request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ServeHTTP should write reply headers and data to the ResponseWriter</span></span><br><span class="line"><span class="comment">// and then return. Returning signals that the request is finished; it</span></span><br><span class="line"><span class="comment">// is not valid to use the ResponseWriter or read from the</span></span><br><span class="line"><span class="comment">// Request.Body after or concurrently with the completion of the</span></span><br><span class="line"><span class="comment">// ServeHTTP call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Depending on the HTTP client software, HTTP protocol version, and</span></span><br><span class="line"><span class="comment">// any intermediaries between the client and the Go server, it may not</span></span><br><span class="line"><span class="comment">// be possible to read from the Request.Body after writing to the</span></span><br><span class="line"><span class="comment">// ResponseWriter. Cautious handlers should read the Request.Body</span></span><br><span class="line"><span class="comment">// first, and then reply.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Except for reading the body, handlers should not modify the</span></span><br><span class="line"><span class="comment">// provided Request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</span></span><br><span class="line"><span class="comment">// that the effect of the panic was isolated to the active request.</span></span><br><span class="line"><span class="comment">// It recovers the panic, logs a stack trace to the server error log,</span></span><br><span class="line"><span class="comment">// and either closes the network connection or sends an HTTP/2</span></span><br><span class="line"><span class="comment">// RST_STREAM, depending on the HTTP protocol. To abort a handler so</span></span><br><span class="line"><span class="comment">// the client sees an interrupted response but the server doesn&#x27;t log</span></span><br><span class="line"><span class="comment">// an error, panic with the value ErrAbortHandler.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是Golang实现WebService最基础的接口，通过实现其方法来</p>
<h1 id="Golang的编译过程"><a href="#Golang的编译过程" class="headerlink" title="Golang的编译过程"></a>Golang的编译过程</h1><ol>
<li> 编译器在执行完语法分析之后会输出一个抽象语法树</li>
</ol>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpServletRequest request 简单使用方法</title>
    <url>/2020/08/18/HttpServletRequest-request-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>  Java底层调用Servlet中HttpServletRequest的原理和常用函数</p>
</blockquote>
<span id="more"></span>

<h3 id="HttpServletRequest-详解"><a href="#HttpServletRequest-详解" class="headerlink" title="HttpServletRequest 详解"></a>HttpServletRequest 详解</h3><p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。</p>
<p>常用到的几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestURL() 返回全路径</span><br><span class="line">request.getRequestURI() 返回除去host（域名或者ip）部分的路径</span><br><span class="line">request.getContextPath() 返回工程名部分，如果工程映射为/，此处返回则为空</span><br><span class="line">request.getServletPath() 返回除去host和工程名部分的路径</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例如获取验证码的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestURL() is : http:<span class="comment">//localhost:8080/captchaImage</span></span><br><span class="line">request.getRequestURI() is : /captchaImage</span><br><span class="line">request.getContextPath() is : </span><br><span class="line">request.getServletPath() is : /captchaImage</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例如返回图片文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestURL() is : http:<span class="comment">//localhost:8080/profile/avatar/2020/07/31/8f04b7aa-c799-405b-90b0-4cfe36d89f35.jpeg</span></span><br><span class="line">request.getRequestURI() is : /profile/avatar/<span class="number">2020</span>/<span class="number">07</span>/<span class="number">31</span>/8f04b7aa-c799-405b-90b0-4cfe36d89f35.jpeg</span><br><span class="line">request.getContextPath() is : </span><br><span class="line">request.getServletPath() is : /profile/avatar/<span class="number">2020</span>/<span class="number">07</span>/<span class="number">31</span>/8f04b7aa-c799-405b-90b0-4cfe36d89f35.jpeg</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JAVA获取主机硬件唯一标识CPUID+MAC地址。</title>
    <url>/2020/08/17/Java%E8%8E%B7%E5%8F%96%E7%A1%AC%E4%BB%B6%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86CPUID+MAC%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<blockquote>
<p>  Java为表示主机的唯一性而做出的获取主机CPUID和MAC地址时所进行的操作，整体是为了解决不同主机能在访问服务器时能通过某个唯一标识来进行权限认证，以此达到控制权限的目的</p>
</blockquote>
<span id="more"></span>

<h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>结合上一篇博文，我需要拿到一台主机的唯一标识，并且这个标识是不可修改的，经查阅发现，MAC地址虽然是唯一标识，但是可修改，所以不可采用。现在选取当前主机唯一标识——CPU序列，本篇说下LINUX系统和WINSOWS系统获取CPU序列，顺带说下MAC地址的方法。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主要思路就是使用Runtime.getRuntime().exec()执行命令来获取参数。毕竟是Java代码，要考虑多个平台的问题，而且linux和windows系统的命令又不同，所以分出处理。不多说，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前系统CPU序列，可区分linux系统和windows系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCpuId</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String cpuId;</span><br><span class="line">    <span class="comment">// 获取当前操作系统名称</span></span><br><span class="line">    String os = System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    os = os.toUpperCase();</span><br><span class="line">    System.out.println(os);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linux系统用Runtime.getRuntime().exec()执行 dmidecode -t processor 查询cpu序列</span></span><br><span class="line">    <span class="comment">// windows系统用 wmic cpu get ProcessorId 查看cpu序列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;LINUX&quot;</span>.equals(os)) &#123;</span><br><span class="line">        cpuId = getLinuxCpuId(<span class="string">&quot;dmidecode -t processor | grep &#x27;ID&#x27;&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cpuId = getWindowsCpuId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cpuId.toUpperCase().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取linux系统CPU序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLinuxCpuId</span><span class="params">(String cmd, String record, String symbol)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String execResult = executeLinuxCmd(cmd);</span><br><span class="line">    String[] infos = execResult.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String info : infos) &#123;</span><br><span class="line">        info = info.trim();</span><br><span class="line">        <span class="keyword">if</span> (info.indexOf(record) != -<span class="number">1</span>) &#123;</span><br><span class="line">            info.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            String[] sn = info.split(symbol);</span><br><span class="line">            <span class="keyword">return</span> sn[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">executeLinuxCmd</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Runtime run = Runtime.getRuntime();</span><br><span class="line">    Process process;</span><br><span class="line">    process = run.exec(cmd);</span><br><span class="line">    InputStream in = process.getInputStream();</span><br><span class="line">    BufferedReader bs = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">    StringBuffer out = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n; (n = in.read(b)) != -<span class="number">1</span>; ) &#123;</span><br><span class="line">        out.append(<span class="keyword">new</span> String(b, <span class="number">0</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    process.destroy();</span><br><span class="line">    <span class="keyword">return</span> out.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取windows系统CPU序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getWindowsCpuId</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Process process = Runtime.getRuntime().exec(</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;wmic&quot;</span>, <span class="string">&quot;cpu&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;ProcessorId&quot;</span>&#125;);</span><br><span class="line">    process.getOutputStream().close();</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(process.getInputStream());</span><br><span class="line">    sc.next();</span><br><span class="line">    String serial = sc.next();</span><br><span class="line">    <span class="keyword">return</span> serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>SQL优化笔记</title>
    <url>/2021/05/31/SQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>最近更新时间：2021-05-31 09:41:56</p>
</blockquote>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SQL优化一般遵循五个原则：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">减少数据访问</span><br><span class="line">返回更少的数据：只返回需要的字段和数据分页处理，减少磁盘IO和网络IO</span><br><span class="line">减少交互次数：批量DML操作，来减少与数据库的交互次数</span><br><span class="line">减少服务器CPU开销：减少数据库排序操作以及全表查询，减少CPU内存占用</span><br><span class="line">利用更多资源：使用表分区，增加并行操作，最大限度使用CPU资源</span><br></pre></td></tr></table></figure>

<p>总结一下就是</p>
<blockquote>
<ul>
<li>最大化利用索</li>
<li>尽可能避免全表扫描</li>
<li>减少无效数据的查询</li>
</ul>
</blockquote>
<h1 id="SELECT语句——语法顺序"><a href="#SELECT语句——语法顺序" class="headerlink" title="SELECT语句——语法顺序"></a>SELECT语句——语法顺序</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">distinct</span> <span class="operator">&lt;</span>查询字段<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span> <span class="keyword">join</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>分组字段<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;</span>分组条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>排序字段<span class="operator">&gt;</span></span><br><span class="line">limit <span class="operator">&lt;</span>参数<span class="number">1</span>, 参数<span class="number">2</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="SELECT语句——执行顺序"><a href="#SELECT语句——执行顺序" class="headerlink" title="SELECT语句——执行顺序"></a>SELECT语句——执行顺序</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="comment">-- 选取表, 如果是多个表通过笛卡尔积形成一个表</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span> <span class="comment">-- 对from的表进行筛选</span></span><br><span class="line"><span class="keyword">join</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="comment">-- 添加字段到on之后的结果中</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span> <span class="comment">-- 对结果再进行筛选</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>分组字段<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;</span>分组条件<span class="operator">&gt;</span> <span class="comment">-- 对分组之后的结果再进行筛选</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>字段<span class="operator">&gt;</span> <span class="comment">-- 筛选列, 返回的单列必须在group by中</span></span><br><span class="line"><span class="keyword">distinct</span> <span class="comment">-- 数据去重</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>排序字段<span class="operator">&gt;</span> <span class="comment">-- 排序</span></span><br><span class="line">limit <span class="comment">-- 行数限制</span></span><br></pre></td></tr></table></figure>

<h1 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h1><h3 id="一、避免不走索引的场景"><a href="#一、避免不走索引的场景" class="headerlink" title="一、避免不走索引的场景"></a>一、避免不走索引的场景</h3><ol>
<li><p>避免在<code>字段开头模糊查询</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 尽量避免</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%岳%&#x27;</span></span><br><span class="line"><span class="comment">-- 优化方式</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;岳%&#x27;</span></span><br><span class="line"><span class="comment">-- 如果必须要在字段开头模糊查询, 建议使用以下策略:</span></span><br><span class="line"><span class="comment">-- 1. 使用FullText全文检索</span></span><br><span class="line"><span class="comment">-- 2. 数据量较大时使用ElasticSearch</span></span><br><span class="line"><span class="comment">-- 3. 使用MySQL内置函数INSTR(str,substr)来匹配</span></span><br><span class="line"><span class="comment">-- 4. 如果数据量少, 就不用花里胡哨的使用策略了, 直接%%</span></span><br></pre></td></tr></table></figure></li>
<li><p>避免使用<code>or</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;yueyang&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;mengwu&#x27;</span></span><br><span class="line"><span class="comment">-- 推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;yueyang&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;mengwu&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>避免<code>进行null值判断</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 优化方式:给字段设置默认值</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>避免<code>在where条件等号左侧使用表达式</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score<span class="operator">/</span><span class="number">10</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="comment">-- 优化方式:把左侧表达式的操作移到右侧</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score <span class="operator">=</span> <span class="number">8</span> <span class="operator">*</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li><p>// </p>
</li>
</ol>
<h3 id="二、SELECT语句优化"><a href="#二、SELECT语句优化" class="headerlink" title="二、SELECT语句优化"></a>二、SELECT语句优化</h3><ol>
<li><p>禁止出现<code>select *</code>，需要哪些字段必须明确标明， 原因是：</p>
<ol>
<li>增加了查询分析器解析成本</li>
<li>容易与resultMap配置不一致</li>
<li>无用字段增加了网络IO</li>
</ol>
</li>
<li><p>多表关联查询时，小表在前，大表在后</p>
<p>多表关联查询会全表扫描第一张表，所以第一张表尽可能小会提升不少性能</p>
</li>
<li><p>使用表的别名</p>
<p>SQL连接多个表时，使用表的别名并用表的别名来指定字段会减少解析时间</p>
</li>
<li><p>//</p>
</li>
</ol>
<h3 id="三、DML语句优化"><a href="#三、DML语句优化" class="headerlink" title="三、DML语句优化"></a>三、DML语句优化</h3><ol>
<li><p>批量<code>insert</code>数据使用<code>insert</code>多个值的方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, name, age) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;yueyang&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, name, age) <span class="keyword">values</span> (<span class="number">2</span>, <span class="string">&#x27;mengwu&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">-- 推荐</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, name, age) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;yueyang&#x27;</span>, <span class="number">18</span>),(<span class="number">2</span>, <span class="string">&#x27;mengwu&#x27;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>//</p>
</li>
</ol>
<h3 id="四、查询条件优化"><a href="#四、查询条件优化" class="headerlink" title="四、查询条件优化"></a>四、查询条件优化</h3><ol>
<li><p>对于复杂查询，使用中间表暂存数据</p>
</li>
<li><p>优化<code>group by</code>语句</p>
<p>默认情况下, MySQL会对<code>group by</code>中所有的值进行排序，也就相当于在后面添加了一段<code>order by</code></p>
<p>因此，查询<code>group by</code>如果你不想对分组数据进行排序，可以在最后加上<code>order by null</code></p>
</li>
<li><p>优化<code>join</code>语句</p>
<p>对于逻辑顺畅的子查询来说，有时使用<code>join</code>替代会有更好的效率</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询没有成绩的学生ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> id <span class="keyword">from</span> grade <span class="keyword">where</span> score <span class="operator">=</span> <span class="number">0</span>);</span><br><span class="line"><span class="comment">-- 优化方式:减少了内存创建临时表的损耗 </span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> grade <span class="keyword">on</span> user.id <span class="operator">=</span> grade.id <span class="keyword">where</span> grade.socre <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>优化<code>union</code>语句</p>
<p>MySQL通过创建临时表并填充临时表的方式来执行<code>union</code>查询。</p>
<p>使用<code>union</code>时，会隐式的给临时表加<code>distinct</code>，从而对整个临时表做唯一性校验，非常损耗性能。因此如果不是非要去重，非常不建议使用<code>union</code>，建议改成<code>union all</code>。</p>
</li>
<li><p>合理的分页方式进行分页优化（^_^这个地方我还没学会呢，大家自己去研究深入一下，欢迎给我留言）</p>
</li>
<li><p>//</p>
</li>
</ol>
<h3 id="五、建表优化"><a href="#五、建表优化" class="headerlink" title="五、建表优化"></a>五、建表优化</h3><ol>
<li><p>在表中建立<code>索引</code>，优先考虑<code>where</code>、<code>order by</code>使用到的字段。</p>
</li>
<li><p>尽量使用数字型字段</p>
<p>举个例子：性别男（1）女（2），就不要设计成字符型字段，会增加查询和连接性能，并增加存储开销</p>
</li>
</ol>
<h3 id="六、事务优化"><a href="#六、事务优化" class="headerlink" title="六、事务优化"></a>六、事务优化</h3><ol>
<li><pre><code class="mysql"> -- 查询事务执行的锁情况
 select * from INFORMATION_SCHEMA.INNODB_TRX;
</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2021/05/26/SpringCloud/</url>
    <content><![CDATA[<blockquote>
<p>  学习SpringCloud时参考的学习资料以及自己的理解和整理</p>
</blockquote>
<span id="more"></span>

<h1 id="Spring-Cloud-微服务工具集v1-1"><a href="#Spring-Cloud-微服务工具集v1-1" class="headerlink" title="Spring Cloud 微服务工具集v1.1"></a>Spring Cloud 微服务工具集v1.1</h1><ul>
<li><strong>版本: Hoxton SR6</strong></li>
</ul>
<h2 id="1-什么是微服务"><a href="#1-什么是微服务" class="headerlink" title="1.什么是微服务"></a>1.什么是微服务</h2><ul>
<li>官网: <a href="https://www.martinfowler.com/articles/microservices.html">https://www.martinfowler.com/articles/microservices.html</a></li>
</ul>
<p>In short, the microservice architectural(架构) style is an approach to developing a single application as <code>a suite(系列) of small services</code>, each <code>running in its own process(进程)</code> and communicating with lightweight mechanisms, often an HTTP resource API. These services are <code>built around business(业务) capabilities(单元)</code> and <code>independently(独立) deployable(部署)</code> by fully automated deployment machinery. <code>There is a bare(基于) minimum of centralized(分布式) management(管理) of these services</code>, which may be written in different programming languages and use different data storage technologies.                        —–[摘自官网]</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> a suite of small services                      				--一系列微小服务</span><br><span class="line"><span class="bullet">-</span> running in its own process                                    --运行在自己的进程里</span><br><span class="line"><span class="bullet">-</span> built around business capabilities                            --围绕自己的业务开发</span><br><span class="line"><span class="bullet">-</span> independently deployable                                      --独立部署</span><br><span class="line"><span class="bullet">-</span> bare minimum of centralized management of these services      --基于分布式管理</span><br></pre></td></tr></table></figure>

<ul>
<li>官方定义:<strong>微服务就是由一系列围绕自己业务开发的微小服务构成,他们独立部署运行在自己的进程里,基于分布式的管理</strong></li>
</ul>
<hr>
<h2 id="2-为什么是微服务"><a href="#2-为什么是微服务" class="headerlink" title="2.为什么是微服务?"></a>2.为什么是微服务?</h2><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.优点</span></span><br><span class="line"><span class="bullet">-</span>	单一架构模式在项目初期很小的时候开发方便，测试方便，部署方便，运行良好。</span><br><span class="line"><span class="section"># 2.缺点</span></span><br><span class="line"><span class="bullet">-</span> 应用随着时间的推进，加入的功能越来越多，最终会变得巨大，一个项目中很有可能数百万行的代码，互相之间繁琐的jar包。</span><br><span class="line"><span class="bullet">-</span> 久而久之，开发效率低，代码维护困难</span><br><span class="line"><span class="bullet">-</span> 还有一个如果想整体应用采用新的技术，新的框架或者语言，那是不可能的。</span><br><span class="line"><span class="bullet">-</span> 任意模块的漏洞或者错误都会影响这个应用，降低系统的可靠性</span><br></pre></td></tr></table></figure>

<h3 id="微服务架构应用"><a href="#微服务架构应用" class="headerlink" title="微服务架构应用"></a>微服务架构应用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.优点</span></span><br><span class="line"><span class="bullet">-</span> 将服务拆分成多个单一职责的小的服务，进行单独部署，服务之间通过网络进行通信</span><br><span class="line"><span class="bullet">-</span> 每个服务应该有自己单独的管理团队，高度自治</span><br><span class="line"><span class="bullet">-</span> 服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</span><br><span class="line"><span class="section"># 2.缺点</span></span><br><span class="line"><span class="bullet">-</span> 开发人员要处理分布式系统的复杂性</span><br><span class="line"><span class="bullet">-</span> 多服务运维难度，随着服务的增加，运维的压力也在增大</span><br><span class="line"><span class="bullet">-</span> 服务治理 和 服务监控 关键</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-微服务的解决方案"><a href="#3-微服务的解决方案" class="headerlink" title="3.微服务的解决方案"></a>3.微服务的解决方案</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Dubbo (阿里系)</span></span><br><span class="line"><span class="section"># Spring Cloud:</span></span><br><span class="line"><span class="bullet">-</span> Spring Cloud NetFlix  </span><br><span class="line"><span class="bullet">-</span> Spring Cloud alibaba</span><br><span class="line"><span class="bullet">-</span> Spring Cloud Spring</span><br></pre></td></tr></table></figure>

<h2 id="4-什么是SpringCloud"><a href="#4-什么是SpringCloud" class="headerlink" title="4.什么是SpringCloud"></a>4.什么是SpringCloud</h2><blockquote>
<p>springcloud是一个含概多个子项目的开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.SpringCloud在整合过程中主要是针对Netflix(耐非)开源组件的封装.SpringCloud的出现真正的简化了分布式架构的开发。NetFlix 是美国的一个在线视频网站,微服务业的翘楚,他是公认的大规模生产级微服务的杰出实践者,NetFlix的开源组件已经在他大规模分布式微服务环境中经过多年的生产实战验证,因此Spring Cloud中很多组件都是基于NetFlix</p>
</blockquote>
<h3 id="核心架构及其组件"><a href="#核心架构及其组件" class="headerlink" title="核心架构及其组件"></a>核心架构及其组件</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.核心组件说明</span></span><br><span class="line"><span class="bullet">-</span> eurekaserver、consul、nacos  	 服务注册中心组件</span><br><span class="line"><span class="bullet">-</span> rabbion &amp; openfeign  			  服务负载均衡 和 服务调用组件</span><br><span class="line"><span class="bullet">-</span> hystrix &amp; hystrix dashboard     服务断路器  和  服务监控组件</span><br><span class="line"><span class="bullet">-</span> zuul、gateway 					 服务网关组件</span><br><span class="line"><span class="bullet">-</span> config 						  统一配置中心组件</span><br><span class="line"><span class="bullet">-</span> bus                             消息总线组件</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-环境搭建"><a href="#5-环境搭建" class="headerlink" title="5.环境搭建"></a>5.环境搭建</h2><h3 id="版本命名"><a href="#版本命名" class="headerlink" title="版本命名"></a>版本命名</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 伦敦地铁站名称 [了解]</span></span><br><span class="line"><span class="bullet">-</span> Angel、Brixton、Camden、Dalston、Edgware、Finchley、Greenwich、Hoxton</span><br></pre></td></tr></table></figure>

<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> Finchley 									版本基于springboot2.0.x版本进行构建,不能兼容1.x版本</span><br><span class="line"><span class="bullet">-</span> Greenwich									版本基于springboot2.1.x版本进行构建,不能兼容1.x版本</span><br><span class="line"><span class="bullet">-</span> Hoxton									版本基于springboot2.2.x版本进行构建</span><br></pre></td></tr></table></figure>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> springboot 2.2.5.RELEASE</span><br><span class="line"><span class="bullet">-</span> springcloud Hoxton.SR6</span><br><span class="line"><span class="bullet">-</span> java8</span><br><span class="line"><span class="bullet">-</span> maven 3.3.9 </span><br><span class="line"><span class="bullet">-</span> idea 2018.3.5</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.创建springboot项目 指定版本为 2.2.5版本</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.引入springcloud的版本管理</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义springcloud使用版本号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR6<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局管理springcloud版本,并不会引入具体依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.完成上述操作springboot与springcloud环境搭建完成</span></span><br><span class="line"><span class="bullet">-</span> 接下来就是使用到具体的springcloud组件,在项目中引入具体的组件即可</span><br></pre></td></tr></table></figure>

<h2 id="6-服务注册中心"><a href="#6-服务注册中心" class="headerlink" title="6.服务注册中心"></a>6.服务注册中心</h2><h3 id="什么服务注册中心"><a href="#什么服务注册中心" class="headerlink" title="什么服务注册中心"></a>什么服务注册中心</h3><p>所谓服务注册中心就是在整个的微服务架构中单独提出一个服务，这个服务不完成系统的任何的业务功能，仅仅用来完成对整个微服务系统的服务注册和服务发现，以及对服务健康状态的监控和管理功能。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务注册中心</span></span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务的信息进行存储，如微服务的名称、IP、端口等</span><br><span class="line"><span class="bullet">-</span> 可以在进行服务调用时通过服务发现查询可用的微服务列表及网络地址进行服务调用</span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务进行心跳检测，如发现某实例长时间无法访问，就会从服务注册表移除该实例。</span><br></pre></td></tr></table></figure>

<h3 id="常用的注册中心"><a href="#常用的注册中心" class="headerlink" title="常用的注册中心"></a>常用的注册中心</h3><p>springcloud支持的多种注册中心Eureka、Consul、Zookeeper、以及阿里巴巴推出Nacos。这些注册中心在本质上都是用来管理服务的注册和发现以及服务状态的检查的。</p>
<h4 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1.Eureka"></a>1.Eureka</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务。SpringCloud将它集成在其子项目spring-cloud-netflix中，		以实现SpringCloud的服务注册和发现功能。</span><br><span class="line"><span class="bullet">-</span> Eureka包含两个组件：Eureka Server和Eureka Client。</span><br></pre></td></tr></table></figure>

<h5 id="Eureka-停止更新不推荐使用了"><a href="#Eureka-停止更新不推荐使用了" class="headerlink" title="Eureka 停止更新不推荐使用了"></a>Eureka 停止更新不推荐使用了</h5><h4 id="2-Consul"><a href="#2-Consul" class="headerlink" title="2.Consul"></a>2.Consul</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.consul 简介</span></span><br><span class="line"><span class="bullet">-</span> https://www.consul.io</span><br><span class="line"><span class="bullet">-</span> consul是一个可以提供服务发现，健康检查，多数据中心，Key/Value存储等功能的分布式服务框架，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、Windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署。</span><br></pre></td></tr></table></figure>

<h5 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.下载consul</span></span><br><span class="line"><span class="bullet">-</span> https://www.consul.io/downloads</span><br><span class="line"><span class="section"># 2.安装consul</span></span><br><span class="line"><span class="section"># 3.根据解压缩目录配置环境变量</span></span><br><span class="line"><span class="section"># 4.查看consul环境变量是否配置成功,执行命令出现如下信息代表成功</span></span><br><span class="line"><span class="bullet">-</span> consul -v</span><br><span class="line"><span class="section"># 5.启动consul服务</span></span><br><span class="line"><span class="bullet">-</span> consul agent -dev</span><br><span class="line"><span class="section"># 6.访问consul的web服务端口</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:8500</span><br><span class="line"><span class="code">	`consul默认服务端口是8500</span></span><br></pre></td></tr></table></figure>

<h5 id="开发consul-客户端即微服务"><a href="#开发consul-客户端即微服务" class="headerlink" title="开发consul 客户端即微服务"></a>开发consul 客户端即微服务</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建项目并引入consul客户端依赖</span></span><br><span class="line">&lt;!--引入consul依赖--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.cloud<span class="xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-cloud-starter-consul-discovery<span class="xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="section"># 2.编写properties配置</span></span><br><span class="line">server.port=8889</span><br><span class="line">spring.application.name=consulclient8889</span><br><span class="line">spring.cloud.consul.host=localhost														#注册consul服务的主机</span><br><span class="line">spring.cloud.consul.port=8500																	#注册consul服务的端口号</span><br><span class="line"><span class="section"># 3.启动服务查看consul界面服务信息</span></span><br><span class="line"><span class="bullet">-</span> 访问localhost:8500</span><br></pre></td></tr></table></figure>

<h5 id="consul-开启健康监控检查"><a href="#consul-开启健康监控检查" class="headerlink" title="consul 开启健康监控检查"></a>consul 开启健康监控检查</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启consul健康监控</span></span><br><span class="line"><span class="bullet">-</span> 默认情况consul监控健康是开启的,但是必须依赖健康监控依赖才能正确监控健康状态所以直接启动会显示错误,引入健康监控依赖之后服务正常</span><br><span class="line">&lt;!-- 这个包是用做健康度监控的--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.boot<span class="xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-boot-starter-actuator<span class="xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="consul-关闭健康监控检查"><a href="#consul-关闭健康监控检查" class="headerlink" title="consul 关闭健康监控检查"></a>consul 关闭健康监控检查</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.consul.discovery.register-health-check</span>=<span class="string">false	    						#关闭consu了服务的健康检查[不推荐]</span></span><br><span class="line"><span class="meta">spring.cloud.consul.discovery.service-name</span>=<span class="string">$&#123;spring.application.name&#125; 					#指定注册的服务名称 默认就是应用名</span></span><br></pre></td></tr></table></figure>

<h3 id="不同注册中心区别"><a href="#不同注册中心区别" class="headerlink" title="不同注册中心区别"></a>不同注册中心区别</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.CAP定理</span></span><br><span class="line"><span class="bullet">-</span> CAP定理：CAP定理又称CAP原则，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</span><br><span class="line"><span class="code">	`一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</span></span><br><span class="line"><span class="code">	`可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</span></span><br><span class="line"><span class="code">	`分区容忍性（P），就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.Eureka特点</span></span><br><span class="line"><span class="bullet">-</span> Eureka中没有使用任何的数据强一致性算法保证不同集群间的Server的数据一致，仅通过数据拷贝的方式争取注册中心数据的最终一致性，虽然放弃数据强一致性但是换来了Server的可用性，降低了注册的代价，提高了集群运行的健壮性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.Consul特点</span></span><br><span class="line"><span class="bullet">-</span> 基于Raft算法，Consul提供强一致性的注册中心服务，但是由于Leader节点承担了所有的处理工作，势必加大了注册和发现的代价，降低了服务的可用性。通过Gossip协议，Consul可以很好地监控Consul集群的运行，同时可以方便通知各类事件，如Leader选择发生、Server地址变更等。</span><br><span class="line"></span><br><span class="line"><span class="section"># 4.zookeeper特点</span></span><br><span class="line"><span class="bullet">-</span> 基于Zab协议，Zookeeper可以用于构建具备数据强一致性的服务注册与发现中心，而与此相对地牺牲了服务的可用性和提高了注册需要的时间。</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CWeiBo%5Csource%5Cnotes%5Cimages%5Cimage-20210527110515877.png" alt="image-20210527110515877"></p>
<hr>
<h2 id="7-服务间通信方式"><a href="#7-服务间通信方式" class="headerlink" title="7. 服务间通信方式"></a>7. 服务间通信方式</h2><p>接下来在整个微服务架构中,我们比较关心的就是服务间的服务改如何调用,有哪些调用方式?</p>
<blockquote>
<p>在springcloud中服务间调用方式主要是使用 http restful方式进行服务间调用</p>
</blockquote>
<h3 id="基于RestTemplate的服务调用"><a href="#基于RestTemplate的服务调用" class="headerlink" title="基于RestTemplate的服务调用"></a>基于RestTemplate的服务调用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。</span><br></pre></td></tr></table></figure>

<h4 id="1-RestTemplate-服务调用"><a href="#1-RestTemplate-服务调用" class="headerlink" title="1. RestTemplate 服务调用"></a>1. RestTemplate 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建两个服务并注册到consul注册中心中</span></span><br><span class="line"><span class="bullet">-</span> users    代表用户服务 端口为 9999</span><br><span class="line"><span class="bullet">-</span> products 代表商品服务 端口为 9998</span><br><span class="line"><span class="code">	`注意:这里服务仅仅用来测试,没有实际业务意义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.在商品服务中提供服务方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;商品服务查询所有调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;服务调用成功,服务提供端口为: &quot;</span>+port);</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在用户服务中使用restTemplate进行调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;调用用户服务...&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用restTemplate调用商品服务</span></span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String forObject = restTemplate.getForObject(<span class="string">&quot;http://localhost:9998/product/findAll&quot;</span>, </span><br><span class="line">                                                     String.class);</span><br><span class="line">        <span class="keyword">return</span> forObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动服务</span></span><br><span class="line"><span class="section"># 5.测试服务调用</span></span><br><span class="line"><span class="bullet">-</span> 浏览器访问用户服务 http://localhost:9999/user/findAll</span><br><span class="line"><span class="section"># 6.总结</span></span><br><span class="line"><span class="bullet">-</span> rest Template是直接基于服务地址调用没有在服务注册中心获取服务,也没有办法完成服务的负载均衡如果需要实现服务的负载均衡需要自己书写服务负载均衡策略。</span><br></pre></td></tr></table></figure>

<h3 id="基于Ribbon的服务调用"><a href="#基于Ribbon的服务调用" class="headerlink" title="基于Ribbon的服务调用"></a>基于Ribbon的服务调用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 官方网址: https://github.com/Netflix/ribbon</span><br><span class="line"><span class="bullet">-</span> Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</span><br></pre></td></tr></table></figure>

<h4 id="1-Ribbon-服务调用"><a href="#1-Ribbon-服务调用" class="headerlink" title="1.Ribbon 服务调用"></a>1.Ribbon 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入依赖</span></span><br><span class="line"><span class="bullet">-</span> 说明: </span><br><span class="line"><span class="code">	1.如果使用的是eureka client 和 consul client,无须引入依赖,因为在eureka,consul中默认集成了ribbon组件</span></span><br><span class="line"><span class="code">	2.如果使用的client中没有ribbon依赖需要显式引入如下依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入ribbon依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.查看consul client中依赖的ribbon</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用restTemplate + ribbon进行服务调用</span></span><br><span class="line"><span class="bullet">-</span> 使用discovery client  进行客户端调用</span><br><span class="line"><span class="bullet">-</span> 使用loadBalanceClient 进行客户端调用</span><br><span class="line"><span class="bullet">-</span> 使用@loadBalanced     进行客户端调用</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.1 使用discovery Client形式调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取服务列表</span></span><br><span class="line">List&lt;ServiceInstance&gt; products = discoveryClient.getInstances(<span class="string">&quot;服务ID&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (ServiceInstance product : products) &#123;</span><br><span class="line">  log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">  log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">  log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br><span class="line">  log.info(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.2 使用loadBalance Client形式调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"><span class="comment">//根据负载均衡策略选取某一个服务调用</span></span><br><span class="line">ServiceInstance product = loadBalancerClient.choose(<span class="string">&quot;服务ID&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.3 使用@loadBalanced</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.整合restTemplate + ribbon</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.调用服务位置注入RestTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="comment">//3.调用</span></span><br><span class="line">String forObject = restTemplate.getForObject(<span class="string">&quot;http://服务ID/hello/hello?name=&quot;</span> + name, String.class);</span><br></pre></td></tr></table></figure>

<h4 id="2-Ribbon负载均衡策略"><a href="#2-Ribbon负载均衡策略" class="headerlink" title="2.Ribbon负载均衡策略"></a>2.Ribbon负载均衡策略</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.ribbon负载均衡算法</span></span><br><span class="line"><span class="bullet">-</span> RoundRobinRule         		轮询策略	按顺序循环选择 Server</span><br><span class="line"><span class="bullet">-</span> RandomRule             		随机策略	随机选择 Server</span><br><span class="line"><span class="bullet">-</span> AvailabilityFilteringRule 可用过滤策略</span><br><span class="line"> 	`会先过滤由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> WeightedResponseTimeRule  响应时间加权策略   </span><br><span class="line"><span class="code">	`根据平均响应的时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时如果统计信息不足，则使用		</span></span><br><span class="line"><span class="code">		RoundRobinRule策略，等统计信息足够会切换到</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> RetryRule                 重试策略          </span><br><span class="line"><span class="code">	`先按照RoundRobinRule的策略获取服务，如果获取失败则在制定时间内进行重试，获取可用的服务。</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- BestAviableRule           最低并发策略     </span></span><br><span class="line"><span class="code">	`会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务  </span></span><br></pre></td></tr></table></figure>

<h4 id="3-修改服务的默认负载均衡策略"><a href="#3-修改服务的默认负载均衡策略" class="headerlink" title="3.修改服务的默认负载均衡策略"></a>3.修改服务的默认负载均衡策略</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.修改服务默认随机策略</span></span><br><span class="line"><span class="bullet">-</span> 服务id.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule</span><br><span class="line"><span class="code">	`下面的products为服务的唯一标识</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">products.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Ribbon停止维护"><a href="#4-Ribbon停止维护" class="headerlink" title="4.Ribbon停止维护"></a>4.Ribbon停止维护</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.官方停止维护说明</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/ribbon</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-OpenFeign组件的使用"><a href="#8-OpenFeign组件的使用" class="headerlink" title="8.OpenFeign组件的使用"></a>8.OpenFeign组件的使用</h2><ul>
<li>思考: 使用RestTemplate+ribbon已经可以完成对端的调用，为什么还要使用feign？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String restTemplateForObject = restTemplate.getForObject(<span class="string">&quot;http://服务名/url?参数&quot;</span> + name, String.class);</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 存在问题:</span></span><br><span class="line"><span class="bullet">-</span> 1.每次调用服务都需要写这些代码,存在大量的代码冗余</span><br><span class="line"><span class="bullet">-</span> 2.服务地址如果修改,维护成本增高</span><br><span class="line"><span class="bullet">-</span> 3.使用时不够灵活</span><br></pre></td></tr></table></figure>

<h3 id="OpenFeign-组件"><a href="#OpenFeign-组件" class="headerlink" title="OpenFeign 组件"></a>OpenFeign 组件</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-openfeign/reference/html/</span><br><span class="line"><span class="bullet">-</span> Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性(可以使用springmvc的注解)，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，默认实现了负载均衡的效果并且springcloud为feign添加了springmvc注解的支持。</span><br></pre></td></tr></table></figure>

<h4 id="1-openFeign-服务调用"><a href="#1-openFeign-服务调用" class="headerlink" title="1.openFeign 服务调用"></a>1.openFeign 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务调用方法引入依赖OpenFeign依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Open Feign依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.入口类加入注解开启OpenFeign支持</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Users9999Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Users9999Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.创建一个客户端调用接口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//value属性用来指定:调用服务名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/findAll&quot;)</span> <span class="comment">//书写服务调用路径</span></span><br><span class="line">    <span class="function">String <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.使用feignClient客户端对象调用服务</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/findAllFeignClient&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAllFeignClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;通过使用OpenFeign组件调用商品服务...&quot;</span>);</span><br><span class="line">  String msg = productClient.findAll();</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.访问并测试服务</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:9999/user/findAllFeignClient</span><br></pre></td></tr></table></figure>

<h4 id="2-调用服务并传参"><a href="#2-调用服务并传参" class="headerlink" title="2.调用服务并传参"></a>2.调用服务并传参</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 服务和服务之间通信,不仅仅是调用,往往在调用过程中还伴随着参数传递,接下来重点来看看OpenFeign在调用服务时如何传递参数</span><br></pre></td></tr></table></figure>

<h6 id="GET方式调用服务传递参数"><a href="#GET方式调用服务传递参数" class="headerlink" title="GET方式调用服务传递参数"></a>GET方式调用服务传递参数</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.GET方式调用服务传递参数</span></span><br><span class="line"><span class="bullet">-</span> 在商品服务中加入需要传递参数的服务方法来进行测试</span><br><span class="line"><span class="bullet">-</span> 在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.商品服务中添加如下方法</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/product/findOne&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">findOne</span><span class="params">(String productId)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品信息的id:[&#123;&#125;]&quot;</span>,productId);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;productId&quot;</span>,productId);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123; </span><br><span class="line">	<span class="meta">@GetMapping(&quot;/product/findOne&quot;)</span></span><br><span class="line"> 	<span class="function">String <span class="title">findOne</span><span class="params">(<span class="meta">@RequestParam(&quot;productId&quot;)</span> String productId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.用户服务中调用并传递参数</span></span><br><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/findAllFeignClient&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAllFeignClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;通过使用OpenFeign组件调用商品服务...&quot;</span>);</span><br><span class="line">  String msg = productClient.findAll();</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="post方式调用服务传递参数"><a href="#post方式调用服务传递参数" class="headerlink" title="post方式调用服务传递参数"></a>post方式调用服务传递参数</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.post方式调用服务传递参数</span></span><br><span class="line"><span class="bullet">-</span> 在商品服务中加入需要传递参数的服务方法来进行测试</span><br><span class="line"><span class="bullet">-</span> 在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.商品服务加入post方式请求并接受name</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/product/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">save</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务保存商品调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品名称:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="comment">//value属性用来指定:调用服务名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/product/save&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">save</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.用户服务中调用并传递参数</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(String productName)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收到的商品信息名称:[&#123;&#125;]&quot;</span>,productName);</span><br><span class="line">  String save = productClient.save(productName);</span><br><span class="line">  log.info(<span class="string">&quot;调用成功返回结果: &quot;</span>+save);</span><br><span class="line">  <span class="keyword">return</span> save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.传递对象类型参数</span></span><br><span class="line"><span class="bullet">-</span> 商品服务定义对象</span><br><span class="line"><span class="bullet">-</span> 商品服务定义对象接收方法</span><br><span class="line"><span class="bullet">-</span> 用户服务调用商品服务定义对象参数方法进行参数传递</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.商品服务定义对象</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date bir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.商品服务定义接收对象的方法</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/product/saveProduct&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">saveProduct</span><span class="params">(<span class="meta">@RequestBody</span> Product product)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务保存商品信息调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品名称:[&#123;&#125;]&quot;</span>,product);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;product&quot;</span>,product);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.将商品对象复制到用户服务中</span></span><br><span class="line"><span class="comment">//4.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PostMapping(&quot;/product/saveProduct&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">saveProduct</span><span class="params">(<span class="meta">@RequestBody</span> Product product)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.在用户服务中调用保存商品信息服务</span></span><br><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/saveProduct&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveProduct</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收到的商品信息:[&#123;&#125;]&quot;</span>,product);</span><br><span class="line">  String save = productClient.saveProduct(product);</span><br><span class="line">  log.info(<span class="string">&quot;调用成功返回结果: &quot;</span>+save);</span><br><span class="line">  <span class="keyword">return</span> save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-OpenFeign超时设置"><a href="#3-OpenFeign超时设置" class="headerlink" title="3.OpenFeign超时设置"></a>3.OpenFeign超时设置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.超时说明</span></span><br><span class="line"><span class="bullet">-</span> 默认情况下,openFiegn在进行服务调用时,要求服务提供方处理业务逻辑时间必须在1S内返回,如果超过1S没有返回则OpenFeign会直接报错,不会等待服务执行,但是往往在处理复杂业务逻辑是可能会超过1S,因此需要修改OpenFeign的默认服务调用超时时间。</span><br><span class="line"><span class="bullet">-</span> 调用超时会出现如下错误：</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.模拟超时</span></span><br><span class="line"><span class="bullet">-</span> 服务提供方加入线程等待阻塞</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.进行客户端调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.修改OpenFeign默认超时时间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">feign.client.config.PRODUCTS.connectTimeout</span>=<span class="string">5000  		#配置指定服务连接超时</span></span><br><span class="line"><span class="meta">feign.client.config.PRODUCTS.readTimeout</span>=<span class="string">5000		  	#配置指定服务等待超时</span></span><br><span class="line"><span class="comment">#feign.client.config.default.connectTimeout=5000  		#配置所有服务连接超时</span></span><br><span class="line"><span class="comment">#feign.client.config.default.readTimeout=5000			#配置所有服务等待超时</span></span><br></pre></td></tr></table></figure>

<h4 id="4-OpenFeign调用详细日志展示"><a href="#4-OpenFeign调用详细日志展示" class="headerlink" title="4.OpenFeign调用详细日志展示"></a>4.OpenFeign调用详细日志展示</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 往往在服务调用时我们需要详细展示feign的日志,默认feign在调用是并不是最详细日志输出,因此在调试程序时应该开启feign的详细日志展示。feign对日志的处理非常灵活可为每个feign客户端指定日志记录策略，每个客户端都会创建一个logger默认情况下logger的名称是feign的全限定名需要注意的是，feign日志的打印只会DEBUG级别做出响应。</span><br><span class="line"><span class="bullet">-</span> 我们可以为feign客户端配置各自的logger.lever对象，告诉feign记录那些日志logger.lever有以下的几种值</span><br><span class="line"><span class="code">	`NONE  不记录任何日志</span></span><br><span class="line"><span class="code">	`BASIC 仅仅记录请求方法，url，响应状态代码及执行时间</span></span><br><span class="line"><span class="code">	`HEADERS 记录Basic级别的基础上，记录请求和响应的header</span></span><br><span class="line"><span class="code">	`FULL 记录请求和响应的header，body和元数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启日志展示</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">feign.client.config.PRODUCTS.loggerLevel</span>=<span class="string">full  #开启指定服务日志展示</span></span><br><span class="line"><span class="comment">#feign.client.config.default.loggerLevel=full  #全局开启服务日志展示</span></span><br><span class="line"><span class="meta">logging.level.com.baizhi.feignclients</span>=<span class="string">debug    #指定feign调用客户端对象所在包,必须是debug级别</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.测试服务调用查看日志</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-Hystrix组件使用"><a href="#9-Hystrix组件使用" class="headerlink" title="9.Hystrix组件使用"></a>9.Hystrix组件使用</h2><h3 id="Hystrix组件"><a href="#Hystrix组件" class="headerlink" title="Hystrix组件"></a>Hystrix组件</h3><p>In a distributed environment, inevitably some of the many service dependencies will fail. Hystrix is a library that helps you control the interactions between these distributed services by adding latency tolerance and fault tolerance logic. Hystrix does this by isolating points of access between the services, stopping cascading failures across them, and providing fallback options, all of which improve your system’s overall resiliency.        –[摘自官方]</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/Hystrix</span><br><span class="line"><span class="bullet">-</span> 译: 在分布式环境中，许多服务依赖项不可避免地会失败。Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、停止它们之间的级联故障以及提供后备选项来实现这一点，所有这些都可以提高系统的整体弹性。</span><br><span class="line"><span class="bullet">-</span> 通俗定义: Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障(服务雪崩现象)，提高分布式系统的弹性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 1.作用</span></span><br><span class="line"><span class="bullet">-</span> hystrix 用来保护微服务系统 实现 服务降级  服务熔断</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 服务雪崩  </span><br><span class="line"><span class="bullet">-</span> 服务降级</span><br><span class="line"><span class="bullet">-</span> 服务熔断</span><br></pre></td></tr></table></figure>

<h4 id="1-服务雪崩"><a href="#1-服务雪崩" class="headerlink" title="1.服务雪崩"></a>1.服务雪崩</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务雪崩</span></span><br><span class="line"><span class="bullet">-</span> 在微服务之间进行服务调用是由于某一个服务故障，导致级联服务故障的现象，称为雪崩效应。雪崩效应描述的是提供方不可用，导致消费方不可用并将不可用逐渐放大的过程。</span><br><span class="line"><span class="section"># 2.图解雪崩效应</span></span><br><span class="line"><span class="bullet">-</span> 如存在如下调用链路:</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 而此时，Service A的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求。此时，如果Service C因为抗不住请求，变得不可用。那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用。紧接着，Service A也会不可用，这一过程如下图所示</span><br></pre></td></tr></table></figure>

<h4 id="2-服务熔断"><a href="#2-服务熔断" class="headerlink" title="2.服务熔断"></a>2.服务熔断</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务熔断</span></span><br><span class="line"><span class="bullet">-</span> “熔断器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器(hystrix)的故障监控，某个异常条件被触发，直接熔断整个服务。向调用方法返回一个符合预期的、可处理的备选响应(FallBack),而不是长时间的等待或者抛出调用方法无法处理的异常，就保证了服务调用方的线程不会被长时间占用，避免故障在分布式系统中蔓延，乃至雪崩。如果目标服务情况好转则恢复调用。服务熔断是解决服务雪崩的重要手段。</span><br><span class="line"></span><br><span class="line"><span class="section"># 服务熔断图示</span></span><br></pre></td></tr></table></figure>

<h4 id="3-服务降级"><a href="#3-服务降级" class="headerlink" title="3.服务降级"></a>3.服务降级</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务降级说明</span></span><br><span class="line"><span class="bullet">-</span> 服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行。同时保证部分甚至大部分任务客户能得到正确的响应。也就是当前的请求处理不了了或者出错了，给一个默认的返回。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 服务降级: 关闭微服务系统中某些边缘服务 保证系统核心服务正常运行</span><br><span class="line"><span class="bullet">-</span> 12 淘宝  京东</span><br><span class="line"><span class="bullet">-</span> 删除订单 --- 关闭订单    确认收货 ----&gt;     服务繁忙,!!!</span><br><span class="line"></span><br><span class="line"><span class="section"># 服务降级图示</span></span><br></pre></td></tr></table></figure>

<h4 id="4-降级和熔断总结"><a href="#4-降级和熔断总结" class="headerlink" title="4.降级和熔断总结"></a>4.降级和熔断总结</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.共同点</span></span><br><span class="line"><span class="bullet">-</span> 目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</span><br><span class="line"><span class="bullet">-</span> 最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</span><br><span class="line"><span class="bullet">-</span> 粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</span><br><span class="line"><span class="bullet">-</span> 自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；sentinel</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.异同点</span></span><br><span class="line"><span class="bullet">-</span> 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</span><br><span class="line"><span class="bullet">-</span> 管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务边缘服务开始）</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.总结</span></span><br><span class="line"><span class="bullet">-</span> 熔断必会触发降级,所以熔断也是降级一种,区别在于熔断是对调用链路的保护,而降级是对系统过载的一种保护处理</span><br></pre></td></tr></table></figure>

<h4 id="5-服务熔断的实现"><a href="#5-服务熔断的实现" class="headerlink" title="5.服务熔断的实现"></a>5.服务熔断的实现</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.服务熔断的实现思路</span></span><br><span class="line"><span class="bullet">-</span> 引入hystrix依赖,并开启熔断器(断路器)</span><br><span class="line"><span class="bullet">-</span> 模拟降级方法</span><br><span class="line"><span class="bullet">-</span> 进行调用测试</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入hystrix依赖 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启断路器</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span>  <span class="comment">//用来开启断路器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Products9998Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Products9998Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用HystrixCommand注解实现断路</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/product/break&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;testBreakFall&quot; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testBreak</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收的商品id为: &quot;</span>+ id);</span><br><span class="line">  <span class="keyword">if</span>(id&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据不合法!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;当前接收商品id: &quot;</span>+id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testBreakFall</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;当前数据不合法: &quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.访问测试</span></span><br><span class="line"><span class="bullet">-</span> 正常参数访问</span><br><span class="line"><span class="bullet">-</span> 错误参数访问</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.总结</span></span><br><span class="line"><span class="bullet">-</span> 从上面演示过程中会发现如果触发一定条件断路器会自动打开,过了一点时间正常之后又会关闭。那么断路器打开条件是什么呢？</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.断路器打开条件</span></span><br><span class="line"><span class="bullet">-</span> 官网: https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix</span><br></pre></td></tr></table></figure>

<p>A service failure in the lower level of services can cause cascading failure all the way up to the user. When calls to a particular service exceed <code>circuitBreaker.requestVolumeThreshold</code> (default: 20 requests) and the failure percentage is greater than <code>circuitBreaker.errorThresholdPercentage</code> (default: &gt;50%) in a rolling window defined by <code>metrics.rollingStats.timeInMilliseconds</code> (default: 10 seconds), the circuit opens and the call is not made. In cases of error and an open circuit, a fallback can be provided by the developer.                                                                        –摘自官方</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 原文翻译之后,总结打开关闭的条件:</span></span><br><span class="line"><span class="bullet">-</span> 1、  当满足一定的阀值的时候（默认10秒内超过20个请求次数）</span><br><span class="line"><span class="bullet">-</span> 2、  当失败率达到一定的时候（默认10秒内超过50%的请求失败）</span><br><span class="line"><span class="bullet">-</span> 3、  到达以上阀值，断路器将会开启</span><br><span class="line"><span class="bullet">-</span> 4、  当开启的时候，所有请求都不会进行转发</span><br><span class="line"><span class="bullet">-</span> 5、  一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。</span><br><span class="line"></span><br><span class="line"><span class="section"># 面试重点问题: 断路器流程</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.默认的服务FallBack处理方法</span></span><br><span class="line"><span class="bullet">-</span> 如果为每一个服务方法开发一个降级,对于我们来说,可能会出现大量的代码的冗余,不利于维护,这个时候就需要加入默认服务降级处理方法</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/product/hystrix&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;testHystrixFallBack&quot;)</span> <span class="comment">//通过HystrixCommand降级处理 指定出错的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHystrix</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收名称为: &quot;</span> + name);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;服务[&quot;</span> + port + <span class="string">&quot;]响应成功,当前接收名称为:&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务降级处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHystrixFallBack</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> port + <span class="string">&quot;当前服务已经被降级处理!!!,接收名称为: &quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-服务降级的实现"><a href="#6-服务降级的实现" class="headerlink" title="6.服务降级的实现"></a>6.服务降级的实现</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务降级: 站在系统整体负荷角度 实现: 关闭系统中某些边缘服务 保证系统核心服务运行</span></span><br><span class="line"><span class="code">	Emps 核心服务   Depts 边缘服务</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 1.客户端openfeign + hystrix实现服务降级实现</span></span><br><span class="line"><span class="bullet">-</span> 引入hystrix依赖</span><br><span class="line"><span class="bullet">-</span> 配置文件开启feign支持hystrix</span><br><span class="line"><span class="bullet">-</span> 在feign客户端调用加入fallback指定降级处理</span><br><span class="line"><span class="bullet">-</span> 开发降级处理方法</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启openfeign支持服务降级</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">feign.hystrix.enabled</span>=<span class="string">true #开启openfeign支持降级</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在openfeign客户端中加如Hystrix</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;PRODUCTS&quot;,fallback = ProductFallBack.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/hystrix&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">testHystrix</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.开发fallback处理类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFallBack</span> <span class="keyword">implements</span> <span class="title">ProductClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHystrix</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是客户端的Hystrix服务实现!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-Hystrix-Dashboard-仪表盘"><a href="#7-Hystrix-Dashboard-仪表盘" class="headerlink" title="7.Hystrix Dashboard(仪表盘)"></a>7.Hystrix Dashboard(仪表盘)</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Hystrix DashBoard 仪表盘 </span></span><br><span class="line"></span><br><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> Hystrix Dashboard的一个主要优点是它收集了关于每个HystrixCommand的一组度量。Hystrix仪表板以高效的方式显示每个断路器的运行状况。</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix dashboard 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.入口类中开启hystrix dashboard</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span> <span class="comment">//开启监控面板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hystrixdashboard9990Application</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(Hystrixdashboard9990Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动hystrix dashboard应用</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:9990(dashboard端口)/hystrix</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.监控的项目中入口类中加入监控路径配置[新版本坑],并启动监控项目</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">  ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">  registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">  registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">  registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.通过监控界面监控</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.点击监控,一致loading,打开控制台发现报错[特别坑]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 解决方案</span></span><br><span class="line"><span class="bullet">-</span> 新版本中springcloud将jquery版本升级为3.4.1，定位到monitor.ftlh文件中，js的写法如下：</span><br><span class="line"><span class="code">	$(window).load(function() </span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- jquery 3.4.1已经废弃上面写法</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 修改方案 修改monitor.ftlh为如下调用方式：</span><br><span class="line"><span class="code">	$(window).on(&quot;load&quot;,function()</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- 编译jar源文件，重新打包引入后，界面正常响应。</span></span><br></pre></td></tr></table></figure>

<h4 id="8-Hystrix停止维护"><a href="#8-Hystrix停止维护" class="headerlink" title="8.Hystrix停止维护"></a>8.Hystrix停止维护</h4><p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5Cimage-20200717161400285.png" alt="image-20200717161400285"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 官方地址:https://github.com/Netflix/Hystrix</span></span><br><span class="line"><span class="bullet">-</span> 翻译:Hystrix（版本1.5.18）足够稳定，可以满足Netflix对我们现有应用的需求。同时，我们的重点已经转移到对应用程序的实时性能作出反应的更具适应性的实现，而不是预先配置的设置（例如，通过自适应并发限制）。对于像Hystrix这样的东西有意义的情况，我们打算继续在现有的应用程序中使用Hystrix，并在新的内部项目中利用诸如resilience4j这样的开放和活跃的项目。我们开始建议其他人也这样做。 ----&gt; sentinel 流量卫兵</span><br><span class="line"><span class="bullet">-</span> Dashboard也被废弃</span><br></pre></td></tr></table></figure>

<h2 id="10-Gateway组件使用"><a href="#10-Gateway组件使用" class="headerlink" title="10.Gateway组件使用"></a>10.Gateway组件使用</h2><h3 id="什么是服务网关"><a href="#什么是服务网关" class="headerlink" title="什么是服务网关"></a>什么是服务网关</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 网关统一服务入口，可方便实现对平台众多服务接口进行管控，对访问服务的身份认证、防报文重放与防数据篡改、功能调用的业务鉴权、响应数据的脱敏、流量与并发控制，甚至基于API调用的计量或者计费等等。</span><br><span class="line"><span class="bullet">-</span> 网关 =  路由转发 + 过滤器</span><br><span class="line"><span class="code">	`路由转发：接收一切外界请求，转发到后端的微服务上去；</span></span><br><span class="line"><span class="code">	`在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 2.为什么需要网关</span></span><br><span class="line"><span class="code"> - 1.网关可以实现服务的统一管理</span></span><br><span class="line"><span class="code"> - 2.网关可以解决微服务中通用代码的冗余问题(如权限控制,流量监控,限流等)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.网关组件在微服务中架构</span></span><br></pre></td></tr></table></figure>

<h3 id="服务网关组件"><a href="#服务网关组件" class="headerlink" title="服务网关组件"></a>服务网关组件</h3><h4 id="zuul-1-x-2-x-netflix-组件"><a href="#zuul-1-x-2-x-netflix-组件" class="headerlink" title="zuul 1.x  2.x(netflix 组件)"></a>zuul 1.x  2.x(netflix 组件)</h4><p>Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security.</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/zuul/wiki</span><br><span class="line"><span class="bullet">-</span> zul是从设备和网站到Netflix流媒体应用程序后端的所有请求的前门。作为一个边缘服务应用程序，zul被构建为支持动态路由、监视、弹性和安全性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.zuul版本说明</span></span><br><span class="line"><span class="bullet">-</span> 目前zuul组件已经从1.0更新到2.0，但是作为springcloud官方不再推荐使用zuul2.0，但是依然支持zuul2.</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.springcloud 官方集成zuul文档</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#netflix-zuul-starter</span><br></pre></td></tr></table></figure>

<h4 id="gateway-spring"><a href="#gateway-spring" class="headerlink" title="gateway (spring)"></a>gateway (spring)</h4><p>This project provides a library for building an API Gateway on top of Spring MVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> https://spring.io/projects/spring-cloud-gateway</span><br><span class="line"><span class="bullet">-</span> 这个项目提供了一个在springmvc之上构建API网关的库。springcloudgateway旨在提供一种简单而有效的方法来路由到api，并为api提供横切关注点，比如：安全性、监控/度量和弹性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.特性</span></span><br><span class="line"><span class="bullet">-</span> 基于springboot2.x 和 spring webFlux 和 Reactor 构建 响应式异步非阻塞IO模型</span><br><span class="line"><span class="bullet">-</span> 动态路由</span><br><span class="line"><span class="bullet">-</span> 请求过滤</span><br></pre></td></tr></table></figure>

<h6 id="1-开发网关动态路由"><a href="#1-开发网关动态路由" class="headerlink" title="1.开发网关动态路由"></a>1.开发网关动态路由</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.翻译</span></span><br><span class="line"><span class="bullet">-</span> 网关配置有两种方式一种是快捷方式(Java代码编写网关),一种是完全展开方式(配置文件方式)[推荐]</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.创建项目引入网关依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入gateway网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>快捷方式配置路由</strong></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写网关配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span>							<span class="comment"># 指定路由唯一标识</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9999/</span> <span class="comment"># 指定路由服务的地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>					  <span class="comment"># 指定路由规则</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9998/</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8989</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动gateway网关项目</span></span><br><span class="line"><span class="bullet">-</span> 直接启动报错:</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 在启动日志中发现,gateway为了效率使用webflux进行异步非阻塞模型的实现,因此和原来的web包冲突,去掉原来的web即可</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 再次启动成功启动</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.测试网关路由转发</span></span><br><span class="line"><span class="bullet">-</span> 测试通过网关访问用户服务: http://localhost:8989/user/findOne?productId=21</span><br><span class="line"><span class="bullet">-</span> 测试通过网关访问商品服务: http://localhost:8989/product/findOne?productId=1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>java方式配置路由</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(<span class="string">&quot;order_route&quot;</span>, r -&gt; r.path(<span class="string">&quot;/order/**&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://localhost:9997&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-查看网关路由规则列表"><a href="#2-查看网关路由规则列表" class="headerlink" title="2.查看网关路由规则列表"></a>2.查看网关路由规则列表</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> gateway提供路由访问规则列表的web界面,但是默认是关闭的,如果想要查看服务路由规则可以在配置文件中开启</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>   <span class="comment">#开启所有web端点暴露</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 访问路由管理列表地址</span><br><span class="line"><span class="bullet">-</span> http://localhost:8989/actuator/gateway/routes</span><br></pre></td></tr></table></figure>

<h6 id="3-配置路由服务负载均衡"><a href="#3-配置路由服务负载均衡" class="headerlink" title="3.配置路由服务负载均衡"></a>3.配置路由服务负载均衡</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 现有路由配置方式,都是基于服务地址写死的路由转发,能不能根据服务名称进行路由转发同时实现负载均衡的呢?</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.动态路由以及负载均衡转发配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9999/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://users</span>							<span class="comment"># lb代表转发后台服务使用负载均衡,users代表服务注册中心上的服务名</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9998/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://products</span>          <span class="comment"># lb(loadbalance)代表负载均衡转发路由</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> 							<span class="comment">#开启根据服务名动态获取路由</span></span><br></pre></td></tr></table></figure>

<h6 id="4-常用路由predicate-断言-验证"><a href="#4-常用路由predicate-断言-验证" class="headerlink" title="4.常用路由predicate(断言,验证)"></a>4.常用路由predicate(断言,验证)</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.Gateway支持多种方式的predicate</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> After=2020-07-21T11:33:33.993+08:00[Asia/Shanghai]  			`指定日期之后的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Before=2020-07-21T11:33:33.993+08:00[Asia/Shanghai]       `指定日期之前的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]</span><br><span class="line"><span class="bullet">-</span> Cookie=username,chenyn																		`基于指定cookie的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Cookie=username,[A-Za-z0-9]+															`基于指定cookie的请求进行路由	</span><br><span class="line"><span class="code">	`curl http://localhost:8989/user/findAll --cookie &quot;username=zhangsna&quot;</span></span><br><span class="line"><span class="code">- Header=X-Request-Id, \d+																 ``基于请求头中的指定属性的正则匹配路由(这里全是整数)</span></span><br><span class="line"><span class="code">	`curl http://localhost:8989/user/findAll -H &quot;X-Request-Id:11&quot;</span></span><br><span class="line"><span class="code">- Method=GET,POST																						 `基于指定的请求方式请求进行路由</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 官方更多: https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/#the-cookie-route-predicate-factory</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.使用predicate</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9999/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://users</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">After=2020-07-21T11:39:33.993+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Cookie=username,[A-Za-z0-9]+</span></span><br><span class="line">            <span class="bullet">-</span>  <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<h6 id="5-常用的Filter以及自定义filter"><a href="#5-常用的Filter以及自定义filter" class="headerlink" title="5.常用的Filter以及自定义filter"></a>5.常用的Filter以及自定义filter</h6><p>Route filters allow the modification of the incoming HTTP request or outgoing HTTP response in some manner. Route filters are scoped to a particular route. Spring Cloud Gateway includes many built-in GatewayFilter Factories.</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> 官网: </span><br><span class="line"><span class="code">	https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/#gatewayfilter-factories</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- 路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。路由筛选器的作用域是特定路由。springcloudgateway包括许多内置的GatewayFilter工厂。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.作用</span></span><br><span class="line"><span class="bullet">-</span> 当我们有很多个服务时，比如下图中的user-service、order-service、product-service等服务，客户端请求各个服务的Api时，每个服务都需要做相同的事情，比如鉴权、限流、日志输出等。</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.使用内置过滤器</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> AddRequestHeader=X-Request-red, blue						<span class="code">`增加请求头的filter`</span></span><br><span class="line"><span class="bullet">-</span> AddRequestParameter=red, blue										<span class="code">`增加请求参数的filterr`</span></span><br><span class="line"><span class="bullet">-</span> AddResponseHeader=X-Response-Red, AAA						<span class="code">`增加响应头filter`</span></span><br><span class="line"><span class="bullet">-</span> PrefixPath=/emp																	<span class="code">`增加前缀的filter`</span></span><br><span class="line"><span class="bullet">-</span> StripPrefix=2																		<span class="code">`去掉前缀的filter`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用自定义filter</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;进入自定义的filter&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(exchange.getRequest().getQueryParams().get(<span class="string">&quot;username&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户身份信息合法,放行请求继续执行!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;非法用户,拒绝访问!!!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="11-Config组件使用"><a href="#11-Config组件使用" class="headerlink" title="11.Config组件使用"></a>11.Config组件使用</h2><h3 id="什么是Config"><a href="#什么是Config" class="headerlink" title="什么是Config"></a>什么是Config</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.3.RELEASE/reference/html/#<span class="emphasis">_spring_</span>cloud<span class="emphasis">_config_</span>server</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> config(配置)又称为 统一配置中心顾名思义,就是将配置统一管理,配置统一管理的好处是在日后大规模集群部署服务应用时相同的服务配置一致,日后再修改配置只需要统一修改全部同步,不需要一个一个服务手动维护。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 1.统一配置中心组件流程图</span></span><br></pre></td></tr></table></figure>

<h3 id="Config-Server-开发"><a href="#Config-Server-开发" class="headerlink" title="Config Server 开发"></a>Config Server 开发</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.引入依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入统一配置中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启统一配置中心服务</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configserver7878Application</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(Configserver7878Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.修改配置文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7878</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">configserver</span></span><br><span class="line"><span class="meta">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.直接启动服务报错</span></span><br><span class="line"><span class="bullet">-</span>  没有指定远程仓库的相关配置</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.创建远程仓库</span></span><br><span class="line"><span class="bullet">-</span> github创建一个仓库</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.复制仓库地址</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/chenyn-java/configservers.git</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.在统一配置中心服务中修改配置文件指向远程仓库地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">https://github.com/chenyn-java/configservers.git   指定仓库的url</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.default-label</span>=<span class="string">master									指定访问的分支</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.username=       私有仓库访问用户名</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.password=		私有仓库访问密码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 8.再次启动统一配置中心</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 9.拉取远端配置 [<span class="string">三种方式</span>][<span class="symbol"></span>]</span></span><br><span class="line"><span class="bullet">-</span> 1. http://localhost:7878/test-xxxx.properties</span><br><span class="line"><span class="bullet">-</span> 2. http://localhost:7878/test-xxxx.json</span><br><span class="line"><span class="bullet">-</span> 3. http://localhost:7878/test-xxxx.yml</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.拉取远端配置规则</span></span><br><span class="line"><span class="bullet">-</span> label/name-profiles.yml|properties|json</span><br><span class="line"><span class="code">	`label   代表去那个分支获取 默认使用master分支</span></span><br><span class="line"><span class="code">	`name    代表读取那个具体的配置文件文件名称</span></span><br><span class="line"><span class="code">	`profile 代表读取配置文件环境</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 11.查看拉取配置详细信息</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:7878/client/dev       [<span class="string">client:代表远端配置名称</span>][<span class="symbol">dev:代表远程配置的环境</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 12.指定分支和本地仓库位置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.server.git.basedir</span>=<span class="string">/localresp 		#一定要是一个空目录,在首次会将该目录清空</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.default-label</span>=<span class="string">master</span></span><br></pre></td></tr></table></figure>

<h3 id="Config-Client-开发"><a href="#Config-Client-开发" class="headerlink" title="Config Client 开发"></a>Config Client 开发</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入config client依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入config client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写配置文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true                #开启统一配置中心服务</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">configserver     #指定统一配置服务中心的服务唯一标识</span></span><br><span class="line"><span class="meta">spring.cloud.config.label</span>=<span class="string">master													#指定从仓库的那个分支拉取配置	</span></span><br><span class="line"><span class="meta">spring.cloud.config.name</span>=<span class="string">client														#指定拉取配置文件的名称</span></span><br><span class="line"><span class="meta">spring.cloud.config.profile</span>=<span class="string">dev														#指定拉取配置文件的环境</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.远程仓库创建配置文件</span></span><br><span class="line"><span class="bullet">-</span> client.properties										[<span class="string">用来存放公共配置</span>][<span class="symbol"></span>]</span><br><span class="line"><span class="code">	spring.application.name=configclient</span></span><br><span class="line"><span class="code">	spring.cloud.consul.host=localhost</span></span><br><span class="line"><span class="code">	spring.cloud.consul.port=8500</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> client-dev.properties  							[<span class="string">用来存放研发相关配置</span>][<span class="symbol">注意:这里端口为例,以后不同配置分别存放</span>]</span><br><span class="line"><span class="code">	server.port=9099</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> client-prod.properties							[<span class="string">用来存放生产相关配置</span>][<span class="symbol"></span>]</span><br><span class="line"><span class="code">	server.port=9098</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动客户端服务进行远程配置拉取测试</span></span><br><span class="line"><span class="bullet">-</span> 直接启动过程中发现无法启动直接报错</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 报错原因</span></span><br><span class="line"><span class="bullet">-</span> 项目中目前使用的是application.properties启动项目,使用这个配置文件在springboot项目启动过程中不会等待远程配置拉取,直接根据配置文件中内容启动,因此当需要注册中心,服务端口等信息时,远程配置还没有拉取到,所以直接报错</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 解决方案</span></span><br><span class="line"><span class="bullet">-</span> 应该在项目启动时先等待拉取远程配置,拉取远程配置成功之后再根据远程配置信息启动即可,为了完成上述要求springboot官方提供了一种解决方案,就是在使用统一配置中心时应该将微服务的配置文件名修改为bootstrap.(properties|yml),bootstrap.properties作为配置启动项目时,会优先拉取远程配置,远程配置拉取成功之后根据远程配置启动当前应用。</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 再次启动服务</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="手动配置刷新"><a href="#手动配置刷新" class="headerlink" title="手动配置刷新"></a>手动配置刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 在生产环境中,微服务可能非常多,每次修改完远端配置之后,不可能对所有服务进行重新启动,这个时候需要让修改配置的服务能够刷新远端修改之后的配置,从而不要每次重启服务才能生效,进一步提高微服务系统的维护效率。在springcloud中也为我们提供了手动刷新配置和自动刷新配置两种策略,这里我们先使用手动配置文件刷新。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.在config client端加入刷新暴露端点</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*          #开启所有web端点暴露</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在需要刷新代码的类中加入刷新配置的注解</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;当前加载配置文件信息为:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.在远程配置中加入name并启动测试</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.启动之后直接访问</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.修改远程配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.修改之后在访问</span></span><br><span class="line"><span class="bullet">-</span> 发现并没有自动刷新配置?</span><br><span class="line"><span class="bullet">-</span> 必须调用刷新配置接口才能刷新配置</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 8.手动调用刷新配置接口</span></span><br><span class="line"><span class="bullet">-</span> curl -X POST http://localhost:9099/actuator/refresh</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 9.在次访问发现配置已经成功刷新</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-Bus组件的使用"><a href="#12-Bus组件的使用" class="headerlink" title="12.Bus组件的使用"></a>12.Bus组件的使用</h2><h3 id="什么是Bus-AMQP-RibbitMQ、Kafka）"><a href="#什么是Bus-AMQP-RibbitMQ、Kafka）" class="headerlink" title="什么是Bus (AMQP RibbitMQ、Kafka）"></a>什么是Bus (AMQP RibbitMQ、Kafka）</h3><p>Spring Cloud Bus links nodes of a distributed system with a lightweight message broker. This can then be used to broadcast state changes (e.g. configuration changes) or other management instructions. AMQP and Kafka broker implementations are included with the project. Alternatively, any <a href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream</a> binder found on the classpath will work out of the box as a transport.   –摘自官网</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.翻译</span></span><br><span class="line"><span class="bullet">-</span> https://spring.io/projects/spring-cloud-bus</span><br><span class="line"><span class="bullet">-</span> springcloudbus使用轻量级消息代理将分布式系统的节点连接起来。然后，可以使用它来广播状态更改（例如配置更改）或其他管理指令。AMQP和Kafka broker(中间件)实现包含在项目中。或者，在类路径上找到的任何springcloudstream绑定器都可以作为传输使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 通俗定义: bus称之为springcloud中消息总线,主要用来在微服务系统中实现远端配置更新时通过广播形式通知所有客户端刷新配置信息,避免手动重启服务的工作</span><br></pre></td></tr></table></figure>

<h3 id="搭建RabbitMQ服务"><a href="#搭建RabbitMQ服务" class="headerlink" title="搭建RabbitMQ服务"></a>搭建RabbitMQ服务</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.下载rabbitmq安装包 [][可以直接使用docker安装更方便]</span></span><br><span class="line"><span class="bullet">-</span> 官方安装包下载:https://www.rabbitmq.com/install-rpm.html#downloads</span><br><span class="line">[<span class="string">注意:</span>][<span class="symbol">这里安装包只能用于centos7.x系统</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.将rabbitmq安装包上传到linux系统中</span></span><br><span class="line"><span class="code">	erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code">	rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.安装Erlang依赖包</span></span><br><span class="line"><span class="code">	rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.安装RabbitMQ安装包(需要联网)</span></span><br><span class="line"><span class="code">	yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code">		注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要	</span></span><br><span class="line"><span class="code">				将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</span></span><br><span class="line"><span class="code"># 4.复制配置文件</span></span><br><span class="line"><span class="code">	cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.查看配置文件位置</span></span><br><span class="line"><span class="code">	ls /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.修改配置文件(参见下图:)</span></span><br><span class="line"><span class="code">	vim /etc/rabbitmq/rabbitmq.config </span></span><br></pre></td></tr></table></figure>

<p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.执行如下命令,启动rabbitmq中的插件管理</span></span><br><span class="line"><span class="code">	rabbitmq-plugins enable rabbitmq_management</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	出现如下说明:</span></span><br><span class="line"><span class="code">		Enabling plugins on node rabbit@localhost:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    The following plugins have been configured:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code">    Applying plugin configuration to rabbit@localhost...</span></span><br><span class="line"><span class="code">    The following plugins have been enabled:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    set 3 plugins.</span></span><br><span class="line"><span class="code">    Offline change; changes will take effect at broker restart.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 8.启动RabbitMQ的服务</span></span><br><span class="line"><span class="code">	systemctl start rabbitmq-server</span></span><br><span class="line"><span class="code">	systemctl restart rabbitmq-server</span></span><br><span class="line"><span class="code">	systemctl stop rabbitmq-server</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.查看服务状态(见下图:)</span></span><br><span class="line"><span class="code">	systemctl status rabbitmq-server</span></span><br><span class="line"><span class="code">  ● rabbitmq-server.service - RabbitMQ broker</span></span><br><span class="line"><span class="code">     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span></span><br><span class="line"><span class="code">     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago</span></span><br><span class="line"><span class="code">   Main PID: 2904 (beam.smp)</span></span><br><span class="line"><span class="code">     Status: &quot;Initialized&quot;</span></span><br><span class="line"><span class="code">     CGroup: /system.slice/rabbitmq-server.service</span></span><br><span class="line"><span class="code">             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -</span></span><br><span class="line"><span class="code">             MBlmbcs...</span></span><br><span class="line"><span class="code">             ├─3220 erl_child_setup 32768</span></span><br><span class="line"><span class="code">             ├─3243 inet_gethost 4</span></span><br><span class="line"><span class="code">             └─3244 inet_gethost 4</span></span><br><span class="line"><span class="code">      .........</span></span><br><span class="line"><span class="code"># 10.启动出现如下错误:</span></span><br><span class="line"><span class="code">- 4月 21 10:10:50 bogon systemd[1]: Starting RabbitMQ broker...</span></span><br><span class="line"><span class="code">- 4月 21 10:11:11 bogon rabbitmq-server[1772]: ERROR: epmd error for host bogon: address (cannot connect to host/port)</span></span><br><span class="line"><span class="code">- 4月 21 10:11:11 bogon systemd[1]: rabbitmq-server.service: main process exited, code=exited, status=1/FAILURE</span></span><br><span class="line"><span class="code"> `解决方案`: </span></span><br><span class="line"><span class="code">   1. 修改主机名   vim /etc/hostname   修改为自己注解名  rabbimq   2.修改完必须重启</span></span><br><span class="line"><span class="code">   3. vim /etc/hosts   在文件中添加:  127.0.0.1   自己主机名(rabbitmq)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.关闭防火墙服务</span></span><br><span class="line"><span class="code">	systemctl disable firewalld</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span></span><br><span class="line"><span class="code">	systemctl stop firewalld   </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 11.访问web管理界面</span></span><br><span class="line"><span class="code">	http://10.15.0.8:15672/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 12.登录管理界面</span></span><br><span class="line"><span class="code">	username:  guest</span></span><br><span class="line"><span class="code">	password:  guest</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 13.MQ服务搭建成功</span></span><br></pre></td></tr></table></figure>

<h3 id="实现自动配置刷新"><a href="#实现自动配置刷新" class="headerlink" title="实现自动配置刷新"></a>实现自动配置刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在所有项目中引入bus依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入bus依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.配置统一配置中心连接到mq</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost											#连接主机</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672														#连接mq端口</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">user												#连接mq用户名</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">password										#连接mq密码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.远端配置中加入连接mq配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动统一配置中心服务</span></span><br><span class="line"><span class="bullet">-</span> 正常启动</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.启动客户端服务</span></span><br><span class="line"><span class="bullet">-</span> 加入bus组件之后客户端启动报错</span><br><span class="line"><span class="bullet">-</span> 原因springcloud中默认链接不到远程服务器不会报错,但是在使用bus消息总线时必须开启连接远程服务失败报错</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.修改远程配置后在配置中心服务通过执行post接口刷新配置</span></span><br><span class="line"><span class="bullet">-</span> curl -X POST http://localhost:7878/actuator/bus-refresh</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.通过上述配置就实现了配置统一刷新</span></span><br></pre></td></tr></table></figure>

<h3 id="指定服务刷新配置"><a href="#指定服务刷新配置" class="headerlink" title="指定服务刷新配置"></a>指定服务刷新配置</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 默认情况下使用curl -X POST http://localhost:7878/actuator/bus-refresh这种方式刷新配置是全部广播形式,也就是所有的微服务都能接收到刷新配置通知,但有时我们修改的仅仅是某个服务的配置,这个时候对于其他服务的通知是多余的,因此就需要指定服务进行通知</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.指定服务刷新配置实现</span></span><br><span class="line"><span class="bullet">-</span> 指定端口刷新某个具体服务: curl -X POST http://localhost:7878/actuator/bus-refresh/configclient:9090</span><br><span class="line"><span class="bullet">-</span> 指定服务id刷新服务集群节点: curl -X POST http://localhost:7878/actuator/bus-refresh/configclient</span><br><span class="line"> 	[<span class="string">注意:</span>][<span class="symbol">configclient代表刷新服务的唯一标识</span>]</span><br></pre></td></tr></table></figure>

<h3 id="集成webhook实现自动刷新"><a href="#集成webhook实现自动刷新" class="headerlink" title="集成webhook实现自动刷新"></a>集成webhook实现自动刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.配置webhooks</span></span><br><span class="line"><span class="bullet">-</span> 说明: git仓库提供一种特有机制: 这种机制就是一个监听机制    监听就是仓库提交事件 ...  触发对应事件执行</span><br><span class="line"><span class="bullet">-</span> javascript: 事件  事件源 html标签  事件: 触发特定动作click  ...  事件处理程序:函数</span><br><span class="line"><span class="bullet">-</span> 添加webhooks</span><br><span class="line"><span class="bullet">-</span> 在webhooks中添加刷新配置接口</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 内网穿透的网站: https://natapp.cn/</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.解决400错误问题</span></span><br><span class="line"><span class="bullet">-</span> 在配置中心服务端加入过滤器进行解决(springcloud中一个坑)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlFilter</span>  <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest)request;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse)response;</span><br><span class="line"> </span><br><span class="line">        String url = <span class="keyword">new</span> String(httpServletRequest.getRequestURI());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//只过滤/actuator/bus-refresh请求</span></span><br><span class="line">        <span class="keyword">if</span> (!url.endsWith(<span class="string">&quot;/bus-refresh&quot;</span>)) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取原始的body</span></span><br><span class="line">        String body = readAsChars(httpServletRequest);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;original body:   &quot;</span>+ body);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用HttpServletRequest包装原始请求达到修改post请求中body内容的目的</span></span><br><span class="line">        CustometRequestWrapper requestWrapper = <span class="keyword">new</span> CustometRequestWrapper(httpServletRequest);</span><br><span class="line"> </span><br><span class="line">        chain.doFilter(requestWrapper, response);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CustometRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustometRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServletInputStream() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read() == -<span class="number">1</span> ? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener readListener)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsChars</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> </span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            br = request.getReader();</span><br><span class="line">            String str;</span><br><span class="line">            <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != br)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="13-SpringCloud-微服务工具集总结"><a href="#13-SpringCloud-微服务工具集总结" class="headerlink" title="13. SpringCloud  微服务工具集总结"></a>13. SpringCloud  微服务工具集总结</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务间通信方式: 		RPC  、 Http 协议 (SpringCloud中)</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 1.服务注册中心组件:  Eureka  、 Consul</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.服务间通信实现 :  </span></span><br><span class="line"><span class="code">	 a.RestTemplate(HttpClient对象) + Ribbon组件(springcloud)</span></span><br><span class="line"><span class="code">	 b.openfegin(伪httpclient客户端组件 底层默认集成Ribbon)  推荐</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.微服务保护组件: 	Hystrix (防止服务雪崩现象)  Hystrix DashBoard 组件  维护状态</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 4.微服务网关组件: 	Zuul1.x  Zuul2.x(netflix组件)、Gateway(Spring 组件)</span></span><br><span class="line"><span class="code">	网关： 路由转发  +  过滤器（前置predicate   后置filter）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.统一配置中心组件:  Config (netflix)</span></span><br><span class="line"><span class="code">	作用: 用来将微服务中所有配置进行远程git仓库统一管理</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.消息总线:         Bus</span></span><br><span class="line"><span class="code">	作用: 用来通过消息中间件将所有微服务连接到一起,利用广播模型实现配置自动刷新机制</span></span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV1S5411c7hM">编程不良人之学习SpringCloud</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/2021/05/26/Redis/</url>
    <content><![CDATA[<blockquote>
<p>  整理Redis整体且全面的知识架构，一片文章了解Redis大部分基础应用</p>
</blockquote>
<span id="more"></span>

<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-NoSQL应用场景"><a href="#1-NoSQL应用场景" class="headerlink" title="1. NoSQL应用场景"></a>1. NoSQL应用场景</h2><ul>
<li><p>数据模型比较简单</p>
</li>
<li><p>需要灵活性更强的IT系统</p>
</li>
<li><p>对数据库性能要求较高</p>
</li>
<li><p>不需要高度的数据一致性</p>
</li>
</ul>
<h2 id="2-什么是Redis"><a href="#2-什么是Redis" class="headerlink" title="2. 什么是Redis"></a>2. 什么是Redis</h2><blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<p>Redis 开源  遵循BSD  基于内存数据存储 被用于作为 数据库 缓存  消息中间件</p>
<ul>
<li>总结: redis是一个内存型的数据库</li>
</ul>
<h2 id="3-Redis特点"><a href="#3-Redis特点" class="headerlink" title="3. Redis特点"></a>3. Redis特点</h2><ul>
<li><p> Redis是一个高性能key/value内存型数据库</p>
</li>
<li><p> Redis支持丰富的数据类型 </p>
</li>
<li><p> Redis支持持久化 </p>
</li>
<li><p> Redis单线程,单进程</p>
</li>
</ul>
<hr>
<h2 id="4-Redis指令以及数据类型"><a href="#4-Redis指令以及数据类型" class="headerlink" title="4. Redis指令以及数据类型"></a>4. Redis指令以及数据类型</h2><h3 id="4-1-数据库操作指令"><a href="#4-1-数据库操作指令" class="headerlink" title="4.1 数据库操作指令"></a>4.1 数据库操作指令</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.Redis中库说明</span></span><br><span class="line"><span class="bullet">-</span> 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15</span><br><span class="line"><span class="bullet">-</span> 可以使用select 库的编号 来选择一个redis的库</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.Redis中操作库的指令</span></span><br><span class="line"><span class="bullet">-</span> 清空当前的库  FLUSHDB</span><br><span class="line"><span class="bullet">-</span> 清空全部的库  FLUSHALL</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.redis客户端显示中文</span></span><br><span class="line"><span class="bullet">-</span>	./redis-cli  -p 7000 --raw</span><br></pre></td></tr></table></figure>

<h3 id="4-2-操作key相关指令"><a href="#4-2-操作key相关指令" class="headerlink" title="4.2 操作key相关指令"></a>4.2 操作key相关指令</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.DEL指令</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  DEL key [key ...] </span><br><span class="line"><span class="bullet">-</span> 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 被删除key 的数量。 </span><br><span class="line"></span><br><span class="line"><span class="section"># 2.EXISTS指令</span></span><br><span class="line"><span class="bullet">-</span> 语法:  EXISTS key</span><br><span class="line"><span class="bullet">-</span> 作用:  检查给定key 是否存在。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 若key 存在，返回1 ，否则返回0。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.EXPIRE</span></span><br><span class="line"><span class="bullet">-</span> 语法:  EXPIRE key seconds</span><br><span class="line"><span class="bullet">-</span> 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 时间复杂度： O(1)</span><br><span class="line"><span class="bullet">-</span> 返回值：设置成功返回1 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 4.KEYS</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  KEYS pattern</span><br><span class="line"><span class="bullet">-</span> 作用 :  查找所有符合给定模式pattern 的key 。</span><br><span class="line"><span class="bullet">-</span> 语法:</span><br><span class="line"><span class="code">	KEYS * 匹配数据库中所有key 。</span></span><br><span class="line"><span class="code">	KEYS h?llo 匹配hello ，hallo 和hxllo 等。</span></span><br><span class="line"><span class="code">	KEYS h*llo 匹配hllo 和heeeeello 等。</span></span><br><span class="line"><span class="code">	KEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 &quot;\&quot; 隔开</span></span><br><span class="line"><span class="code">- 可用版本： &gt;= 1.0.0</span></span><br><span class="line"><span class="code">- 返回值： 符合给定模式的key 列表。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.MOVE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  MOVE key db</span><br><span class="line"><span class="bullet">-</span> 作用 :  将当前数据库的key 移动到给定的数据库db 当中。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 移动成功返回1 ，失败则返回0 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 6.PEXPIRE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PEXPIRE key milliseconds</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 时间复杂度： O(1)</span><br><span class="line"><span class="bullet">-</span> 返回值：设置成功，返回1  key 不存在或设置失败，返回0</span><br><span class="line"></span><br><span class="line"><span class="section"># 7.PEXPIREAT</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PEXPIREAT key milliseconds-timestamp</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)</span><br><span class="line"></span><br><span class="line"><span class="section"># 8.TTL</span></span><br><span class="line"><span class="bullet">-</span> 语法 :   TTL key</span><br><span class="line"><span class="bullet">-</span> 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：</span><br><span class="line"><span class="code">	当key 不存在时，返回-2 。</span></span><br><span class="line"><span class="code">	当key 存在但没有设置剩余生存时间时，返回-1 。</span></span><br><span class="line"><span class="code">	否则，以秒为单位，返回key 的剩余生存时间。</span></span><br><span class="line"><span class="code">- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.PTTL</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PTTL key</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。</span><br><span class="line"><span class="bullet">-</span> 否则，以毫秒为单位，返回key 的剩余生存时间。</span><br><span class="line"><span class="bullet">-</span> 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 10.RANDOMKEY</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  RANDOMKEY</span><br><span class="line"><span class="bullet">-</span> 作用 :  从当前数据库中随机返回(不删除) 一个key 。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 11.RENAME</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  RENAME key newkey</span><br><span class="line"><span class="bullet">-</span> 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 改名成功时提示OK ，失败时候返回一个错误。</span><br><span class="line"></span><br><span class="line"><span class="section"># 12.TYPE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  TYPE key</span><br><span class="line"><span class="bullet">-</span> 作用 :  返回key 所储存的值的类型。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：</span><br><span class="line"><span class="code">	none (key 不存在)</span></span><br><span class="line"><span class="code">	string (字符串)</span></span><br><span class="line"><span class="code">	list (列表)</span></span><br><span class="line"><span class="code">	set (集合)</span></span><br><span class="line"><span class="code">	zset (有序集)</span></span><br><span class="line"><span class="code">	hash (哈希表)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-String类型"><a href="#4-3-String类型" class="headerlink" title="4.3 String类型"></a>4.3 String类型</h3><h4 id="1-内存存储模型"><a href="#1-内存存储模型" class="headerlink" title="1. 内存存储模型"></a>1. 内存存储模型</h4><p>朴实无华的String类型</p>
<h4 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>设置一个key/value</td>
</tr>
<tr>
<td>get</td>
<td>根据key获得对应的value</td>
</tr>
<tr>
<td>mset</td>
<td>一次设置多个key value</td>
</tr>
<tr>
<td>mget</td>
<td>一次获得多个key的value</td>
</tr>
<tr>
<td>getset</td>
<td>获得原始key的值，同时设置新值</td>
</tr>
<tr>
<td>strlen</td>
<td>获得对应key存储value的长度</td>
</tr>
<tr>
<td>append</td>
<td>为对应key的value追加内容</td>
</tr>
<tr>
<td>getrange 索引0开始</td>
<td>截取value的内容</td>
</tr>
<tr>
<td>setex</td>
<td>设置一个key存活的有效期（秒）</td>
</tr>
<tr>
<td>psetex</td>
<td>设置一个key存活的有效期（毫秒）</td>
</tr>
<tr>
<td>setnx</td>
<td>存在不做任何操作,不存在添加</td>
</tr>
<tr>
<td>msetnx原子操作(只要有一个存在不做任何操作)</td>
<td>可以同时设置多个key,只有有一个存在都不保存</td>
</tr>
<tr>
<td>decr</td>
<td>进行数值类型的-1操作</td>
</tr>
<tr>
<td>decrby</td>
<td>根据提供的数据进行减法操作</td>
</tr>
<tr>
<td>Incr</td>
<td>进行数值类型的+1操作</td>
</tr>
<tr>
<td>incrby</td>
<td>根据提供的数据进行加法操作</td>
</tr>
<tr>
<td>Incrbyfloat</td>
<td>根据提供的数据加入浮点数</td>
</tr>
</tbody></table>
<h3 id="4-4-List类型"><a href="#4-4-List类型" class="headerlink" title="4.4 List类型"></a>4.4 List类型</h3><p>list 列表 相当于java中list 集合  特点  元素有序  且 可以重复</p>
<h4 id="1-内存存储模型-1"><a href="#1-内存存储模型-1" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p>是左右端都可以操作的双向链表</p>
<h4 id="2-常用操作指令"><a href="#2-常用操作指令" class="headerlink" title="2.常用操作指令"></a>2.常用操作指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lpush</td>
<td>将某个值加入到一个key列表头部</td>
</tr>
<tr>
<td>lpushx</td>
<td>同lpush,但是必须要保证这个key存在</td>
</tr>
<tr>
<td>rpush</td>
<td>将某个值加入到一个key列表末尾</td>
</tr>
<tr>
<td>rpushx</td>
<td>同rpush,但是必须要保证这个key存在</td>
</tr>
<tr>
<td>lpop</td>
<td>返回和移除列表左边的第一个元素</td>
</tr>
<tr>
<td>rpop</td>
<td>返回和移除列表右边的第一个元素</td>
</tr>
<tr>
<td>lrange</td>
<td>获取某一个下标区间内的元素</td>
</tr>
<tr>
<td>llen</td>
<td>获取列表元素个数</td>
</tr>
<tr>
<td>lset</td>
<td>设置某一个指定索引的值(索引必须存在)</td>
</tr>
<tr>
<td>lindex</td>
<td>获取某一个指定索引位置的元素</td>
</tr>
<tr>
<td>lrem</td>
<td>删除重复元素</td>
</tr>
<tr>
<td>ltrim</td>
<td>保留列表中特定区间内的元素</td>
</tr>
<tr>
<td>linsert</td>
<td>在某一个元素之前，之后插入新元素</td>
</tr>
</tbody></table>
<h3 id="4-5-Set类型"><a href="#4-5-Set类型" class="headerlink" title="4.5 Set类型"></a>4.5 Set类型</h3><p>特点: Set类型 Set集合 元素无序  不可以重复</p>
<h4 id="1-内存存储模型-2"><a href="#1-内存存储模型-2" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p>朴实无华的Set类型</p>
<h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sadd</td>
<td>为集合添加元素</td>
</tr>
<tr>
<td>smembers</td>
<td>显示集合中所有元素 无序</td>
</tr>
<tr>
<td>scard</td>
<td>返回集合中元素的个数</td>
</tr>
<tr>
<td>spop</td>
<td>随机返回一个元素 并将元素在集合中删除</td>
</tr>
<tr>
<td>smove</td>
<td>从一个集合中向另一个集合移动元素  必须是同一种类型</td>
</tr>
<tr>
<td>srem</td>
<td>从集合中删除一个元素</td>
</tr>
<tr>
<td>sismember</td>
<td>判断一个集合中是否含有这个元素</td>
</tr>
<tr>
<td>srandmember</td>
<td>随机返回元素</td>
</tr>
<tr>
<td>sdiff</td>
<td>去掉第一个集合中其它集合含有的相同元素</td>
</tr>
<tr>
<td>sinter</td>
<td>求交集</td>
</tr>
<tr>
<td>sunion</td>
<td>求和集</td>
</tr>
</tbody></table>
<h3 id="4-6-ZSet类型"><a href="#4-6-ZSet类型" class="headerlink" title="4.6 ZSet类型"></a>4.6 ZSet类型</h3><p>特点: 可排序的set集合  排序  不可重复 </p>
<p>ZSET 官方  可排序SET  sortSet   </p>
<h4 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p>朴实无华的ZSet集合</p>
<h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>zadd</td>
<td>添加一个有序集合元素</td>
</tr>
<tr>
<td>zcard</td>
<td>返回集合的元素个数</td>
</tr>
<tr>
<td>zrange 升序 zrevrange 降序</td>
<td>返回一个范围内的元素</td>
</tr>
<tr>
<td>zrangebyscore</td>
<td>按照分数查找一个范围内的元素</td>
</tr>
<tr>
<td>zrank</td>
<td>返回排名</td>
</tr>
<tr>
<td>zrevrank</td>
<td>倒序排名</td>
</tr>
<tr>
<td>zscore</td>
<td>显示某一个元素的分数</td>
</tr>
<tr>
<td>zrem</td>
<td>移除某一个元素</td>
</tr>
<tr>
<td>zincrby</td>
<td>给某个特定元素加分</td>
</tr>
</tbody></table>
<h3 id="4-7-hash类型"><a href="#4-7-hash类型" class="headerlink" title="4.7 hash类型"></a>4.7 hash类型</h3><p>特点: value 是一个map结构 存在key value  key 无序的  </p>
<h4 id="1-内存模型-1"><a href="#1-内存模型-1" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p>朴实无华的HashMap</p>
<h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>hset</td>
<td>设置一个key/value对</td>
</tr>
<tr>
<td>hget</td>
<td>获得一个key对应的value</td>
</tr>
<tr>
<td>hgetall</td>
<td>获得所有的key/value对</td>
</tr>
<tr>
<td>hdel</td>
<td>删除某一个key/value对</td>
</tr>
<tr>
<td>hexists</td>
<td>判断一个key是否存在</td>
</tr>
<tr>
<td>hkeys</td>
<td>获得所有的key</td>
</tr>
<tr>
<td>hvals</td>
<td>获得所有的value</td>
</tr>
<tr>
<td>hmset</td>
<td>设置多个key/value</td>
</tr>
<tr>
<td>hmget</td>
<td>获得多个key的value</td>
</tr>
<tr>
<td>hsetnx</td>
<td>设置一个不存在的key的值</td>
</tr>
<tr>
<td>hincrby</td>
<td>为value进行加法运算</td>
</tr>
<tr>
<td>hincrbyfloat</td>
<td>为value加入浮点值</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-持久化机制"><a href="#5-持久化机制" class="headerlink" title="5. 持久化机制"></a>5. 持久化机制</h2><p>client  redis[内存] —–&gt;  内存数据- 数据持久化–&gt;磁盘</p>
<p>Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:</p>
<ul>
<li>快照(Snapshot)</li>
<li>AOF (Append Only File) 只追加日志文件</li>
</ul>
<h3 id="5-1-快照-Snapshot"><a href="#5-1-快照-Snapshot" class="headerlink" title="5.1 快照(Snapshot)"></a>5.1 快照(Snapshot)</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><p>这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是<strong>redis的默认开启持久化方式</strong>,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。</p>
<h4 id="2-快照生成方式"><a href="#2-快照生成方式" class="headerlink" title="2.快照生成方式"></a>2.快照生成方式</h4><ul>
<li>客户端方式: BGSAVE 和 SAVE指令</li>
<li>服务器配置自动触发</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.客户端方式之BGSAVE</span></span><br><span class="line"><span class="bullet">-</span> a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。</span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.客户端方式之SAVE</span></span><br><span class="line"><span class="bullet">-</span> b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务</strong></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.服务器配置方式之满足配置自动触发</span></span><br><span class="line"><span class="bullet">-</span> 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.服务器接收客户端shutdown指令</span></span><br><span class="line"><span class="bullet">-</span> 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器</span><br></pre></td></tr></table></figure>

<h4 id="3-配置生成快照名称和位置"><a href="#3-配置生成快照名称和位置" class="headerlink" title="3.配置生成快照名称和位置"></a>3.配置生成快照名称和位置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#1.修改生成快照名称</span></span><br><span class="line"><span class="bullet">-</span> dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.修改生成位置</span></span><br><span class="line"><span class="bullet">-</span> dir ./</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-AOF-只追加日志文件"><a href="#5-2-AOF-只追加日志文件" class="headerlink" title="5.2 AOF 只追加日志文件"></a>5.2 AOF 只追加日志文件</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.</p>
<h4 id="2-开启AOF持久化"><a href="#2-开启AOF持久化" class="headerlink" title="2.开启AOF持久化"></a>2.开启AOF持久化</h4><p>在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启AOF持久化</span></span><br><span class="line"><span class="bullet">-</span> a.修改 appendonly yes 开启持久化</span><br><span class="line"><span class="bullet">-</span> b.修改 appendfilename &quot;appendonly.aof&quot; 指定生成文件名称</span><br></pre></td></tr></table></figure>

<h4 id="3-日志追加频率"><a href="#3-日志追加频率" class="headerlink" title="3.日志追加频率"></a>3.日志追加频率</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.always 【谨慎使用】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度</span><br><span class="line"><span class="bullet">-</span> 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;</span><br><span class="line"><span class="bullet">-</span> 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;</span><br><span class="line"><span class="bullet">-</span> 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.everysec 【推荐】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘</span><br><span class="line"><span class="bullet">-</span> 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.no	【不推荐】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 由操作系统决定何时同步 </span><br><span class="line"><span class="bullet">-</span> 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。</span><br></pre></td></tr></table></figure>

<h4 id="4-修改同步频率"><a href="#4-修改同步频率" class="headerlink" title="4.修改同步频率"></a>4.修改同步频率</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.修改日志同步频率</span></span><br><span class="line"><span class="bullet">-</span> 修改appendfsync everysec|always|no 指定</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-AOF文件的重写"><a href="#5-3-AOF文件的重写" class="headerlink" title="5.3 AOF文件的重写"></a>5.3 AOF文件的重写</h3><h4 id="1-AOF带来的问题"><a href="#1-AOF带来的问题" class="headerlink" title="1. AOF带来的问题"></a>1. AOF带来的问题</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。</p>
<h4 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2. AOF重写"></a>2. AOF重写</h4><p>用来在一定程度上减小AOF文件的体积</p>
<h4 id="3-触发重写方式"><a href="#3-触发重写方式" class="headerlink" title="3. 触发重写方式"></a>3. 触发重写方式</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.客户端方式触发重写</span></span><br><span class="line"><span class="bullet">-</span> 执行BGREWRITEAOF命令  不会阻塞redis的服务</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.服务器配置方式自动触发</span></span><br><span class="line"><span class="bullet">-</span> 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓</span><br><span class="line"><span class="bullet">-</span> 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大</span><br></pre></td></tr></table></figure>

<h4 id="4-重写原理"><a href="#4-重写原理" class="headerlink" title="4. 重写原理"></a>4. 重写原理</h4><p> <strong>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 重写流程</span></span><br><span class="line"><span class="bullet">-</span> 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令</span><br><span class="line"><span class="bullet">-</span> 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。</span><br><span class="line"><span class="bullet">-</span> 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。</span><br><span class="line"><span class="bullet">-</span> 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5Cimage-20210527105149362.png" alt="image-20210527105149362"></p>
<hr>
<h3 id="5-4-持久化总结"><a href="#5-4-持久化总结" class="headerlink" title="5.4 持久化总结"></a>5.4 持久化总结</h3><p>两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。</p>
<p>无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。</p>
<hr>
<h2 id="6-SpringBoot整合Redis"><a href="#6-SpringBoot整合Redis" class="headerlink" title="6. SpringBoot整合Redis"></a>6. SpringBoot整合Redis</h2><p>Spring Boot Data(数据) Redis 中提供了<strong>RedisTemplate和StringRedisTemplate</strong>，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，<strong>RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。</strong></p>
<p><code>注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口</code></p>
<h3 id="11-1-环境准备"><a href="#11-1-环境准备" class="headerlink" title="11.1 环境准备"></a>11.1 环境准备</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-配置application-propertie"><a href="#2-配置application-propertie" class="headerlink" title="2.配置application.propertie"></a>2.配置application.propertie</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<h3 id="11-2-使用StringRedisTemplate和RedisTemplate"><a href="#11-2-使用StringRedisTemplate和RedisTemplate" class="headerlink" title="11.2 使用StringRedisTemplate和RedisTemplate"></a>11.2 使用StringRedisTemplate和RedisTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;  <span class="comment">//对字符串支持比较友好,不能存储对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;  <span class="comment">//存储对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(redisTemplate);</span><br><span class="line">        <span class="comment">//设置redistemplate值使用对象序列化策略</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());<span class="comment">//指定值使用对象序列化</span></span><br><span class="line">        <span class="comment">//redisTemplate.opsForValue().set(&quot;user&quot;,new User(&quot;21&quot;,&quot;小黑&quot;,23,new Date()));</span></span><br><span class="line">        User user = (User) redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"><span class="comment">//      Set keys = redisTemplate.keys(&quot;*&quot;);</span></span><br><span class="line"><span class="comment">//      keys.forEach(key -&gt; System.out.println(key));</span></span><br><span class="line">        <span class="comment">/*Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(name);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object xiaohei = redisTemplate.opsForValue().get(&quot;xiaohei&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(xiaohei);</span></span><br><span class="line">        <span class="comment">/*redisTemplate.opsForValue().set(&quot;name&quot;,&quot;xxxx&quot;);</span></span><br><span class="line"><span class="comment">        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(name);*/</span></span><br><span class="line">        <span class="comment">/*redisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;xxxx&quot;,&quot;1111&quot;);</span></span><br><span class="line"><span class="comment">        List lists = redisTemplate.opsForList().range(&quot;lists&quot;, 0, -1);</span></span><br><span class="line"><span class="comment">        lists.forEach(list-&gt; System.out.println(list));*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key</span></span><br><span class="line">    <span class="comment">//boundValueOps 用来对String值绑定key</span></span><br><span class="line">    <span class="comment">//boundListOps 用来对List值绑定key</span></span><br><span class="line">    <span class="comment">//boundSetOps 用来对Set值绑定key</span></span><br><span class="line">    <span class="comment">//boundZsetOps 用来对Zset值绑定key</span></span><br><span class="line">    <span class="comment">//boundHashOps 用来对Hash值绑定key</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBoundKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BoundValueOperations&lt;String, String&gt; nameValueOperations = stringRedisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        nameValueOperations.set(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//yuew</span></span><br><span class="line">        nameValueOperations.set(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        String s = nameValueOperations.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash相关操作 opsForHash</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;maps&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">        Object o = stringRedisTemplate.opsForHash().get(<span class="string">&quot;maps&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//zset相关操作 opsForZSet</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;zsets&quot;</span>,<span class="string">&quot;小黑&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(<span class="string">&quot;zsets&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        zsets.forEach(value-&gt; System.out.println(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set相关操作 opsForSet</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;sets&quot;</span>,<span class="string">&quot;xiaosan&quot;</span>,<span class="string">&quot;xiaosi&quot;</span>,<span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(<span class="string">&quot;sets&quot;</span>);</span><br><span class="line">        sets.forEach(value-&gt; System.out.println(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list相关的操作opsForList</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// stringRedisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</span></span><br><span class="line">        List&lt;String&gt; lists = stringRedisTemplate.opsForList().range(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        lists.forEach(key -&gt; System.out.println(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String相关的操作 opsForValue</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//stringRedisTemplate.opsForValue().set(&quot;166&quot;,&quot;好同学&quot;);</span></span><br><span class="line">        String s = stringRedisTemplate.opsForValue().get(<span class="string">&quot;166&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        Long size = stringRedisTemplate.opsForValue().size(<span class="string">&quot;166&quot;</span>);</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key相关的操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.keys(<span class="string">&quot;*&quot;</span>);<span class="comment">//查看所有key</span></span><br><span class="line">        Boolean name = stringRedisTemplate.hasKey(<span class="string">&quot;name&quot;</span>);<span class="comment">//判断某个key是否存在</span></span><br><span class="line">        stringRedisTemplate.delete(<span class="string">&quot;age&quot;</span>);<span class="comment">//根据指定key删除</span></span><br><span class="line">        stringRedisTemplate.rename(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//修改key的名称</span></span><br><span class="line">        stringRedisTemplate.expire(<span class="string">&quot;key&quot;</span>,<span class="number">10</span>, TimeUnit.HOURS);</span><br><span class="line">      	<span class="comment">//设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位</span></span><br><span class="line">        stringRedisTemplate.move(<span class="string">&quot;&quot;</span>,<span class="number">1</span>);<span class="comment">//移动key</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-Redis-主从复制"><a href="#7-Redis-主从复制" class="headerlink" title="7. Redis 主从复制"></a>7. Redis 主从复制</h2><h3 id="7-1-主从复制"><a href="#7-1-主从复制" class="headerlink" title="7.1 主从复制"></a>7.1 主从复制</h3><p>主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据</p>
<p><strong>无法解决: 1.master节点出现故障的自动故障转移</strong></p>
<h3 id="7-2-搭建主从复制"><a href="#7-2-搭建主从复制" class="headerlink" title="7.2 搭建主从复制"></a>7.2 搭建主从复制</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.准备3台机器并修改配置</span></span><br><span class="line"><span class="bullet">-</span> master</span><br><span class="line"><span class="code">	port 6379</span></span><br><span class="line"><span class="code">	bind 0.0.0.0</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- slave1</span></span><br><span class="line"><span class="code">	port 6380</span></span><br><span class="line"><span class="code">	bind 0.0.0.0</span></span><br><span class="line"><span class="code">	slaveof masterip masterport</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> slave2</span><br><span class="line"><span class="code">	port 6381</span></span><br><span class="line"><span class="code">	bind 0.0.0.0</span></span><br><span class="line"><span class="code">	slaveof masterip masterport</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.启动3台机器进行测试</span></span><br><span class="line"><span class="bullet">-</span> cd /usr/redis/bin</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/master/redis.conf</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/slave1/redis.conf</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/slave2/redis.conf</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-Redis哨兵机制"><a href="#8-Redis哨兵机制" class="headerlink" title="8. Redis哨兵机制"></a>8. Redis哨兵机制</h2><h3 id="8-1-哨兵Sentinel机制"><a href="#8-1-哨兵Sentinel机制" class="headerlink" title="8.1 哨兵Sentinel机制"></a>8.1 哨兵Sentinel机制</h3><p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有<strong>自动故障转移功能的主从架构</strong>。</p>
<p><strong>无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限</strong></p>
<h3 id="8-2-搭建哨兵架构"><a href="#8-2-搭建哨兵架构" class="headerlink" title="8.2 搭建哨兵架构"></a>8.2 搭建哨兵架构</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在主节点上创建哨兵配置</span></span><br><span class="line"><span class="bullet">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span></span><br><span class="line"><span class="bullet">-</span> sentinel monitor 被监控数据库名字（自己起名字） ip port 1</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.启动哨兵模式进行测试</span></span><br><span class="line"><span class="bullet">-</span> redis-sentinel  /root/sentinel/sentinel.conf</span><br><span class="line"><span class="code">	说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-通过springboot操作哨兵"><a href="#8-3-通过springboot操作哨兵" class="headerlink" title="8.3 通过springboot操作哨兵"></a>8.3 通过springboot操作哨兵</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis sentinel 配置</span></span><br><span class="line"><span class="comment"># master书写是使用哨兵监听的那个名称</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.master</span>=<span class="string">mymaster</span></span><br><span class="line"><span class="comment"># 连接的不再是一个具体redis主机,书写的是多个哨兵节点</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.nodes</span>=<span class="string">192.168.202.206:26379</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)</strong></li>
<li><strong>解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限</strong></li>
</ul>
<h2 id="9-Redis集群"><a href="#9-Redis集群" class="headerlink" title="9. Redis集群"></a>9. Redis集群</h2><h3 id="9-1-集群"><a href="#9-1-集群" class="headerlink" title="9.1 集群"></a>9.1 集群</h3><p>Redis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持节点的自动发现,支持slave-master选举和容错,支持在线分片(sharding shard )等特性。reshard</p>
<h3 id="9-2-集群细节"><a href="#9-2-集群细节" class="headerlink" title="9.2 集群细节"></a>9.2 集群细节</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</span><br><span class="line"><span class="bullet">-</span> 节点的fail是通过集群中超过半数的节点检测失效时才生效. </span><br><span class="line"><span class="bullet">-</span> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</span><br><span class="line"><span class="bullet">-</span> redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</span><br></pre></td></tr></table></figure>

<h3 id="9-3-集群搭建"><a href="#9-3-集群搭建" class="headerlink" title="9.3 集群搭建"></a>9.3 集群搭建</h3><p>判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数，<strong>搭建集群至少需要三个主节点,三个从节点,至少需要6个节点</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.准备环境安装ruby以及redis集群依赖</span></span><br><span class="line"><span class="bullet">-</span> yum install -y ruby rubygems</span><br><span class="line"><span class="bullet">-</span> gem install redis-xxx.gem</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.在一台机器创建7个目录</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.每个目录复制一份配置文件</span></span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.修改不同目录配置文件</span></span><br><span class="line"><span class="bullet">-</span> port 	6379 .....                		 //修改端口</span><br><span class="line"><span class="bullet">-</span> bind  0.0.0.0                   		 //开启远程连接</span><br><span class="line"><span class="bullet">-</span> cluster-enabled  yes 	        			 //开启集群模式</span><br><span class="line"><span class="bullet">-</span> cluster-config-file  nodes-port.conf //集群节点配置文件</span><br><span class="line"><span class="bullet">-</span> cluster-node-timeout  5000      	   //集群节点超时时间</span><br><span class="line"><span class="bullet">-</span> appendonly  yes   		               //开启AOF持久化</span><br><span class="line"></span><br><span class="line"><span class="section"># 5.指定不同目录配置文件启动七个节点</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7000/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7001/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7002/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7003/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7004/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7005/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7006/redis.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.查看进程</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ps aux|grep redis</span><br></pre></td></tr></table></figure>

<h4 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1.创建集群"></a>1.创建集群</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.复制集群操作脚本到bin目录中</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# cp /root/redis-4.0.10/src/redis-trib.rb .</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.创建集群</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb create --replicas 1 192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.集群创建成功</span></span><br></pre></td></tr></table></figure>

<h4 id="2-查看集群状态"><a href="#2-查看集群状态" class="headerlink" title="2.查看集群状态"></a>2.查看集群状态</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.查看集群状态 check [原始集群中任意节点] [无]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb check 192.168.202.205:7000</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.集群节点状态说明</span></span><br><span class="line"><span class="bullet">-</span> 主节点 </span><br><span class="line"><span class="code">	主节点存在hash slots,且主节点的hash slots 没有交叉</span></span><br><span class="line"><span class="code">	主节点不能删除</span></span><br><span class="line"><span class="code">	一个主节点可以有多个从节点</span></span><br><span class="line"><span class="code">	主节点宕机时多个副本之间自动选举主节点</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 从节点</span><br><span class="line"><span class="code">	从节点没有hash slots</span></span><br><span class="line"><span class="code">	从节点可以删除</span></span><br><span class="line"><span class="code">	从节点不负责数据的写,只负责数据的同步</span></span><br></pre></td></tr></table></figure>

<h4 id="3-添加主节点"><a href="#3-添加主节点" class="headerlink" title="3.添加主节点"></a>3.添加主节点</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"><span class="code">	1.该节点必须以集群模式启动</span></span><br><span class="line"><span class="code">	2.默认情况下该节点就是以master节点形式添加</span></span><br></pre></td></tr></table></figure>

<h4 id="4-添加从节点"><a href="#4-添加从节点" class="headerlink" title="4.添加从节点"></a>4.添加从节点</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"><span class="code">	当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]</span></span><br><span class="line"><span class="code">- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000</span></span><br></pre></td></tr></table></figure>

<h4 id="5-删除副本节点"><a href="#5-删除副本节点" class="headerlink" title="5.删除副本节点"></a>5.删除副本节点</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.删除节点 del-node [集群中任意节点] [删除节点id]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"> 1.被删除的节点必须是从节点或没有被分配hash slots的节点</span><br></pre></td></tr></table></figure>

<h4 id="6-集群在线分片"><a href="#6-集群在线分片" class="headerlink" title="6.集群在线分片"></a>6.集群在线分片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在线分片 reshard [集群中任意节点] [无]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  reshard  192.168.1.158:7000</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-Redis实现分布式Session管理"><a href="#10-Redis实现分布式Session管理" class="headerlink" title="10.Redis实现分布式Session管理"></a>10.Redis实现分布式Session管理</h2><h3 id="10-1-管理机制"><a href="#10-1-管理机制" class="headerlink" title="10.1 管理机制"></a>10.1 管理机制</h3><p><strong>redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据。</strong></p>
<h3 id="10-2-开发Session管理"><a href="#10-2-开发Session管理" class="headerlink" title="10.2 开发Session管理"></a>10.2 开发Session管理</h3><h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-开发Session管理配置类"><a href="#2-开发Session管理配置类" class="headerlink" title="2. 开发Session管理配置类"></a>2. 开发Session管理配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionManager</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-打包测试即可"><a href="#3-打包测试即可" class="headerlink" title="3.打包测试即可"></a>3.打包测试即可</h4><hr>
<h2 id="11-总结面试"><a href="#11-总结面试" class="headerlink" title="11.总结面试"></a>11.总结面试</h2><h3 id="11-1缓存穿透、缓存击穿、缓存雪崩以及解决方案？"><a href="#11-1缓存穿透、缓存击穿、缓存雪崩以及解决方案？" class="headerlink" title="11.1缓存穿透、缓存击穿、缓存雪崩以及解决方案？"></a>11.1缓存穿透、缓存击穿、缓存雪崩以及解决方案？</h3><p>缓存穿透：<code>请求查询的ID是缓存和数据库中都不存在的，外部攻击频繁查询不存在的ID而不经过缓存，导致频繁查询数据库，而对数据库的压力过大。</code></p>
<p>解决方案：</p>
<ol>
<li>对查询ID进行校验，不符合的ID被拦截。</li>
<li>对缓存和数据库中都不取不到的ID进行缓存，key-value设置为key-null，缓存的有效时间设置短点。</li>
</ol>
<p>缓存击穿：<code>请求查询的ID是缓存中不存在，而数据库中存在的，情景理解成一个缓存在刚好失效的时候，大量的请求涌入，由于缓存不存在而去大量访问数据库，导致对数据库的压力过大。</code></p>
<p>解决方案：</p>
<ol>
<li>设置键永久期限（不推荐）</li>
<li>互斥锁：Redis使用SETNX（set if not exists）</li>
<li>布隆过滤器</li>
</ol>
<p>缓存雪崩：<code>多个请求查询的ID是缓存中不存在而数据库中存在,大量缓存设置了相同的生存时间后同时失效,高并发情况下大量的数据同时涌入数据库,导致数据库压力瞬间过大而挂起</code></p>
<p>解决方案：</p>
<ol>
<li>根据业务场景给不同的key设置不同的过期时间</li>
<li>设置键的永久期限（不推荐）</li>
</ol>
<h3 id="11-2Redis为什么这么快"><a href="#11-2Redis为什么这么快" class="headerlink" title="11.2Redis为什么这么快?"></a>11.2Redis为什么这么快?</h3><ol>
<li>完全基于内存操作</li>
<li>C语言编写，使用优化过的基本数据结构</li>
<li>单线程，无上下文切换成本</li>
<li>NIO：非阻塞的IO多路复用</li>
</ol>
<h3 id="11-3那为什么Redis6-0之后又改成了多线程？"><a href="#11-3那为什么Redis6-0之后又改成了多线程？" class="headerlink" title="11.3那为什么Redis6.0之后又改成了多线程？"></a>11.3那为什么Redis6.0之后又改成了多线程？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Redis使用多线程并非摒弃单线程，Redis的多线程只是在处理数据的读写和协议解析的时候使用，在执行命令时还是使用单线程。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 目的是Redis的性能瓶颈是网络IO而非CPU，使用多线程来处理IO读写效率从而提升整体Redis效率。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-4Redis的热key问题是什么？怎么解决热key问题？"><a href="#11-4Redis的热key问题是什么？怎么解决热key问题？" class="headerlink" title="11.4Redis的热key问题是什么？怎么解决热key问题？"></a>11.4Redis的热key问题是什么？怎么解决热key问题？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 所谓热key问题，就是一瞬间大量热点数据访问redis中某个key，瞬间达到物理网卡上限，导致Redis宕机。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 解决热key问题可以将热点key加入二级缓存，如果Redis宕机，直接从内存中读取。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-5持久化方式有那些？"><a href="#11-5持久化方式有那些？" class="headerlink" title="11.5持久化方式有那些？"></a>11.5持久化方式有那些？</h3><ol>
<li><p>RDB</p>
<p>内存快照</p>
</li>
<li><p>AOF</p>
<p>日志追加</p>
</li>
</ol>
<h3 id="11-6Redis如何实现高可用？"><a href="#11-6Redis如何实现高可用？" class="headerlink" title="11.6Redis如何实现高可用？"></a>11.6Redis如何实现高可用？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 主从复制架构</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 主从复制架构是最简单实现高可用的方案，核心就是主从同步。主从同步的原理：</span></span><br><span class="line"><span class="bullet">1.</span> slave发送sync命令到master</span><br><span class="line"><span class="bullet">2.</span> master收到sync之后，执行bgsave，生成RDB全量文件</span><br><span class="line"><span class="bullet">3.</span> master把slave的写命令记录到缓存</span><br><span class="line"><span class="bullet">4.</span> bgsave执行完毕之后，发送RDB文件到slave，slave执行</span><br><span class="line"><span class="bullet">5.</span> master发送缓存中的写命令到slave，slave执行</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 哨兵模式</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 哨兵模式解决了主从复制无法实现的自动故障转移、集群监控、消息通知。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-7Redis集群的原理是什么？"><a href="#11-7Redis集群的原理是什么？" class="headerlink" title="11.7Redis集群的原理是什么？"></a>11.7Redis集群的原理是什么？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Redis集群</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Redis集群是Redis提供的分布式存储方案，利用分片sharding来对数据进行共享，同时还提供自动故障转移和复制功能。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 节点</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 一个Redis集群由多个节点构成，节点之间通过cluster meet命令进行链接。连接的握手过程：</span></span><br><span class="line"><span class="bullet">1.</span> 节点A收到客户端的cluster meet命令</span><br><span class="line"><span class="bullet">2.</span> 节点A根据接收到的IP和PORT向节点B发送meet消息</span><br><span class="line"><span class="bullet">3.</span> 节点B收到meet消息返回ping给节点A</span><br><span class="line"><span class="bullet">4.</span> 节点A收到ping消息返回pong给节点B，握手成功</span><br><span class="line"><span class="bullet">5.</span> 节点A通过gossip协议把节点B的信息传播给集群中其他节点，其他节点和节点B进行握手</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 补充：</span><br><span class="line"><span class="code">	发送meet消息是加入节点是发生的，发送ping-pong是每个节点每隔一秒就会从已知节点中随机选出5个节点，然后对这5个节点中最久没有发送过ping消息的节点发送ping，以此来检验被选中节点是否在线。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># Slot 槽</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 节点分为主节点、从节点，一个Reids集群中有16384个Slot槽，会均匀的分配到所有集群主节点中，读取数据时key进行哈希计算得到一个slot对应的值。主节点宕机从节点会接替主节点的所有slot槽。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 故障转移</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 如果节点B在被ping后没有相应pong，那么节点A会标记节点B为fail状态，超过半数节点标记节点B为fail状态，则节点B为宕机状态，节点B下的备份数据最多的将替代节点B，接收节点B的所有slot槽。整个过程和哨兵非常类似，都是基于Raft协议做选举。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-8了解Redis事务吗？"><a href="#11-8了解Redis事务吗？" class="headerlink" title="11.8了解Redis事务吗？"></a>11.8了解Redis事务吗？</h3><p><code>使用MULT、EXEC、WATCH命令来实现事务，事务的执行过程是多个命令按照顺序一次性执行完成，并在执行期间事务不会被中断，如果遇到其他正在执行的事务，会返回QUEUED。</code></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>代码整洁之道_读书笔记</title>
    <url>/2022/02/01/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>学习笔记</title>
    <url>/2021/03/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>文章着重点在于基础点细节的总结和解析，绝大部分代码都是上的源码和核心代码，对于原理的实现给出定义，需要配合自己动手写代码和动脑理解和分析来得出实际的理解，本文疏漏的地方可以在留言区给我留言，欢迎指正和技术讨论！</p>
</blockquote>
<span id="more"></span>

<h1 id="1-Java"><a href="#1-Java" class="headerlink" title="1    Java"></a>1    Java</h1><h2 id="1-1-Java-基础"><a href="#1-1-Java-基础" class="headerlink" title="1.1    Java 基础"></a>1.1    Java 基础</h2><h3 id="1-1-1-面向对象"><a href="#1-1-1-面向对象" class="headerlink" title="1.1.1    面向对象"></a>1.1.1    面向对象</h3><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul>
<li>封装：</li>
</ul>
<p>将数据的属性和方法隐藏在内部，对外提供接口。</p>
<ul>
<li>继承：</li>
</ul>
<p>将数据的非私有属性和方法传递给子类。</p>
<p>父类引用指向子类对象成为<strong>向上转型</strong>。</p>
<ul>
<li>多态：</li>
</ul>
<p>多态分为编译时多态和运行时多态：</p>
<p>编译时多态：主要是指方法的重载</p>
<p>运行时多态：主要是指对象引用所指向的具体类型需要在运行期间确定</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型：</p>
<ul>
<li><p>byte/8</p>
</li>
<li><p>short/16</p>
</li>
<li><p>int/32</p>
</li>
<li><p>long/64</p>
</li>
<li><p>float/32</p>
</li>
<li><p>double/64</p>
</li>
<li><p>boolean/1</p>
</li>
<li><p>char/16</p>
</li>
</ul>
<h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><ul>
<li><p>new Integer(123)  每次都创建新的对象；</p>
</li>
<li><p>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一对象的引用。</p>
</li>
<li><p>valueOf() 会先判断值是否在缓存池中，如果有则直接返回缓存池中的内容，如果没有则在缓存池中创建值。</p>
</li>
<li><p>编译器会在基本数据类型缓冲范围内进行自动装箱过程中调用valueOf()。</p>
</li>
<li><p>Java 8中，基本数据类型的缓冲池范围：</p>
</li>
<li><p>Byte、Short、Integer缓存池的大小默认是 -128~127。</p>
</li>
<li><p>Boolean values true and false。</p>
</li>
<li><p>Character int the range \u0000 to \u007F  （符号、数字、字母）</p>
</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 被 final 声明，因此不可被继承。</p>
<p>内部使用 char[] 存储数据，被 final 修饰，因此 String 不可被修改。</p>
<h5 id="不可变的好处？为什么String不可变？"><a href="#不可变的好处？为什么String不可变？" class="headerlink" title="不可变的好处？为什么String不可变？"></a>不可变的好处？为什么String不可变？</h5><ol>
<li><p>缓存 hash 值</p>
<p>因为 String 的 hash 经常被使用，比如 HashMap 的 Key，不可变可以使 hash 值不变，只需要进行一次 hash 计算。</p>
</li>
<li><p>String Pool 需要</p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
</li>
<li><p>安全性</p>
</li>
<li><p>线程安全</p>
<p>因为 String 不可变，因此天生线程安全。</p>
</li>
</ol>
<h5 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h5><ol>
<li><p>可变性</p>
<ul>
<li><p>String 不可变</p>
</li>
<li><p>StringBuffer、StringBuilder 可变</p>
</li>
</ul>
</li>
<li><p>线程安全</p>
<ul>
<li>String 不可变，所以线程安全</li>
<li>StringBuilder 线程不安全</li>
<li>StringBuffer 线程安全，内部使用 synchronized 进行同步</li>
</ul>
</li>
</ol>
<h5 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h5><p>intern() 可以保证相同内容的字符串变量引用同一内存对象。</p>
<p>当 String 调用 intern() 时，如果字符串常量池中没有该值，则在字符串常量池中先创建该值，再讲常量池中的字符串引用返回；如果常量池中已经存在该值，则直接返回常量池中的字符串引用。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><p>Java中的参数传递是值传递，而不是引用传递。</p>
<h4 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h4><p>1.1默认属于 double，不能直接赋值给float，因为不能隐式向下转型</p>
<p>1.1f 才属于 float</p>
<h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><p>隐式类型转换不能向下转型，只能向上转型，就是朝着比自己范围更大的类型转型。</p>
<h4 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException`</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><ol>
<li>作用于类：无法被继承；</li>
<li>作用于方法：无法被重载；</li>
<li>作用于对象：无法被再次赋值。</li>
</ol>
<h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><ol>
<li><p>静态变量：属于类的变量，类的所有实例共享静态变量；</p>
</li>
<li><p>静态方法：类加载时就存在，所有的静态方法必须被实现（换句话说静态方法不能抽象）；</p>
</li>
<li><p>静态代码块：类初始化时运行一次；</p>
</li>
<li><p>静态内部类：非静态内部类需要依赖于外部类的实例，而静态内部类不需要；静态内部类不能访问外部类非静态方法和属性；</p>
</li>
<li><p>静态导包：在使用静态变量和方法时不需要声明 ClassName，但可读性大大降低；</p>
</li>
<li><p>初始化顺序：静态变量和静态代码块优先于普通变量和普通代码块，最后才是构造函数的初始化。以下为类初始化的加载顺序：</p>
<p>父类静态变量、父类静态代码块</p>
<p>子类静态变量、子类静态代码块</p>
<p>父类普通变量、父类普通代码块</p>
<p>父类构造函数</p>
<p>子类普通变量、子类普通代码块</p>
<p>子类构造函数</p>
</li>
</ol>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>反射可以提供运行时的类信息。</p>
<p><a href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html">反射机制详解</a></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p> <a href="https://pdai.tech/md/java/basic/java-basic-x-exception.html">异常机制详解</a></p>
<p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5CPPjwP.png" alt="img"></p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">泛型机制详解</a></p>
<p>泛型是JDK1.5提出的新特性，泛型提供了在编译时期的类型安全检测机制，该机制允许程序员在编译时期检测到非法的类型。泛型的本质是参数化类型，也就是说将所操作的数据类型被指定为参数。</p>
<p>泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span>&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> Point&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo24</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arsg[])</span></span>&#123;  </span><br><span class="line">        Info&lt;String&gt; i = <span class="keyword">null</span>;        <span class="comment">// 声明接口对象  </span></span><br><span class="line">        i = <span class="keyword">new</span> InfoImpl&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getObject</span><span class="params">(Class&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    T t = c.newInstance();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明一下，定义泛型方法时，必须在返回值前边加一个<code>&lt;T&gt;</code>，来声明这是一个泛型方法，持有一个泛型<code>T</code>，然后才可以用泛型T作为方法的返回值。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p><a href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html">注解机制详解</a></p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><h5 id="Java-SE-8"><a href="#Java-SE-8" class="headerlink" title="Java SE 8"></a>Java SE 8</h5><ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<h2 id="1-2-Java-集合框架"><a href="#1-2-Java-集合框架" class="headerlink" title="1.2    Java 集合框架"></a>1.2    Java 集合框架</h2><h3 id="Collection-关系图"><a href="#Collection-关系图" class="headerlink" title="Collection 关系图"></a>Collection 关系图</h3><p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5Cjava_collections_overview.png" alt="img"></p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>基于红黑树实现，支持有序性操作。查询的时间复杂度为 O(logN)。</p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>基于哈希实现，不支持有序性操作，插入无序。查询的时间复杂度为 O(1)。</p>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>具有HashSet的查询效率，且内部使用双向链表维护元素插入顺序。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>基于数组实现，查询效率高，但在数组内部进行添加删除元素效率低。线程不安全。</p>
<p>自动扩容：每当向数组中添加元素时，都会检测添加后元素个数是否超出数组长度，如果超出，调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span></span><br></pre></td></tr></table></figure>

<p>数组进行扩容时，会将老数组的元素重新拷贝一份到新数组，每次数组增加容量为原容量的 1.5 倍，这种操作代价很高，所以应尽量避免数组扩容，可以采用手动调用 ensureCapacity() 方法或者初始化时指定数组容量大小。</p>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>和 ArrayList 类似，线程安全。</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>基于双向链表实现，查询效率比 ArrayList 低，但可以快速在链表中间插入和删除元素。LinkedList 还可以用作栈、队列、双向队列。</p>
<p>LinkedList 同时实现了 List 和 Deque 接口，所以说既可以看做是一个列表，可以以看做是一个队列。当你需要使用栈时，还可以当做栈来使用，因为 Java 官方已经不推荐使用 Stack 了，当然，现在使用栈时更推荐使用 ArrayDeque，它比 LinkedList 当做栈使用时效率更高。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><h5 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>可以用来做双向队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>优先队列，基于堆结构实现。优先队列的作用是每次取出的元素都是队列中权值最小的（ Java 中的优先队列取权值最小的，C++ 中的优先队列取权值最大的）。</p>
<p>小顶堆。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>基于哈希表实现，内部数据结构为链表+数组的形式，Java 8 以后改为链表+数组+红黑树的形式。</p>
<p>HashMap的扩容。</p>
<p>HashMap的查询时间复杂度 O(1)。</p>
<h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>基于红黑树实现。</p>
<h5 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h5><p>和 HashMap 类似，在 HashMap 基础上每个方法都加了 synchronized 关键字保证线程安全，但多线程访问时会锁住整个数据结构，不推荐使用。</p>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>线程安全，相比 HashTable 效率更高，JDK1.7使用分段锁加锁，JDK1.7使用Synchronized+CAS加锁。</p>
<p>简单总结一下JDK1.8的ConcurrentHashMap的加锁机制，当头结点为空时，使用CAS机制赋值，当头结点不为空时，Synchronized锁住当前头结点，判断当前头结点和期望头结点是否一致，这个过程就像CAS机制的判断过程一暗影，如果一致，则进行赋值操作，如果不一致，则重新对头结点进行赋值预期值，重新锁住头结点，巴拉巴拉。。。其实这样做的道理很简单，因为对头结点赋值的操作和锁住头结点的操作是两个时刻的操作，如果这个过程中有其他线程对头结点进行了一些修改，那就出问题了。</p>
<h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p>使用双向链表来维护元素顺序，顺序为插入顺序或者最近最少使用顺序（LRU）。</p>
<h3 id="集合框架相关问题"><a href="#集合框架相关问题" class="headerlink" title="集合框架相关问题"></a>集合框架相关问题</h3><ol>
<li><p>Stack，ArrayDeque，LinkedList的区别</p>
<p>底层存储结构方面：</p>
<ul>
<li><p>Stack 长度为 10 的数组；</p>
</li>
<li><p>ArrayDeque 长度为 16 的数组；</p>
</li>
<li><p>LinkedList 链表。</p>
</li>
</ul>
<p>线程安全方面：</p>
<ul>
<li>Stack 线程安全</li>
<li>ArrayDeque 线程不安全</li>
<li>LinkedList 线程不安全</li>
</ul>
<p>性能选择方面：</p>
<ul>
<li>需要线程同步的话，使用 Collections.synchronizedxxx() 讲ArrayDeque 或 LinkedList 转换成线程安全的。</li>
<li>频繁插入删除，使用 LinkedList。</li>
<li>频繁随机访问，使用ArrayDeque。</li>
<li>未知初始数据容量，使用 LinkedList。</li>
</ul>
</li>
<li><p>栈和队列</p>
<p>Java 中有 Stack 的类，没有 Queue 的类（ Queue 是接口）。当使用栈时，Java 官方已经不推荐使用 Stack 了，而是使用效率更高的 ArrayDeque。既然 Queue 只是一个接口，当需要使用队列时，首选 ArrayDeque（次选 LinkedList）。</p>
</li>
</ol>
<h2 id="1-3-Java-多线程与并发"><a href="#1-3-Java-多线程与并发" class="headerlink" title="1.3    Java 多线程与并发"></a>1.3    Java 多线程与并发</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li><p>什么是死锁？</p>
<p>死锁是多个线程抢占公共资源而出现线程僵持，若无外力作用，它们都将无法继续前进。</p>
</li>
<li><p>死锁产生的原因</p>
<p>资源竞争、进程推进顺序非法</p>
</li>
<li><p>死锁产生的四个必要条件</p>
<ul>
<li>互斥条件</li>
<li>请求保持</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ul>
</li>
<li><p>预防死锁的方式</p>
<ul>
<li>资源一次性分配（破坏请求条件）</li>
<li>不能一次性得到所有资源，则一个资源也不分配（破坏保持条件）</li>
<li>可剥夺资源（破坏不可剥夺）</li>
<li>资源有序分配法</li>
</ul>
</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>创建线程池的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime, // 保持时间</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit, // 保持时间的单位</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue, // 等待队列</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory, // 线程工厂</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span></span>; <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure>

<p>几种常用的线程池类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Excutors.newFixdThreadPool(<span class="keyword">int</span> nThread); <span class="comment">// 固定线程池</span></span><br><span class="line">Excutors.newCacheThreadPool(); <span class="comment">// 无边界线程池</span></span><br><span class="line">Excutors.newSingleThreadPool(); <span class="comment">// 单线程池</span></span><br></pre></td></tr></table></figure>

<p>拒绝策略（上源码，自己悟）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that runs the rejected task</span></span><br><span class="line"><span class="comment"> * directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span></span><br><span class="line"><span class="comment"> * unless the executor has been shut down, in which case the task</span></span><br><span class="line"><span class="comment"> * is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment"> * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment"> * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment"> * rejected task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;..&#125;</span><br></pre></td></tr></table></figure>







<h3 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h3><p>CAS机制叫做Compare And Swap，CAS机制中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>每次更新新值会判断内存地址V得值和预期值A是否一致，一致才会更新新值B，否则自旋，重新得到预期值A和计算新值B，这样来保证线程安全。</p>
<p>从思想上来说，synchronized是悲观锁，悲观的认为并发情况极其严重，所以无论如何也保证线程安全；CAS机制是乐观锁，乐观的认为并发情况并不严重，所以无限次的去重试更新。</p>
<h4 id="CAS机制的缺点"><a href="#CAS机制的缺点" class="headerlink" title="CAS机制的缺点"></a>CAS机制的缺点</h4><ul>
<li>CPU开销过大，毕竟都乐观锁了，不断地尝试肯定对CPU有不小的开销</li>
<li>不能保证代码块的原子性</li>
<li>ABA问题：这事CAS机制最大的问题所在</li>
</ul>
<h4 id="CAS机制的ABA问题"><a href="#CAS机制的ABA问题" class="headerlink" title="CAS机制的ABA问题"></a>CAS机制的ABA问题</h4><p>A线程：内存值为200，希望更改为100</p>
<p>B线程：内存值为200，希望更改为100</p>
<p>A线程执行完了，内存值为100，但是B线程卡住了，并且C线程进来了</p>
<p>C线程：内存值为100，希望更改为200</p>
<p>C线程执行完了，内存值为200，这之后B线程好了，B读取的内存值为200，确实是和期望的值一致，并且更改了值为100</p>
<p>这就是问题所在，解决的方式就是使用<code>版本号</code></p>
<blockquote>
<p>在Java中，AtomicStampedReference类就实现了用版本号作比较额CAS机制。</p>
</blockquote>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>保证原子性、可见性、有序性</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>修饰实例方法，对当前实例对象加锁</li>
<li>修饰静态方法，对当前类的Class对象加锁</li>
<li>修饰代码块，对synchronized括号内的对象加锁</li>
</ul>
<h4 id="Synchronized实现原理"><a href="#Synchronized实现原理" class="headerlink" title="Synchronized实现原理"></a>Synchronized实现原理</h4><p>JVM通过进入和退出Monitor对象来实现方法的同步和代码块的同步。</p>
<p>方法级的同步是隐式的，无需通过字节码指令来控制，它实现在方法调用和返回操作中。调用指令在会检测方法常量表中ACC_SYNCHRONIZED标志是否被设置，如果设置了，执行线程将持有monitor，然后再执行方法，在方法完成时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit两个字节码指令，它们位于代码块的开始和结束位置，当执行到monitorenter时，当前线程尝试获取monitor对象的所有权，如果未加锁或者已经被当前线程加锁，那么就把锁的计数器+1，当执行到monitorexit时，锁的计数器-1；如果锁计数器不为0，如获取monitor所有权失败，当前线程被阻塞，直到其他线程释放锁。</p>
<p>来举个栗子！^_^</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;    <span class="comment">//这个是同步方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;		<span class="comment">//这个是同步代码块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译来瞅一眼JVM底层指令走的过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -verbose SynchronizedDemo</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">public synchronized void f();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED # 兄弟们看这里, 对于方法就是加了标识位</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=1, args_size=1</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String Hello world</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 6: 0</span><br><span class="line">      line 7: 8</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       9     0  this   Lcom/yueyang/SynchronizedDemo;</span><br><span class="line"></span><br><span class="line">public void g();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: monitorenter  # 这里这里, 代码块开头加monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #3                  // String Hello world</span><br><span class="line">       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: monitorexit</span><br><span class="line">      14: goto          22</span><br><span class="line">      17: astore_2</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: monitorexit # 这里这里, 代码块结尾加monitorexit</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: athrow</span><br><span class="line">      22: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           4    14    17   any</span><br><span class="line">          17    20    17   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 10: 0</span><br><span class="line">      line 11: 4</span><br><span class="line">      line 12: 12</span><br><span class="line">      line 13: 22</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      23     0  this   Lcom/yueyang/SynchronizedDemo;</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 17</span><br><span class="line">        locals = [ class com/yueyang/SynchronizedDemo, class java/lang/Object ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = 250 /* chop */</span><br><span class="line">        offset_delta = 4</span><br></pre></td></tr></table></figure>

<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>作用：保证可见性</p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><h4 id="Java-并发的理论知识"><a href="#Java-并发的理论知识" class="headerlink" title="Java 并发的理论知识"></a>Java 并发的理论知识</h4><ul>
<li><p>多线程的出现是要解决什么问题？</p>
<p>众所周知，IO 设备、内存、CPU 之间速度有很大差异，为了更完全的使用 CPU 的高性能，平衡三者之间的速度差异，CPU、操作系统、编译程序都做出了贡献：</p>
<ul>
<li>CPU 增加缓存，平衡了 CPU 与内存的速度差异。导致可见性问题</li>
<li>操作系统增加了线程、进程，复用CPU，平衡了 CPU 与 IO 设备的速度差异。导致了原子性问题</li>
<li>编译程序优化指令执行次序，使缓存合理利用。导致有序性问题</li>
</ul>
</li>
<li><p>线程不安全是指什么? </p>
<p>线程不安全指的是多个线程对共享数据进行操作，会导致多次相同操作的结果不同。</p>
</li>
<li><p>并发出现线程不安全的本质什么? 可见性，原子性，有序性</p>
<ul>
<li><p>可见性：CPU 缓存引起的</p>
</li>
<li><p>原子性：分时复用问题</p>
<p>经典的<strong>转账问题</strong>：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
</li>
<li><p>有序性：重排序引起</p>
</li>
</ul>
</li>
<li><p>JAVA是怎么解决并发问题的: JMM(Java内存模型)</p>
<p><a href="https://www.infoq.cn/minibook/java_memory_model">https://www.infoq.cn/minibook/java_memory_model</a></p>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="1-4-Java-IO-NIO-AIO"><a href="#1-4-Java-IO-NIO-AIO" class="headerlink" title="1.4    Java IO/NIO/AIO"></a>1.4    Java IO/NIO/AIO</h2><h2 id="1-5-Java-新版本特性"><a href="#1-5-Java-新版本特性" class="headerlink" title="1.5    Java 新版本特性"></a>1.5    Java 新版本特性</h2><h2 id="1-6-Java-JVM相关"><a href="#1-6-Java-JVM相关" class="headerlink" title="1.6    Java JVM相关"></a>1.6    Java JVM相关</h2><h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>JDK1.7：<code>堆</code>，<code>栈</code>，<code>方法区</code>，<code>程序计数器</code>，<code>本地方法栈</code></p>
<p>JDK1.8：<code>堆</code>，<code>栈</code>，<code>程序计数器</code>，<code>本地方法栈</code></p>
<p>JDK1.8将<code>方法区</code>改成<code>元空间</code>，从虚拟机内存中移出到本地内存</p>
<p>方法区也称为永久代，存放<code>静态变量</code>、<code>常量</code>、<code>类信息</code>、<code>运行时常量池</code>；</p>
<h3 id="JVM-GC"><a href="#JVM-GC" class="headerlink" title="JVM GC"></a>JVM GC</h3><h4 id="JDK1-8默认垃圾收集器"><a href="#JDK1-8默认垃圾收集器" class="headerlink" title="JDK1.8默认垃圾收集器"></a>JDK1.8默认垃圾收集器</h4><p>查看方式：Java -XX:PrintCommandLineFlags -version</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=133385472 -XX:MaxHeapSize=2134167552 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC -- 默认垃圾收集器</span><br><span class="line">java version &quot;1.8.0_281&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_281-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode)</span><br></pre></td></tr></table></figure>

<p>JDK1.8的默认值是UseParallelGC，打开此开关后，使用<code>新生代（Parallel Scavenge）</code>，<code>老年代（Ps MarkSweep）</code>的收集器组合进行内存回收。</p>
<p><code>新生代收集器（Parallel Scavenge）</code>是采用标记复制算法、多线程模型进行垃圾收集。</p>
<p>与其他新生代垃圾收集器的差别是，它更关注于吞吐量，而不是停顿时间。一般来说，需要与用户交互的</p>
<p>程序更关注较短的停顿时间，而如果是需要达成尽量大的吞吐量的话，则该处理器会更加适合。</p>
<p>其通过<code>-XX：UseAdaptiveSizePolicy</code>参数，可以开启其自动调节功能，适用于对垃圾收集器的调优不太了解的</p>
<p>用户。</p>
<h4 id="如何查看GC日志？"><a href="#如何查看GC日志？" class="headerlink" title="如何查看GC日志？"></a>如何查看GC日志？</h4><p>JVM参数中添加：<code>-Xloggc : gc.log</code></p>
<h1 id="2-算法"><a href="#2-算法" class="headerlink" title="2    算法"></a>2    算法</h1><h2 id="2-1-数据结构基础"><a href="#2-1-数据结构基础" class="headerlink" title="2.1    数据结构基础"></a>2.1    数据结构基础</h2><h2 id="2-2-常见排序算法"><a href="#2-2-常见排序算法" class="headerlink" title="2.2    常见排序算法"></a>2.2    常见排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortTest</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">int</span> num = array[i];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt; num)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                array[i++] = array[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt; num)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                array[j--] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        array[i] = num;</span><br><span class="line">        quickSortTest(array, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSortTest(array, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3    数据库"></a>3    数据库</h1><h2 id="3-1-关系型数据库"><a href="#3-1-关系型数据库" class="headerlink" title="3.1    关系型数据库"></a>3.1    关系型数据库</h2><p>关系型数据库查询的流程：</p>
<ol>
<li><p>客户端管理器</p>
<p>当连接数据库时：</p>
<ul>
<li>验证账号密码，验证访问权限</li>
<li>检查进程是否有空余</li>
<li>检查数据库负载是否严重</li>
<li>管理器花一段时间来获取资源</li>
<li>管理器发送查询语句给查询管理器</li>
<li>得到数据后保存到缓冲区，向你发送数据</li>
</ul>
</li>
<li><p>查询管理器</p>
<ul>
<li>查询解析器：解析，并判断是否合法</li>
<li>查询重写器：预优化，避免不必要的计算，给优化器提供最佳解决方案</li>
<li>统计</li>
<li>查询优化器</li>
<li></li>
</ul>
</li>
<li><p>数据管理器</p>
</li>
<li><p>客户端管理器</p>
</li>
</ol>
<h2 id="3-3非关系型数据库"><a href="#3-3非关系型数据库" class="headerlink" title="3.3非关系型数据库"></a>3.3非关系型数据库</h2><h2 id="3-4-事务"><a href="#3-4-事务" class="headerlink" title="3.4 事务"></a>3.4 事务</h2><h3 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h3><ul>
<li><strong>原子性</strong>：要么全部执行，要么全部不执行；就像一件事一样，是不可再分的。</li>
<li><strong>一致性</strong>：事务执行前后，数据库完整性不会被破坏；就像A给B转账，A少了钱，B不可能不加钱。</li>
<li><strong>隔离性</strong>：同一时间，只允许一个事务访问同一数据；就像A取钱到结束之前，B不可能对这个账号进行转账操作。</li>
<li><strong>持久性</strong>：事务结束之后，数据永久性保存在数据库中，不能再回滚。</li>
</ul>
<h3 id="事务并发会造成问题"><a href="#事务并发会造成问题" class="headerlink" title="事务并发会造成问题"></a>事务并发会造成问题</h3><ul>
<li><p><strong>脏读</strong>：事务A读到了事务B为提交的数据，然后B回滚了，A就读多了就叫脏读。</p>
</li>
<li><p><strong>不可重复读</strong>：事务A多次读取同一数据，但是B在A多次读取同一数据过程中，修改并提交了一部分数据，导致多次读取的数据结果不一致。</p>
</li>
<li><p><strong>幻读</strong>：事务A读取数据时，事务B插入了一条不太一致的数据，导致A读取到的数据和其他数据不太一致，就像幻觉一样。</p>
<p><code>不可重复读和幻读的区别在于，不可重复读是修改一条数据，幻读是增删了数据。所以解决方案上不可重复读只需要锁住行，幻读需要锁住表。</code></p>
</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><table>
<thead>
<tr>
<th align="center">事务隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（read-uncommited）<br>（可以读取到未提交的数据）</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">读提交（read-commited）<br>（）</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可重复读（repeatable-read）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">串行化（seriallizable）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：</p>
<ul>
<li>事务隔离级别为读提交时，写数据只会锁住相应的行</li>
<li>事务隔离级别为可重复读时，如果索引条件有索引的话，默认加锁方式是next-key锁；如果没有索引，那么会锁住整张表，这样可以方式幻读</li>
<li>事务隔离级别为串行化时，读写都会锁住整张表，完全保证了事务的安全情况下也具有极低的并发性，开发中不推荐使用</li>
<li>事务隔离级别越高，越能保证数据的完整性，但是相应的对并发的影响也越大</li>
</ul>
<h3 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PROPAGATION_REQUIRED<br/>（必须是事务）</td>
<td align="center">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td align="center">PROPAGATION_SUPPORTS<br>（支持事务，没有就算了）</td>
<td align="center">支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td align="center">PROPAGATION_MANDATORY<br>（强制性，如果没有事务报错）</td>
<td align="center">使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td align="center">PROPAGATION_REQUIRES_NEW<br>（必须新建，原来有事务就等着）</td>
<td align="center">新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NOT_SUPPORTED<br>（不支持事务，原来有事务就等着）</td>
<td align="center">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NEVER<br>（从不，不能以事务方式执行）</td>
<td align="center">以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NESTED<br>（嵌套，作为原事务中的一个子事务）</td>
<td align="center">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<h1 id="4-Spring"><a href="#4-Spring" class="headerlink" title="4    Spring"></a>4    Spring</h1><p>IOC</p>
<p>PCG中台</p>
<p>9500</p>
<p>Spring声明周期：</p>
<p>Bean定义、实例化前、实例化、实例化后、属性注入、初始化前、初始化、初始化后、得到Bean。</p>
<p>Spring三级缓存：</p>
<p>一级缓存：单例池，singletonObjects，存放成熟的Bean</p>
<p>二级缓存：earlySingletonObjects，存放循环依赖过程中不完整的Bean</p>
<p>三级缓存：AOP</p>
<p>单例Bean：可以通过唯一ID来定位唯一实例的Bean对象</p>
<p>单例池：单例Bean的实现方式，使用Map实现，key是beanName，value是bean对象</p>
<p>单例模式：一种设计模式，程序运行期间只存在一个实例</p>
<h1 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5    设计模式"></a>5    设计模式</h1><h2 id="5-1-策略模式"><a href="#5-1-策略模式" class="headerlink" title="5.1    策略模式"></a>5.1    策略模式</h2><p>废话不多说，上代码来理解吧，人类的语言很难将设计模式讲明白，起码我不行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateSubtract</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperateAdd());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperateSubtract());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperateMultiply());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>核心思想</strong>：<code>抽象实现共性，接口实现特性</code></p>
<p>多使用行为特性的组合，少用共性抽象，这样更有弹性。</p>
<hr>
<h1 id="等待解决的面试题"><a href="#等待解决的面试题" class="headerlink" title="等待解决的面试题"></a>等待解决的面试题</h1><ul>
<li><p><input disabled="" type="checkbox">  了解一下 sonrt</p>
</li>
<li><p><input disabled="" type="checkbox">  了解一下 kafka</p>
</li>
<li><p><input disabled="" type="checkbox">  数据库：引擎、索引、事务、锁</p>
</li>
<li><p><input disabled="" type="checkbox">  计算机网络：TCP、UDP</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲 redis</p>
</li>
<li><p><input disabled="" type="checkbox">  面向对象的理解、面向过程的理解、多态的理解</p>
</li>
<li><p><input disabled="" type="checkbox">  深拷贝和浅拷贝，进行深拷贝的方式有那些？</p>
</li>
<li><p><input disabled="" type="checkbox">  讲一讲集合：List、Set、Map、ArrayList、LinkedList</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲泛型，如何使用？举个例子</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲异常</p>
</li>
<li><p><input disabled="" type="checkbox">  计算机网络分几层？分别使用什么协议？</p>
</li>
<li><p><input disabled="" type="checkbox">  MySql 事务特性的理解，并发问题，隔离级别</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲 cookie和session的区别、作用</p>
</li>
<li><p><input disabled="" type="checkbox">  linux常用命令：如何查看可用端口？lsof -i  和 netstat -aptn；如何查看日志？tail -f 、less、cat</p>
</li>
<li><p><input disabled="" type="checkbox">  什么是幂等？什么情况下需要考虑幂等？我是怎么解决幂等的？</p>
</li>
<li><p><input disabled="" type="checkbox">  多个线程同时读写，读线程的数量远远大于写线程，你认为应该如何解决 并发的问题？你会选择加什么样的锁？ReentrantReadWriteLock 读写锁；</p>
</li>
<li><p><input disabled="" type="checkbox">  JAVA的AQS是否了解，它是⼲嘛的？AbstractQueuedSynchronizer </p>
</li>
<li><p><input disabled="" type="checkbox">  除了synchronized关键字之外，你是怎么来保障线程安全的？加锁啊，就上面那个问题</p>
</li>
<li><p><input disabled="" type="checkbox">  什么时候需要加volatile关键字？它能保证线程安全吗？答案：在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：</p>
<ol>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>
</li>
<li><p>变量不需要与其他状态变量共同参与不变约束</p>
<p>能保证可见性、有序性，不能保证原子性，所以不能完全保证线程安全。</p>
</li>
</ol>
</li>
<li><p><input disabled="" type="checkbox">  线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部 塞满了之后，还是忙，再提交会发⽣什么？</p>
</li>
<li><p><input disabled="" type="checkbox">  TCP和UDP的区别？TCP可靠稳定传输慢，UDP迅速大量不可靠</p>
</li>
<li><p><input disabled="" type="checkbox">  互联网公司的分布式ID的生成策略？Redis生成ID并持久化、雪花算法</p>
</li>
<li><p><input disabled="" type="checkbox">  MySQL事务相关知识</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB笔记</title>
    <url>/2020/08/27/Mongo/</url>
    <content><![CDATA[<blockquote>
<p>  MongoDB的一些基本操作，只适用于日常开发，深入了解MongoDB请略过本文</p>
</blockquote>
<span id="more"></span>

<h1 id="Mongo数据库操作"><a href="#Mongo数据库操作" class="headerlink" title="Mongo数据库操作"></a>Mongo数据库操作</h1><p>在学习Mongo之后因为没有系统的做过总结，就想在此写一篇比较系统比较全面的日常操作数据库的SQL操作总结。本文实时补充</p>
<p>增</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>添加语句</span><br><span class="line"></span><br><span class="line">db.COLLECTION_NAME.insert(document)</span><br><span class="line"></span><br><span class="line">db.data.insert(&#123;</span><br><span class="line">	title:<span class="string">&#x27;测试添加操作&#x27;</span>,</span><br><span class="line">	<span class="keyword">by</span>:<span class="string">&#x27;YueYang&#x27;</span>,</span><br><span class="line">	<span class="type">time</span>:<span class="string">&#x27;11:08&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : <span class="number">1</span>, &quot;writeConcernError&quot; : [ ] &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>删</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除操作</span><br><span class="line"></span><br><span class="line">db.collection.remove(</span><br><span class="line">   <span class="operator">&lt;</span>query<span class="operator">&gt;</span>,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span>,</span><br><span class="line">     writeConcern: <span class="operator">&lt;</span>document<span class="operator">&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.data.remove(&#123;</span><br><span class="line">	<span class="keyword">by</span>:<span class="string">&#x27;YueYang&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">WriteResult(&#123; &quot;nRemoved&quot; : <span class="number">1</span>, &quot;writeConcernError&quot; : [ ] &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 更改操作</span><br><span class="line"></span><br><span class="line">db.collection.update(</span><br><span class="line">   <span class="operator">&lt;</span>query<span class="operator">&gt;</span>,</span><br><span class="line">   <span class="operator">&lt;</span>update<span class="operator">&gt;</span>,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span>,</span><br><span class="line">     multi: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span>,</span><br><span class="line">     writeConcern: <span class="operator">&lt;</span>document<span class="operator">&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.data.update(&#123;&quot;title&quot;:&quot;测试添加操作&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;&quot;title&quot;:&quot;测试更新操作&quot;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	&quot;nMatched&quot; : <span class="number">1</span>,</span><br><span class="line">	&quot;nUpserted&quot; : <span class="number">0</span>,</span><br><span class="line">	&quot;nModified&quot; : <span class="number">1</span>,</span><br><span class="line">	&quot;writeConcernError&quot; : [ ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.data.update(&#123;&quot;title&quot;:&quot;测试添加操作&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;&quot;title&quot;:&quot;测试更新操作&quot;&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	&quot;nMatched&quot; : <span class="number">2</span>,</span><br><span class="line">	&quot;nUpserted&quot; : <span class="number">0</span>,</span><br><span class="line">	&quot;nModified&quot; : <span class="number">2</span>,</span><br><span class="line">	&quot;writeConcernError&quot; : [ ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询操作</span><br><span class="line"></span><br><span class="line">db.data.find(&#123;&quot;by&quot;:&quot;YueYang&quot;&#125;);</span><br><span class="line"></span><br><span class="line">_id            				title    	<span class="keyword">by</span>		<span class="type">time</span></span><br><span class="line"><span class="number">5</span>dafd24abc1b000007001bf7	测试更新操作	YueYang	<span class="number">11</span>:<span class="number">08</span></span><br><span class="line"><span class="number">5</span>dafd2e5bc1b000007001bf8	测试更新操作	YueYang	<span class="number">12</span>:<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>条件查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">大于		 $gt</span><br><span class="line">小于		 $lt</span><br><span class="line">大于等于 	gte</span><br><span class="line">小于等于	$lte</span><br><span class="line">不等于		 $ne</span><br><span class="line">等于		  $eq</span><br><span class="line">包含于 	 $<span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.data.find(&#123;age: &#123;$gt : <span class="number">18</span>&#125;&#125;); <span class="comment">-- select * from data where age &gt; 18;</span></span><br></pre></td></tr></table></figure>

<p>模糊查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询 title 包含&quot;测试&quot;字的文档：</span><br><span class="line">db.data.find(&#123;title:<span class="operator">/</span>测试<span class="operator">/</span>&#125;);</span><br><span class="line"></span><br><span class="line">查询 title 字段以&quot;教&quot;字开头的文档：</span><br><span class="line">db.data.find(&#123;title:<span class="operator">/</span><span class="operator">^</span>测试<span class="operator">/</span>&#125;);</span><br><span class="line"></span><br><span class="line">查询 titl e字段以&quot;教&quot;字结尾的文档：</span><br><span class="line">db.data.find(&#123;title:<span class="operator">/</span>教$<span class="operator">/</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>模糊查询查询字段掌握了正则表达式就很容易扩展出来啦~<br>三种正则表达式方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&#123; <span class="operator">&lt;</span> field <span class="operator">&gt;</span>： &#123; $ regex ： <span class="operator">/</span> <span class="keyword">pattern</span> <span class="operator">/</span> ， $ options ： ‘’ &#125; &#125;</span><br><span class="line">&#123; <span class="operator">&lt;</span> field <span class="operator">&gt;</span>： &#123; $ regex ： ‘<span class="keyword">pattern</span>’ ， $ options ： ‘’ &#125; &#125;</span><br><span class="line">&#123; <span class="operator">&lt;</span> field <span class="operator">&gt;</span> ： &#123; $ regex ： <span class="operator">/</span> <span class="keyword">pattern</span> <span class="operator">/</span> <span class="operator">&lt;</span> options <span class="operator">&gt;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 数据排序</span><br><span class="line"></span><br><span class="line">db.data.find().sort(&#123;title:<span class="number">1</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 其中 <span class="number">1</span> 为升序排列，而 <span class="number">-1</span> 是用于降序排列</span><br></pre></td></tr></table></figure>

<p>分组操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.data.aggregate([&#123;</span><br><span class="line">    $<span class="keyword">group</span>: &#123;</span><br><span class="line">        _id: &#123;</span><br><span class="line">            title: <span class="string">&#x27;$title&#x27;</span>,</span><br><span class="line">            <span class="keyword">by</span>: <span class="string">&#x27;$by&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        count: &#123;</span><br><span class="line">            $sum: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    $<span class="keyword">match</span>: &#123;</span><br><span class="line">        count: &#123;</span><br><span class="line">            $gt: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">$<span class="keyword">group</span></span><br><span class="line">将集合中的文档分组，可用于统计结果</span><br><span class="line">_id表示分组的依据，使用某个字段的格式为<span class="string">&#x27;$字段&#x27;</span>。</span><br><span class="line"></span><br><span class="line">$<span class="keyword">match</span></span><br><span class="line">用于过滤数据，只输出符合条件的文档</span><br></pre></td></tr></table></figure>

<p>删除重复数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 前面写查询语句，对结果数据进行去重</span><br><span class="line">.forEach(<span class="keyword">function</span>(it) &#123;</span><br><span class="line">    it.dups.shift();</span><br><span class="line">    db.data.remove(&#123;</span><br><span class="line">        _id: &#123;</span><br><span class="line">            $<span class="keyword">in</span>: it.dups</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>删除_id失败？</p>
<p>对id直接进行remove删除失败，是因为id是ObjectId类型，而id是字符串类型，类型对应不上就会导致删除失败。</p>
<p>解决方法就是把id转换成ObjectId：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.data.remove(&#123;_id:ObjectId(<span class="string">&#x27;1013&#x27;</span>)&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>整理备份</title>
    <url>/2021/12/30/%E6%95%B4%E7%90%86%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h5 id="20211230"><a href="#20211230" class="headerlink" title="20211230"></a>20211230</h5><p><code>range for 拷贝问题</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> list &#123;</span><br><span class="line">		list = <span class="built_in">append</span>(list, i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(list); i++ &#123;</span><br><span class="line">		list = <span class="built_in">append</span>(list, i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>切片翻转排序</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[i] &gt; nums[j]</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>PerAuthorize注解</title>
    <url>/2020/08/14/%E6%B3%A8%E8%A7%A3PerAuthorize%E7%94%A8%E4%BD%9C%E6%8E%88%E6%9D%83%E6%97%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>

<p>@PerAuthorizr 这个注解我相信很多不使用SpringSecurity的小伙伴都不是很了解。<br>使用他的初衷是最近需要做一个对授权的客户做判断，让他买了哪些模块的代码才能使用哪些模块的代码，需要进行一波模块过滤。<br>@PreAuthorize是可以用来控制一个方法或类是否能够被调用的，通俗一点就是看看你有没有权利用被注解的东西。怎么用呢？直接上代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取部门列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ac.hasPermi(&#x27;dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult <span class="title">list</span><span class="params">(SysDept dept)</span> </span>&#123;</span><br><span class="line">    List&lt;SysDept&gt; depts = deptService.selectDeptList(dept);</span><br><span class="line">    <span class="keyword">return</span> AjaxResult.success(depts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里@PreAuthorize(“@ac.hasPermi(‘dept:list’)”)是调用别名为as类的hasPermi方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 根据授权文件获取接口权限</span><br><span class="line">*/</span><br><span class="line">public boolean hasPermi(String permission) &#123;</span><br><span class="line">	log.debug(&quot; 当前模块：&#123;&#125; 当前权限：&#123;&#125; &quot;, permission, AuthorizationConfig.isAccess() &amp;&amp; authorizationConfig.getMk().indexOf(permission) &gt;= 0);</span><br><span class="line">    return AuthorizationConfig.isAccess() &amp;&amp; authorizationConfig.getMk().indexOf(permission) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里就简单写一下供大家参考。<br>判断结果返回true则正常调用接口，false则接口返回403。</p>
<p>加在类头上依然有效，上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部门信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ac.hasPermi(&#x27;mk&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/dept&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysDeptController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISysDeptService deptService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放了类头上会在每次调用改类方法的时候都会进行一次判断。</p>
<p>这样授权给用户的功能实现了，但是一个用户登录过之后，每次请求接口都要进行一次权限判断，这显然不合理，所以我想加上一个给每个用户本次登录判断完权限有之后加一个标识。这个写好了就更新~</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>软件备份</title>
    <url>/2021/07/07/%E8%BD%AF%E4%BB%B6%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<blockquote>
<p>  针对于MacOS、CentOS、Windows系统的软件安装教程备份，长期维护，建议收藏</p>
</blockquote>
<span id="more"></span>

<h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a><code>Git</code>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- linux</span><br><span class="line">sudo dnf install git-all</span><br></pre></td></tr></table></figure>

<h3 id="Ruby安装"><a href="#Ruby安装" class="headerlink" title="Ruby安装"></a><code>Ruby</code>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- linux</span><br><span class="line">sudo yum install ruby</span><br></pre></td></tr></table></figure>

<h3 id="HomeBrew安装"><a href="#HomeBrew安装" class="headerlink" title="HomeBrew安装"></a><code>HomeBrew</code>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- linux</span><br><span class="line">/bin/bash -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br><span class="line">-- mac</span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>终极目标！</title>
    <url>/2020/07/29/%E7%BB%88%E6%9E%81%E7%9B%AE%E6%A0%87%EF%BC%81/</url>
    <content><![CDATA[<blockquote>
<p>  有目标的执行计划是走向成功的捷径，我希望可以通过给自己制定一个个阶段的目标来时刻激励自己无限学习和不断进步，本文的目的是将自己从事于程序开发工作以来的目标制定公布于大众，以此来时刻警醒自己来不断缩小与优秀程序员的差距！</p>
</blockquote>
<span id="more"></span>

<p>时间：<code>2020-07-29 15:29☀️</code></p>
<h1 id="给自己定个一年后的终极目标！"><a href="#给自己定个一年后的终极目标！" class="headerlink" title="给自己定个一年后的终极目标！"></a>给自己定个一年后的终极目标！</h1><p>今年的小目标<br>2019年7月3日入职现在这家公司，做后端开发已经整整一年了，这一年里见证着自己一步步完成设定的每一个小目标，自己成长的痕迹，有些欣慰，也有些压力。欣慰是能按照既定的轨迹进行着程序人生的规划路线，压力在于对自己成长速度的不够认可。<br>所以，今年给自己定的终极目标就是：一年之后加入miHoYo！</p>
<p>目标的缘由<br>和联调的前端同事交流的时候，我们突然聊到miHoYo公司，她说她有个同学是在miHoYo工作，聊到miHoYo那我瞬间就精神起来了，毕竟是我喜欢了崩坏系列很多年，自然了解miHoYo公司和其他公司不同的地方，是发自真心的喜欢这家公司，如果以后能在自己喜欢的公司工作的话，岂不是快乐加倍？<br>所以，即刻了解了一下miHoYo公司的招聘岗位和要求，发现：Java岗位（我做的是Java研发）需要5年开发经验？！Golang语言必须要有实际项目开发经验？！平台前端开发也要有经验的呢~看来现学现卖已经经不通了，于是我大胆做出一个决定，在接下来的一年里，为我热爱的公司，付出双倍努力的学习，让自己有机会进入miHoYo！</p>
<p>接下来的心里路程<br>其实想到这里，我心里也是比较迷茫的，一部分是担心自己是否能通过一年的努力就弥补工作年限和项目经验上的差距，虽然我我对我的努力从来都不会质疑，但是一年里不仅要完成每天工作上的要求，还有抽出时间来进行新语言的学习，想想如果中途因为过大的压力导致懈怠甚至放弃，心里落差真的会很大！想到这里我决定：给自己指明一条路，让自己只朝着这一个目标前进</p>
<p>最终决定，继续实现我Java后端开发的道路！</p>
<p>mmdYueY4n9，从今天开始自己记录学习的道路，与各位共勉~</p>
<p>首先我决定复习一下数据结构和算法，虽然大学期间学习的成绩还可以，但是经过一年，总会有些遗忘。因为基础我是有的，所以每天刷题来见证自己的成长吧~</p>
<p>这段时间疯狂的看Java书，感觉自己有了高中和大学拼搏奋斗的感觉！这种感觉自从工作之后就很少有了~我会保持住这种劲头，大家一起见证我的成长吧！</p>
<p>这段时间写项目的授权模块功能研究的头都大了，最终完成总算告于一段落。在这段时间复习了数据结构和算法，大学虽然自以为学的很扎实结果现在看看还是生疏，现在基本做到每天总结之前学习内容的习惯，希望能与各位共勉吧~</p>
<p>时间：<code>2021-06-23 20:58🌛</code></p>
<h3 id="转型？难，但不完全难"><a href="#转型？难，但不完全难" class="headerlink" title="转型？难，但不完全难"></a>转型？难，但不完全难</h3><p>时间来到了2021年6月23日，我成功转型Golang开发，但是并没有如预期般的加入到米哈游的阵容中。来到了现在这家公司——幂律，感觉真的很棒。公司给我转型Go的机会，我也会尽我所能以更加优质的代码去回报公司。</p>
<h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>这周学习Golang的最大感受就是Golang试图用更紧凑更底层的操作来实现尽可能多的功能实现，这种不刻意的面向对象面向函数的思想给我眼前一亮。如果要问学Java两年给我带来了什么，我可能回答的是更加良好的学习习惯和编程习惯，Golang将给我带来更多的东西。</p>
<p>时间：<code>2021-07-22 10:34🌧</code></p>
<h3 id="我来维护？我来维护！"><a href="#我来维护？我来维护！" class="headerlink" title="我来维护？我来维护！"></a>我来维护？我来维护！</h3><p>入职到今天一个月，还是讲讲体会吧。从事一个自己喜欢的行业真的很重要，做自己喜欢的事也很重要。CRUD工作本身是无趣的，但是从CRUD的代码中去体会Golang程序代码的含义和设计思想这个过程，是我在现在工作中享受的事情。还有还有，家中的女伴略有些幼稚和顽皮，关键时刻总得有一个人来维护这段感情把。而且，自博客创建开始，每周写博文和美化博客的时间，更能让这位扭坐在计算机前的小小程序员感受到互联网时代的伟大。<br>至此：<br>    每天的博文更新，我来维护！<br>    每天的工作激情，我来维护！<br>    每天与她的感情，我来维护！<br>    这互联网时代，我与阅读文章的你，一同来维护！（破音！）</p>
]]></content>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/12/30/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>动态规划背包问题学习总结</p>
]]></content>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2021/05/31/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>  整理了2021年5月面试Java中级研发工程师过程中，遇到的知识疏漏点和模糊点，以及面试过程中的面试题的详细解析，对于一些比较基础的问题只做了简单的记录，希望能对个人提升和习惯养成有所帮助</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>  2021-07-22</p>
</blockquote>
<h3 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h3><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务</p>
<p>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</p>
<p>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>
<h3 id="Zookeeper是什么框架"><a href="#Zookeeper是什么框架" class="headerlink" title="Zookeeper是什么框架"></a>Zookeeper是什么框架</h3><p>Zookeeper是分布式系统协调服务的框架，也叫作服务注册中心</p>
<h3 id="Dubbo一般用什么注册中心？还有别的选择吗？"><a href="#Dubbo一般用什么注册中心？还有别的选择吗？" class="headerlink" title="Dubbo一般用什么注册中心？还有别的选择吗？"></a>Dubbo一般用什么注册中心？还有别的选择吗？</h3><p>Dubbo一般使用Zookeeper，也可以使用Redis，consul，数据库</p>
<h3 id="为什么说Spring是一个容器？"><a href="#为什么说Spring是一个容器？" class="headerlink" title="为什么说Spring是一个容器？"></a>为什么说Spring是一个容器？</h3><p>Spring的核心思想是更方便的管理Java Bean，有Spring创建的Bean放入一个Map中，这个Map就可以理解成装Bean的容器，也就是IOC容器。</p>
<h3 id="JVM生命周期和体系结构"><a href="#JVM生命周期和体系结构" class="headerlink" title="JVM生命周期和体系结构"></a>JVM生命周期和体系结构</h3><p>JVM声明周期是跟随程序一起的，JVM开始运行时就是程序启动时，JVM停止运行程序也随之结束。</p>
<p>JVM体系结构包含：类加载器、内存区、执行引擎、本地方法调用。</p>
<blockquote>
<p>2021-06-07</p>
</blockquote>
<h3 id="ConcurrentHashMap为什么是CAS-Synchronized？"><a href="#ConcurrentHashMap为什么是CAS-Synchronized？" class="headerlink" title="ConcurrentHashMap为什么是CAS+Synchronized？"></a>ConcurrentHashMap为什么是CAS+Synchronized？</h3><p>用CAS是为了减小锁的粒度，毕竟CAS是JUC下面使用最多的锁，用Synchronized是因为Synchronized可以不断优化，并且粒度也不高。</p>
<h3 id="MyBatis是怎么实现的？不用Spring怎么集成？"><a href="#MyBatis是怎么实现的？不用Spring怎么集成？" class="headerlink" title="MyBatis是怎么实现的？不用Spring怎么集成？"></a>MyBatis是怎么实现的？不用Spring怎么集成？</h3><h3 id="CAS会出现什么问题？怎么解决的？"><a href="#CAS会出现什么问题？怎么解决的？" class="headerlink" title="CAS会出现什么问题？怎么解决的？"></a>CAS会出现什么问题？怎么解决的？</h3><p>ABA问题</p>
<h3 id="MySQL和Redis的重要数据，必须完全一致，这个怎么实现？"><a href="#MySQL和Redis的重要数据，必须完全一致，这个怎么实现？" class="headerlink" title="MySQL和Redis的重要数据，必须完全一致，这个怎么实现？"></a>MySQL和Redis的重要数据，必须完全一致，这个怎么实现？</h3><h3 id="MySQL是可重复读是怎么实现的？"><a href="#MySQL是可重复读是怎么实现的？" class="headerlink" title="MySQL是可重复读是怎么实现的？"></a>MySQL是可重复读是怎么实现的？</h3><p>使用MVCC（多版本并发控制），每次SELECT之前会找到上一个数据版本，只读当前版本的数据。innoDB已经实现”秒级快照版本”</p>
<h3 id="springboot做了哪些事？深入到底层是怎么实现的？"><a href="#springboot做了哪些事？深入到底层是怎么实现的？" class="headerlink" title="springboot做了哪些事？深入到底层是怎么实现的？"></a>springboot做了哪些事？深入到底层是怎么实现的？</h3><h3 id="Redis的Key过期后会立即删除么？"><a href="#Redis的Key过期后会立即删除么？" class="headerlink" title="Redis的Key过期后会立即删除么？"></a>Redis的Key过期后会立即删除么？</h3><p>不会的，三种删除策略：定时删除、惰性删除（？还有什么？原理是什么）</p>
<h3 id="Redis的集群用过吗？是怎么的架构？哨兵机制呢？"><a href="#Redis的集群用过吗？是怎么的架构？哨兵机制呢？" class="headerlink" title="Redis的集群用过吗？是怎么的架构？哨兵机制呢？"></a>Redis的集群用过吗？是怎么的架构？哨兵机制呢？</h3><h3 id="分布式集群下怎么执行定时任务？"><a href="#分布式集群下怎么执行定时任务？" class="headerlink" title="分布式集群下怎么执行定时任务？"></a>分布式集群下怎么执行定时任务？</h3><h3 id="为什么分布式要用RestTemplete而不用HttpUtils？"><a href="#为什么分布式要用RestTemplete而不用HttpUtils？" class="headerlink" title="为什么分布式要用RestTemplete而不用HttpUtils？"></a>为什么分布式要用RestTemplete而不用HttpUtils？</h3><h3 id="JWT的整体流程是怎样的？"><a href="#JWT的整体流程是怎样的？" class="headerlink" title="JWT的整体流程是怎样的？"></a>JWT的整体流程是怎样的？</h3><p>MySQL锁<br>Redis集群</p>
<blockquote>
<p>2021-06-04</p>
</blockquote>
<h3 id="maven父类依赖冲突"><a href="#maven父类依赖冲突" class="headerlink" title="maven父类依赖冲突"></a>maven父类依赖冲突</h3><p>maven的依赖原则</p>
<h3 id="线城池参数、拒绝策略、流程"><a href="#线城池参数、拒绝策略、流程" class="headerlink" title="线城池参数、拒绝策略、流程"></a>线城池参数、拒绝策略、流程</h3><p>7个参数：核心线程数、总线程数、存活时间、时间单位、阻塞队列、工厂、拒绝策略</p>
<p>4个拒绝策略：拒绝并抛出异常、静默拒绝、移除队列中最前面的任务然后重新提交被拒绝的任务、由调用线程来执行该任务</p>
<p>流程：先看核心线程是否满了，满了再看阻塞队列是否满了，满了再看总线程数是否满了，满了再走拒绝策略</p>
<h3 id="ConcurrentHashMap的线程安全在JDK1-7和JDK1-8的区别"><a href="#ConcurrentHashMap的线程安全在JDK1-7和JDK1-8的区别" class="headerlink" title="ConcurrentHashMap的线程安全在JDK1.7和JDK1.8的区别"></a>ConcurrentHashMap的线程安全在JDK1.7和JDK1.8的区别</h3><p>JDK1.7：分段锁</p>
<p>JDK1.8 :  Synchronized+CAS</p>
<h3 id="SpringMVC工作流程（需要仔细研究底层执行流程）"><a href="#SpringMVC工作流程（需要仔细研究底层执行流程）" class="headerlink" title="SpringMVC工作流程（需要仔细研究底层执行流程）"></a>SpringMVC工作流程（需要仔细研究底层执行流程）</h3><ol>
<li>客户端发送请求到前端控制器DispatcherServlet</li>
<li>前端控制器DispatcherServlet根据URL来决定选择哪一个控制器Controller进行处理，并把请求委托给控制器</li>
<li>控制器Controller接收请求后，将请求参数绑定为一个对象，这个对象叫命令对象，并进行验证。然后将命令对象委托给业务对象进行处理，处理完毕后返回一个ModelAndView</li>
<li>前端控制器DispatcherServlet收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入，以便渲染</li>
<li>前端控制器DispatcherServlet再次收回控制权，将相应返回给用户</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>加载、验证、解析、准备、初始化</p>
<h3 id="了解双亲委派机制吗？"><a href="#了解双亲委派机制吗？" class="headerlink" title="了解双亲委派机制吗？"></a>了解双亲委派机制吗？</h3><p>一个类加载器加载类时，会将请求委托交给父加载器去加载，只要父加载器无法完成这个加载请求时，子加载器才会自己尝试完成加载。</p>
<p>好处：保证基础类环境的稳定运行</p>
<blockquote>
<p>2021-06-03</p>
</blockquote>
<h3 id="spring和springboot的区别"><a href="#spring和springboot的区别" class="headerlink" title="spring和springboot的区别"></a>spring和springboot的区别</h3><p>springboot就是spring的扩展，少了繁琐的配置，让开发、测试、部署方便了。</p>
<blockquote>
<p>2021-06-02</p>
</blockquote>
<h3 id="了解HashMap吗？"><a href="#了解HashMap吗？" class="headerlink" title="了解HashMap吗？"></a>了解HashMap吗？</h3><ul>
<li>HashMap的数据结构（数组+链表/红黑树）</li>
<li>哈希冲突的实现原理</li>
<li>HashMap扩容机制</li>
<li>线程不安全性</li>
<li>HashMap为什么初始容量是2的4幂（16）：按位运算</li>
</ul>
<h3 id="那想用线程安全的Map用什么呢？（踩过坑）"><a href="#那想用线程安全的Map用什么呢？（踩过坑）" class="headerlink" title="那想用线程安全的Map用什么呢？（踩过坑）"></a>那想用线程安全的Map用什么呢？（踩过坑）</h3><p>我答的ConcurrentHashMap是线程安全的，并且把线程安全的机制详细的描述了一遍；但是我记忆里大学期间学过了一段设计，就是说ConcurrentHashMap也不是完全保证线程安全的，在事务下，也会发生线程不安全。当时对ConcurrentHashMap的理解也仅限于此；但今天细究了一下，ConcurrentHashMap是可以完全保证每次操作的线程安全问题的，但是事务的安全那就得另算了，需要考虑的就是事务的隔离级别了！这点希望大家不要和我一起进入这个误区。过段时间会详细写一下事务的隔离级别的专题文章。</p>
<h3 id="了解MySQL索引吗？"><a href="#了解MySQL索引吗？" class="headerlink" title="了解MySQL索引吗？"></a>了解MySQL索引吗？</h3><ul>
<li>索引的数据结构（B+树）</li>
<li>B+树的自平衡（脑子清楚嘴笨）</li>
<li>MySQL索引能存储的数据量</li>
<li>事务的基本要素ACID</li>
<li>事务并发问题：脏读、不可重复读、幻读</li>
<li>事务的隔离级别（读未提交、不可重复读、重复读、串行化）</li>
</ul>
<h3 id="算法题：数组中求最大差值（股票的最大收益问题）"><a href="#算法题：数组中求最大差值（股票的最大收益问题）" class="headerlink" title="算法题：数组中求最大差值（股票的最大收益问题）"></a>算法题：数组中求最大差值（股票的最大收益问题）</h3><p>这题朴实无华的动态规划，2分钟解决了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        int[] nums;</span></span><br><span class="line"><span class="comment">//        nums = new int[0];</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;1&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;21, 12, 7, 3, 11, 20&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;21, 20, 19, 18, 10&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;22, 20, 20, 20, 10&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划实现, 如果按照题意求最大差值的话需要返回零和负数情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">question1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - min &gt; max) &#123;</span><br><span class="line">                max = nums[i] - min;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; min) &#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法题：计算合法（）的最大长度"><a href="#算法题：计算合法（）的最大长度" class="headerlink" title="算法题：计算合法（）的最大长度"></a>算法题：计算合法<code>（）</code>的最大长度</h3><p>？？？这连中间都不穿插点加减号了？？？</p>
<p>直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        String str;</span></span><br><span class="line"><span class="comment">////        str = &quot;()()()()&quot;;</span></span><br><span class="line"><span class="comment">////        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">////        str = &quot;((((()()&quot;;</span></span><br><span class="line"><span class="comment">////        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;()(())&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;(()))))())&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;((((&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;)))((()((((()((&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;(*(*)*)*)(())&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈使用的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">question2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == str)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == str.charAt(i)) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    start = i + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                        result = Math.max(result, i - start + <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result = Math.max(result, i - stack.peek());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法题：实现LRU算法"><a href="#算法题：实现LRU算法" class="headerlink" title="算法题：实现LRU算法"></a>算法题：实现LRU算法</h3><p>这题我是最喜欢的^_^因为我脑子会，手不会写（我就想知道谁能记住LinkedHashMap里面的API啊），所以百度帮我做了，但想法我就是这样的。</p>
<p>给大家讲一下实现吧，首先LRU就叫做Least Recently Used最少最近使用，就是把最老最久没碰过得数据给淘汰掉，刚好LinkedHashMap就已经做了按照访问顺序来实现节点排序，HashMap的put方法有一个实现，参数是accessOrder，当accessOrder=true时，访问节点和插入节点都会将当前节点放到链表最新处（如果是JDK1.6+那就是放到结尾去），那不就是LRU的想法么 ~ 那我直接用就好了（源码解析我7月份会贡献笔记）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU算法：最少最近使用：利用LinkedHashMap实现了按访问顺序存储的特性来简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> initialCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialCapacity = cacheSize;</span><br><span class="line">        <span class="keyword">int</span> capacity = (<span class="keyword">int</span>) Math.ceil(cacheSize / loadFactor) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// accessOrder=true是重点, 该参数为true是按照访问顺序插入到链表最新节点后, false是按照插入顺序存储</span></span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(capacity, loadFactor, <span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; LRUCache.<span class="keyword">this</span>.initialCapacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="设计一个门票限时销售系统"><a href="#设计一个门票限时销售系统" class="headerlink" title="设计一个门票限时销售系统"></a>设计一个门票限时销售系统</h3><p>听到这个题目我直接懵圈了，what？我设计一个系统？</p>
<p>提供系统架构图和业务流程图，what？画图？</p>
<p>这个考的不是我的专业技能，是对总体把控的能力，但我觉得我现在还不是把精力去花费在把一个个专业知识整合的时候，我更应该做的是去精通和扎实每一个我熟悉的技术（听起来像是在给自己找理由，嘻嘻），所以这题我就简单答了答，做了一个微服务，订单和商品的并发操作使用Redis的分布式锁保证安全，然后限时功能也是就用Redis的设置存活时间来实现。</p>
<blockquote>
<p>2021-06-01</p>
</blockquote>
<h3 id="算法题：求100以内质数的阶乘之和"><a href="#算法题：求100以内质数的阶乘之和" class="headerlink" title="算法题：求100以内质数的阶乘之和"></a>算法题：求100以内质数的阶乘之和</h3><p>思路是先求100以内的阶乘，放到数组中，再对数组中的质数一一求阶乘，再累加；</p>
<p>思路清晰，但编码过程中我发现了两个问题，一个就是10以上的阶乘其实是非常大的，那么他们的和很可能超过int和long的范围，所以尽可能使用其他更能长的数据结构来存储。果然，97的阶乘甚至都到达了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>那么就先用BigDecimal来试试够不够，上我的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">question2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存质数结果集</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断当前数字是否为质数</span></span><br><span class="line">        <span class="keyword">if</span> (isPrimeNumber(i)) &#123;</span><br><span class="line">            <span class="comment">// 将质数添加到结果集</span></span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印质数结果集, 为question5参考</span></span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 返回结果超出long长度, 使用BigDecimal保存最终结果和计算过程结果</span></span><br><span class="line">    BigDecimal result = <span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : list) &#123;</span><br><span class="line">        <span class="comment">// 顺序添加BigDecimal类型的阶乘结果</span></span><br><span class="line">        result = result.add(getBigDecimalFactorial(num));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;结果:&quot;</span> + result); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个2-100的数字是否是质数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrimeNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(num); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算一个1-100之间数字的阶乘</span></span><br><span class="line"><span class="comment"> * 返回结果超过long长度, 使用BigDecima保存过程结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigDecimal <span class="title">getBigDecimalFactorial</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    BigDecimal result = <span class="keyword">new</span> BigDecimal(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num; i++) &#123;</span><br><span class="line">        result = result.multiply(<span class="keyword">new</span> BigDecimal(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(num + <span class="string">&quot;的阶乘是&quot;</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运气不错，BigDecimal就存下了。但如果是BigDecimal也存储不下的话，就用String来存吧，就是要重写一个加减乘除方法来实现就比较麻烦了。</p>
<h3 id="智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多"><a href="#智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多" class="headerlink" title="智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多"></a>智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多</h3><p>这题我采用的数学的方式解决，也是需要转个弯就解决了。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 设一堆中朝上硬币是x, 另一堆则是10-x</span></span><br><span class="line"><span class="section"># 那我需要做的令 x = 10-x</span></span><br><span class="line"><span class="section"># 那么问题就来了, 错误的逻辑是让 x = 5, 思考无果后换个方向</span></span><br><span class="line"><span class="section"># 如果还有一个10-x的变量, 那么尝试着解决交换变量种类可不可以</span></span><br><span class="line"><span class="section"># 百度：如果令一堆硬币是10, 翻转这10枚硬币, 就可以了（啊啊啊, 我的思路没错, 就差一点点）</span></span><br></pre></td></tr></table></figure>

<h3 id="证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除"><a href="#证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除" class="headerlink" title="证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除"></a>证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除</h3><p>这个话不多说了，我思路都在我的回答上了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">question5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 3 中间这个数字是2, 这个数字需要大于6*********************************</span></span><br><span class="line">    <span class="comment">// 2 4 不可能2结尾, 因为所有2结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 3 5 不可能5结尾, 因为所有5结尾的大于6的数字都可以被5整除(15, 25, 35)</span></span><br><span class="line">    <span class="comment">// 4 6 不可能4结尾, 因为所有4结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 5 7 不可能5结尾, 因为所有5结尾的大于6的数字都可以被5整除(15, 25, 35)</span></span><br><span class="line">    <span class="comment">// 6 8 不可能6结尾, 因为所有6结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 7 9 中间这个数字是8, 这个数字需要大于6***************************************</span></span><br><span class="line">    <span class="comment">// 8 0 不可能8结尾, 因为所有8结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 9 1 中间这个数字是0, 这个数字需要大于6*********************************</span></span><br><span class="line">    <span class="comment">// 0 2 不可能0结尾, 因为所有0结尾的数字都可以被5整除</span></span><br><span class="line">    <span class="comment">// 根据星号“*****”行的分析可知</span></span><br><span class="line">    <span class="comment">// 根据我的上面这个分析, 只需要证明这个数字一定可以被2整除, 那么该命题就可以转换成去证明这个数字可以被3整除</span></span><br><span class="line">    <span class="comment">// 假设质数对数字为x, x-1, x+1分别是质数</span></span><br><span class="line">    <span class="comment">// 而且x-1和x+1都是大于6的质数, 那么x-1不可能被三整除, 要么余1, 要么余2, 同理可知x+2, 要么余1, 要么余2</span></span><br><span class="line">    <span class="comment">// 并且关键是x-1与x+1之间只差了2, 所以这两个质数的余数一定是一个余1, 一个余2</span></span><br><span class="line">    <span class="comment">// 那么假设x不可能被3整除, 那么一定余1或者余2, 无论如何都是x+1和x-1余1余2的条件矛盾</span></span><br><span class="line">    <span class="comment">// 所以x一定可以被3整除</span></span><br><span class="line">    <span class="comment">// 最后得到结论, 质数对之前的数字一定可以被6整除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>百度的答案稍微复杂点，我是拆解了6，感觉更容易理解一些。</p>
<blockquote>
<p>2021-05-31</p>
</blockquote>
<h3 id="我在项目中遇到的难点"><a href="#我在项目中遇到的难点" class="headerlink" title="我在项目中遇到的难点"></a>我在项目中遇到的难点</h3><ul>
<li>地图切片的分组缓存</li>
<li>负责集成LiquiBase</li>
</ul>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/README.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>留下你的脚印👣</title>
    <url>/guestbook/index.html</url>
    <content><![CDATA[<p>试一试在这里写内容又会发生什么</p>
]]></content>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/notes/JVM.html</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><ol>
<li>引用计数器</li>
<li>根可达性分析算法</li>
</ol>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><ol>
<li><p>复制算法</p>
</li>
<li><p>标记清除法</p>
</li>
<li><p>标记整理法</p>
</li>
<li><p>分代收集算法</p>
<p>现在</p>
</li>
<li><p>//</p>
</li>
</ol>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ol>
<li>强引用：只要强引用存在，GC永远不会回收被强引用引用的对象。Object obj = new Object();</li>
<li>弱引用：GC工作时，都会回收只被弱引用引用的对象。</li>
<li>软引用：有用，但不完全有用的对象，在系统内存不足时，GC才会回收。</li>
<li>虚引用：最弱的一种引用关系。</li>
</ol>
<blockquote>
<p>GC的可达性分析算法就是看的是强引用</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/notes/MySQL.html</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/notes/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/notes/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
  </entry>
  <entry>
    <title>notes</title>
    <url>/notes/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/notes/Go%E5%BC%80%E5%8F%91%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html</url>
    <content><![CDATA[<p>包中引用多个其他功能同级目录的包导致的重命名规则</p>
<blockquote>
<p>  功能模块名简写+当前目录层级名简写，全部字母小写；</p>
<p>  当不同功能模块简写重复时，后添加的功能模块包使用易懂的简写代替；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    uc <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/utils/consts/user&quot;</span> <span class="comment">// uc表示userconsts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包中引用系统级别包和自定义包导致的重命名规则</p>
<blockquote>
<p>  系统级别包使用前缀<code>sys</code>+包名或缩写</p>
<p>  Golang扩展包使用<code>go</code>或扩展包前缀+包名或缩写</p>
<p>  用户自定义包使用原名或缩写，全部字母小写；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    sysctx 	<span class="string">&quot;context&quot;</span></span><br><span class="line">    </span><br><span class="line">   	gouuid <span class="string">&quot;github.com/satori/go.uuid&quot;</span></span><br><span class="line">    gomail <span class="string">&quot;gopkg.in/mail.v2&quot;</span></span><br><span class="line">    </span><br><span class="line">    context <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/domain/contract/entity&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包中引用工具包，可以直接重定义命名</p>
<blockquote>
<p>  引用工具包时，即使没有重名包的情况下，对工具包直接重命名，全部字母小写；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    httputils <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/utils/http&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  结构体中引用到多个其他其他功能同级目录的类型时，参数名使用功能模块名+目录层级名，小驼峰命名（包名中包含多词时以功能为最小单位）</p>
<p>  引用到系统级别包或自定义系统级功能包时，</p>
<p>  当<code>单词长度≤8</code>时，参数名可以使用单词全拼；</p>
<p>  当<code>单词长度＞8</code>时，参数名使用短命名形式；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctx 				*context.AppContext	<span class="comment">// AppContext就简写成ctx</span></span><br><span class="line">    workflowDomain 		workflow.Domain		<span class="comment">// workflow长度适宜，使用全拼，且不允许写成workFlow</span></span><br><span class="line">    bcDomain 			bcd.Domain 			<span class="comment">// businesscategory过长，就简写成了bc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/notes/%E5%B9%82%E5%BE%8B%E6%97%A5%E6%8A%A5.html</url>
    <content><![CDATA[<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><h4 id="202106"><a href="#202106" class="headerlink" title="202106"></a>202106</h4><h5 id="20210621"><a href="#20210621" class="headerlink" title="20210621"></a>20210621</h5><blockquote>
<p>  入职幂律智能<del>开心的Golang开发启程</del></p>
</blockquote>
<h5 id="20210628"><a href="#20210628" class="headerlink" title="20210628"></a>20210628</h5><p>api/http/v1： <code>handler.go</code>定义uri与代码的映射、入参校验，调用<code>Service层</code>的逻辑写在这里面；<code>validation.go</code>定义入参校验的结构体</p>
<p>context：<code>config.go</code>、<code>context,go</code>配置文件</p>
<p>domain：<code>domain.go</code>实现<code>interface.go</code>，</p>
<p>microservice：未知</p>
<p>model：未知</p>
<p>router：路由层，程序启动时初始化用到的<code>路由层</code></p>
<p>service：<code>service.go</code>实现<code>interface.go</code>，service.go里写逻辑调用的其他模块的一个service结构体，实现调用<code>数据层</code>的所有逻辑，数据层包含<code>domain</code>和<code>entity</code>两部分，分别代表DAO层和Entity层，把domain下来操作数据库，得到entity，entity来获取数据库实例中具体信息</p>
<blockquote>
<p>  总结：handle层→service层→domain层</p>
</blockquote>
<h5 id="20210629"><a href="#20210629" class="headerlink" title="20210629"></a>20210629</h5><p>包中引用多个其他功能同级目录的包导致的重命名规则</p>
<blockquote>
<p>  功能模块名简写+当前目录层级名简写，全部字母小写；</p>
<p>  当不同功能模块简写重复时，后添加的功能模块包使用易懂的简写代替；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    uc <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/utils/consts/user&quot;</span> <span class="comment">// uc表示userconsts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包中引用系统级别包和自定义包导致的重命名规则</p>
<blockquote>
<p>  系统级别包使用前缀<code>sys</code>+包名或缩写</p>
<p>  Golang扩展包使用<code>go</code>或扩展包前缀+包名或缩写</p>
<p>  用户自定义包使用原名或缩写，全部字母小写；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    sysctx 	<span class="string">&quot;context&quot;</span></span><br><span class="line">    </span><br><span class="line">   	gouuid <span class="string">&quot;github.com/satori/go.uuid&quot;</span></span><br><span class="line">    gomail <span class="string">&quot;gopkg.in/mail.v2&quot;</span></span><br><span class="line">    </span><br><span class="line">    context <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/domain/contract/entity&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包中引用工具包，可以直接重定义命名</p>
<blockquote>
<p>  引用工具包时，即使没有重名包的情况下，对工具包直接重命名，全部字母小写；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    httputils <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/utils/http&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  结构体中引用到多个其他其他功能同级目录的类型时，参数名使用功能模块名+目录层级名，小驼峰命名（包名中包含多词时以功能为最小单位）</p>
<p>  引用到系统级别包或自定义系统级功能包时，</p>
<p>  当<code>单词长度≤8</code>时，参数名可以使用单词全拼；</p>
<p>  当<code>单词长度＞8</code>时，参数名使用短命名形式；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctx 				*context.AppContext	<span class="comment">// AppContext就简写成ctx</span></span><br><span class="line">    workflowDomain 		workflow.Domain		<span class="comment">// workflow长度适宜，使用全拼，且不允许写成workFlow</span></span><br><span class="line">    bcDomain 			bcd.Domain 			<span class="comment">// businesscategory过长，就简写成了bc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>git rebase相关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b [本地开发分支名] origin/[远程分支名] // 本地创建分支关联远端分支</span><br><span class="line">// 修改代码</span><br><span class="line">git add -A // 添加所有[新增][修改][删除]内容</span><br><span class="line">git commit -m &quot;注释内容&quot; // 预提交，进行lint检测</span><br><span class="line">git commit -m &quot;注释内容&quot; -n // 提交代码，保存本地分支</span><br><span class="line">git checkout [主分支] // 切换主分支</span><br><span class="line">git pull // 拉去主分支代码，此时本地主分支代码为最新代码，本地开发分支有所有修改的代码</span><br><span class="line">git checkout [本地开发分支] // 切回本地开发分支，准备rebase</span><br><span class="line">git rebase [主分支] -i HEAD~2 // 将当前分支合并提交到目标分支</span><br><span class="line">// rebase过程可能会出现冲突，解决冲突后继续rebase过程</span><br><span class="line">git rebase [主分支] --continue // 继续rebase过程</span><br><span class="line">git push // 推送远端</span><br></pre></td></tr></table></figure>

<h5 id="20200630"><a href="#20200630" class="headerlink" title="20200630"></a>20200630</h5><p>git rebase相关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 一次提交，可以直接rebase后解决冲突</span><br><span class="line">git rebase [目标分支]</span><br><span class="line">// 如果多次提交，建议使用rebase -i</span><br><span class="line">git rebase -i [目标分支] // 这样写就是把之前所有commit的都合并成一个，即使之前在该分支合并过的commit也会合并，这就导致了之前的冲突可能重新解决一次，这种问题的解决办法是一个功能做完就提交合并，下一个功能另开新的分支</span><br></pre></td></tr></table></figure>

<h4 id="202107"><a href="#202107" class="headerlink" title="202107"></a>202107</h4><h5 id="20210701"><a href="#20210701" class="headerlink" title="20210701"></a>20210701</h5><p>分析Golang中使用匿名成员和Java中继承的差异</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上层结构体</span></span><br><span class="line"><span class="keyword">type</span> BaseUser <span class="keyword">struct</span>&#123;</span><br><span class="line">    ID <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *BaseUser)</span> <span class="title">GetID</span><span class="params">()</span> <span class="title">int64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.ID</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属于BaseUser结构体的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *BaseUser)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BaseUser&#x27;ID is&quot;</span> + ID</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ====================================== </span></span><br><span class="line"><span class="comment">// 包含了BaseUser结构体的新结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    BaseUser <span class="comment">// 匿名结构体</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属于User结构体的ToString方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User&#x27;ID is&quot;</span> + ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  分析上面代码，BaseUser中实现了ToString方法，User中使用了BaseUser的匿名结构体，Golang中没有继承的概念，这种”组合”的结构理解成将匿名结构体中的成员变量和成员方法传递到子类中，子类再重写就只能是属于子类的成员方法，可以调用父类的成员方法，但不能覆盖父类成员方法；</p>
</blockquote>
<h5 id="20210705"><a href="#20210705" class="headerlink" title="20210705"></a>20210705</h5><blockquote>
<p>  entity层不要依赖entity层的结构体，防止循环依赖，可以依赖于common的entity层</p>
</blockquote>
<blockquote>
<p>  构建结构体对象直接使用{}初始化，不用使用new()</p>
</blockquote>
<blockquote>
<p>  更新接口要执行事务，对数据加锁</p>
</blockquote>
<blockquote>
<p>  <code>解决完一个小问题也需要回头检查和验证是否正确</code></p>
</blockquote>
<h5 id="20210706"><a href="#20210706" class="headerlink" title="20210706"></a>20210706</h5><blockquote>
<p>  考虑一块代码需要放到合适的位置，还挺重要的，可以避免不必要的代码重复执行</p>
</blockquote>
<blockquote>
<p>避免变量名歧义</p>
</blockquote>
<blockquote>
<p>  <code>做完一定要测一测，千万别嫌麻烦！！！</code></p>
</blockquote>
<h5 id="20210707"><a href="#20210707" class="headerlink" title="20210707"></a>20210707</h5><blockquote>
<p>  定义结构体接收请求参数的时候，注意：</p>
<p>  uri是对应地址中的两个/中间夹着的那个，对应校验ShouldBindUri</p>
<p>  form是?后面开始的那些，对应校验ShouldBindQuery</p>
<p>  json是body里面的，对应校验ShouldBindJSON</p>
</blockquote>
<blockquote>
<p>  MVP：最简化可行性版本</p>
</blockquote>
<ul>
<li>  [ ] 写Golang原生的http接口请求和响应，以此来理解Go处理请求的底层实现</li>
</ul>
<h5 id="20210708"><a href="#20210708" class="headerlink" title="20210708"></a>20210708</h5><blockquote>
<p>  Synth账号/密码：<code>synth/synth@powerlaw4506</code></p>
</blockquote>
<blockquote>
<p>  一般启动项要置于日志管理工具之后，否则会有日志无法捕捉异常这种问题</p>
</blockquote>
<p>完成启动项启动时的panic异常在阿里云日志的捕获</p>
<h5 id="20210709"><a href="#20210709" class="headerlink" title="20210709"></a>20210709</h5><blockquote>
<p>  解决一个bug，生成两个bug？？？认真开发</p>
</blockquote>
<h5 id="20210712"><a href="#20210712" class="headerlink" title="20210712"></a>20210712</h5><ul>
<li>  [x] 修复编辑合同模板时更新人字段未返回的bug</li>
<li>  [x] 修复添加成员不输入手机号报参数不合法bug</li>
</ul>
<h5 id="20210713"><a href="#20210713" class="headerlink" title="20210713"></a>20210713</h5><blockquote>
<p>  做需求之前了解需求文档</p>
</blockquote>
<h5 id="20210714"><a href="#20210714" class="headerlink" title="20210714"></a>20210714</h5><ul>
<li><p>  [x] 获取审批通知列表接口</p>
</li>
<li><p>  [x] 通知已读接口</p>
</li>
<li><p>  [x] 通知全部已读接口</p>
</li>
<li><p>  [x] 获取通知数量接口</p>
</li>
</ul>
<h5 id="20210715"><a href="#20210715" class="headerlink" title="20210715"></a>20210715</h5><blockquote>
<p>  事务执行更新语句一定要对查询的数据结果进行判断是否存在，否则获取锁会卡住然后直到获取锁超时！！！</p>
</blockquote>
<ul>
<li>  [x] 审批详情接口</li>
<li>  [x] 获取审批进程接口</li>
</ul>
<blockquote>
<p>  喝了一罐魔爪一晚上没睡着，真就离谱！</p>
</blockquote>
<h5 id="20210716"><a href="#20210716" class="headerlink" title="20210716"></a>20210716</h5><blockquote>
<p>  rebase之后代码会自动合并，这时出现的冲突并不会被检测，所以rebase之后需要再次make proj来检测代码。</p>
<p>  可以总结为，任意一次push之前，进行make proj。（commit之前的make proj是为了不反复的reset自己commit的代码）</p>
</blockquote>
<p><del>中耳炎的折磨</del></p>
<h5 id="20210719"><a href="#20210719" class="headerlink" title="20210719"></a>20210719</h5><ul>
<li>  [x] 审批进程加签接口</li>
</ul>
<h5 id="20210720"><a href="#20210720" class="headerlink" title="20210720"></a>20210720</h5><blockquote>
<p>  写代码的过程中一定要把自己需要之后修改的地方记在小本本上，否则之后又要重新找位置，很蓝的啦！</p>
</blockquote>
<blockquote>
<p>  返回标准库的error必须加入到栈中，否则不会返回err栈！</p>
</blockquote>
<p>完善了之前写的接口问题和bug</p>
<h5 id="20210721"><a href="#20210721" class="headerlink" title="20210721"></a>20210721</h5><p>解决了一天的接口bug，现在明确了一点，就是接口写完一定要好好复盘，因为真的会有很多在写代码中和写代码之前考虑不到的问题，</p>
<blockquote>
<p>  写完代码要<code>好好复盘</code>，从中吸取经验和教训</p>
</blockquote>
<blockquote>
<p>  写代码之前花最少的时间来简单了解需求，更多的时间放在写代码过程中思考和写完代码之后的复盘时间，这样可能是对现在的水平效率最高的方式</p>
</blockquote>
<ul>
<li>  [ ] 解决model和domain区别这个问题</li>
<li>  [ ] 解决rebase -i HEAD~2的合并问题</li>
</ul>
<h5 id="20210722"><a href="#20210722" class="headerlink" title="20210722"></a>20210722</h5><blockquote>
<p>  项目Git push 之前一定要执行make proj，这会决定别人拉去后的代码是否是有问题的。</p>
</blockquote>
<blockquote>
<p>  对直接查询出来的数据也需要判断nil，经典空指针错误不可以再次出现！</p>
</blockquote>
<blockquote>
<p>  请假记得和技术负责人都打声招呼啥的</p>
</blockquote>
<p><code>周四周会</code>：</p>
<p><a href="https://confluence.milvzn.com/pages/viewpage.action?pageId=23236421">设计文档最佳实践</a></p>
<p><a href="https://confluence.milvzn.com/pages/viewpage.action?pageId=23236334">k8s本地开发指南</a></p>
<p>写好代码并不是需要程序包用的多好，更多是想法是否能到那个点，设计文档就可以提升这种水平。（但我觉得这种能力对于水平相对较低的开发来说极难提升，所以暂时更应该花时间来提升自己的开发水平）<code>^_^</code></p>
<p>要改进的地方：<br>    把需求文档嵌在设计文档中，就挺好找的<br>    把每周的会议纪要记下，每周轮着做<code>Q^Q</code><br>    请假和技术负责人打招呼，考虑的因素有排期和人员安排</p>
<h5 id="20210723"><a href="#20210723" class="headerlink" title="20210723"></a>20210723</h5><p>快活周五！<code>^_^</code></p>
<h5 id="20210726"><a href="#20210726" class="headerlink" title="20210726"></a>20210726</h5><blockquote>
<p>  err判断nil和对象的判断nil必须好好对照！否则会做一部分无用功！<code>QAQ</code></p>
</blockquote>
<h5 id="20210728"><a href="#20210728" class="headerlink" title="20210728"></a>20210728</h5><blockquote>
<p>  如果能判断切片长度，需要写定长度避免扩容带来的性能损耗</p>
</blockquote>
<h4 id="202108"><a href="#202108" class="headerlink" title="202108"></a>202108</h4><h5 id="20210802"><a href="#20210802" class="headerlink" title="20210802"></a>20210802</h5><blockquote>
<p>  控制饮食，控制体重，增强锻炼，自律自强！</p>
</blockquote>
<p>努力改变自己目前的编程思想，成为一名拥有较强独立思考能力的架构者。</p>
<h5 id="20210803"><a href="#20210803" class="headerlink" title="20210803"></a>20210803</h5><p>File表中is_temp字段的修改情景：</p>
<ol>
<li> 审批同意接口、审批拒绝接口，都会重新上传新文件</li>
<li> 模板创建接口，会上传文件</li>
<li> 模板修改接口，会取消文件关联，再重新上传文件</li>
<li> 模板删除接口，会取消文件关联</li>
<li> 合同审批直接发起接口，会上传文件</li>
<li> 合同审批暂存接口，会上传文件</li>
</ol>
<h5 id="20210804"><a href="#20210804" class="headerlink" title="20210804"></a>20210804</h5><ul>
<li>  [ ] 了解下mongo事务的级别；问题来自于：先开启mongo的事务，插入数据后不能对不存在的集合插入数据</li>
</ul>
<h5 id="20210811"><a href="#20210811" class="headerlink" title="20210811"></a>20210811</h5><blockquote>
<p>  mongoDB通过<code>_id</code>查询时，需要将<code>string类型的_id</code>转换成<code>ObjectID类型的_id</code>，才能实现mongoDB的查询。个人认为这个地方可以进行封装优化</p>
</blockquote>
<h4 id="202109"><a href="#202109" class="headerlink" title="202109"></a>202109</h4><h5 id="20210908"><a href="#20210908" class="headerlink" title="20210908"></a>20210908</h5><p>时隔一个月，重新写起日报。</p>
<blockquote>
<p>  设计并开发一项功能的流程：需求分析与设计—设计文档评审(不要在评审阶段去讨论设计方案，这个过程一定要自己思考得出结论)—根据开发</p>
</blockquote>
<h5 id="20210909"><a href="#20210909" class="headerlink" title="20210909"></a>20210909</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 审批通过</span></span><br><span class="line"><span class="comment">// 1.approval_node_user</span></span><br><span class="line"><span class="comment">// 2.file</span></span><br><span class="line"><span class="comment">// 3.contractcopy_powerlaw</span></span><br><span class="line"><span class="comment">// 4.approval_flow</span></span><br><span class="line"><span class="comment">// 5.approval_node</span></span><br><span class="line"><span class="comment">// 6.notice</span></span><br><span class="line"><span class="comment">// 7.contract_powerlaw</span></span><br><span class="line"><span class="comment">// 8.contract_file</span></span><br><span class="line"><span class="comment">// 9.record</span></span><br><span class="line"><span class="comment">// 10.record_detail</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从外部发起审批</span></span><br><span class="line"><span class="comment">// 1.contract_powerlaw</span></span><br><span class="line"><span class="comment">// 2.contract_user</span></span><br><span class="line"><span class="comment">// 3.contract_department</span></span><br><span class="line"><span class="comment">// 4.contractcopy_powerlaw</span></span><br><span class="line"><span class="comment">// 5.approval_flow</span></span><br><span class="line"><span class="comment">// 6.approval_node</span></span><br><span class="line"><span class="comment">// 7.approval_node_user</span></span><br><span class="line"><span class="comment">// 8.notice</span></span><br><span class="line"><span class="comment">// 9.workflow_user</span></span><br><span class="line"><span class="comment">// 10.approval_comparison</span></span><br><span class="line"><span class="comment">// 11.contract_user</span></span><br><span class="line"><span class="comment">// 12.contract_department</span></span><br><span class="line"><span class="comment">// 13.contract_group</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 审批通过</span><br><span class="line">// 1.approval_node_user // 锁全表</span><br><span class="line">// 2.approval_node // 锁一行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 异步</span><br><span class="line">// 6.approval_node // 锁全表</span><br><span class="line">// 7.approval_node_user // 插入</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 审批拒绝</span><br><span class="line">// 1.approval_node // 获取锁</span><br></pre></td></tr></table></figure>

<h4 id="202111"><a href="#202111" class="headerlink" title="202111"></a>202111</h4><h5 id="20211008"><a href="#20211008" class="headerlink" title="20211008"></a>20211008</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- mongoDB 全部删除</span><br><span class="line"></span><br><span class="line">-- mysql</span><br><span class="line">truncate table approval_comparison;</span><br><span class="line">truncate table approval_flow;</span><br><span class="line">truncate table approval_node;</span><br><span class="line">truncate table approval_node_user;</span><br><span class="line">truncate table approval_timer;</span><br><span class="line">truncate table contract_compare_file;</span><br><span class="line">truncate table contract_department;</span><br><span class="line">truncate table contract_file;</span><br><span class="line">truncate table contract_group;</span><br><span class="line">truncate table contract_user;</span><br><span class="line">truncate table notice;</span><br><span class="line">truncate table record;</span><br><span class="line">truncate table record_detail;</span><br></pre></td></tr></table></figure>

<h5 id="20211022"><a href="#20211022" class="headerlink" title="20211022"></a>20211022</h5><p><em>SOP</em>，是 Standard Operating Procedure</p>
<h5 id="20211109"><a href="#20211109" class="headerlink" title="20211109"></a>20211109</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Reject() </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Review</span><span class="params">()</span>;</span> </span><br></pre></td></tr></table></figure>

<h3 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h3><h4 id="202201"><a href="#202201" class="headerlink" title="202201"></a>202201</h4><h5 id="20220104"><a href="#20220104" class="headerlink" title="20220104"></a>20220104</h5><p>年度工作总结</p>
<h5 id="20220113"><a href="#20220113" class="headerlink" title="20220113"></a>20220113</h5><p>解决三一临时提出的一些遗留问题和开发中的BUG </p>
<h5 id="20220117"><a href="#20220117" class="headerlink" title="20220117"></a>20220117</h5><p>解决三一审查结果不出现的问题（临时）。<strong>这种现象亟待解决</strong></p>
<blockquote>
<p>  <strong>工作内容</strong></p>
<ol>
<li> 维护三一项目。</li>
<li> 提供MeFlow作为GRPC服务。</li>
<li> 租户管理系统Case评审。</li>
</ol>
</blockquote>
<h5 id="20220118"><a href="#20220118" class="headerlink" title="20220118"></a>20220118</h5><blockquote>
<p>  <strong>工作内容</strong></p>
<ol>
<li> 搭建GRPC服务</li>
<li> 排查接口问题</li>
<li> 提交测试环境</li>
</ol>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>	_ <span class="string">&quot;github.com/golang-migrate/migrate/v4/source/file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    dbMigrate := migrate.NewMyMigrateIns(db) <span class="comment">// 依赖于import中的init函数</span></span><br><span class="line">	dbMigrate.Migrate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20220119"><a href="#20220119" class="headerlink" title="20220119"></a>20220119</h5><blockquote>
<p>  <strong>工作内容</strong></p>
<ol>
<li> 修改BUG</li>
<li> 测试接口问题</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- %Y 四位年份</span><br><span class="line">-- %m 两位月份(00-12)</span><br><span class="line">-- %d 两位日期(00-31)</span><br><span class="line">select date_format( &#x27;2022-01-01&#x27;, &#x27;%Y-%m-%d&#x27; ) from dual;</span><br></pre></td></tr></table></figure>

<h5 id="20220120"><a href="#20220120" class="headerlink" title="20220120"></a>20220120</h5><blockquote>
<p>  <strong>工作内容</strong></p>
<ol>
<li> MeFlow v2.0.0 版本需求分析</li>
<li> MeFlow v1.4.0 修改BUG</li>
</ol>
</blockquote>
<h5 id="20220121"><a href="#20220121" class="headerlink" title="20220121"></a>20220121</h5><p><em>年会！五矿君澜酒店！阳光普照奖！服务先锋！大吉他！</em></p>
<h5 id="20220124"><a href="#20220124" class="headerlink" title="20220124"></a>20220124</h5>]]></content>
  </entry>
  <entry>
    <title>面试整理</title>
    <url>/notes/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h3 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h3><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务</p>
<p>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</p>
<p>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>
<h3 id="Zookeeper是什么框架"><a href="#Zookeeper是什么框架" class="headerlink" title="Zookeeper是什么框架"></a>Zookeeper是什么框架</h3><p>Zookeeper是分布式系统协调服务的框架，也叫作服务注册中心</p>
<h3 id="Dubbo一般用什么注册中心？还有别的选择吗？"><a href="#Dubbo一般用什么注册中心？还有别的选择吗？" class="headerlink" title="Dubbo一般用什么注册中心？还有别的选择吗？"></a>Dubbo一般用什么注册中心？还有别的选择吗？</h3><p>Dubbo一般使用Zookeeper，也可以使用Redis，consul，数据库</p>
<h3 id="为什么说Spring是一个容器？"><a href="#为什么说Spring是一个容器？" class="headerlink" title="为什么说Spring是一个容器？"></a>为什么说Spring是一个容器？</h3><p>Spring的核心思想是更方便的管理Java Bean，有Spring创建的Bean放入一个Map中，这个Map就可以理解成装Bean的容器，也就是IOC容器。</p>
<h3 id="JVM生命周期和体系结构"><a href="#JVM生命周期和体系结构" class="headerlink" title="JVM生命周期和体系结构"></a>JVM生命周期和体系结构</h3><p>JVM声明周期是跟随程序一起的，JVM开始运行时就是程序启动时，JVM停止运行程序也随之结束。</p>
<p>JVM体系结构包含：类加载器、内存区、执行引擎、本地方法调用。</p>
]]></content>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/notes/Dubbo.html</url>
    <content><![CDATA[<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h3 id="Dubbo是什么？"><a href="#Dubbo是什么？" class="headerlink" title="Dubbo是什么？"></a>Dubbo是什么？</h3><ul>
<li>一款分布式服务框架</li>
<li>高性能透明化RPC方案</li>
<li>SOA服务治理方案</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><p>基本信息：岳杨/1996/男</p>
<p>联系方式：17806283435（微信钉钉同号）<a href="mailto:&#x59;&#117;&#101;&#x59;&#52;&#110;&#57;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#x59;&#117;&#101;&#x59;&#52;&#110;&#57;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a></p>
<p>学历：统招本科（山东科技大学）</p>
<p>工作年限：2年（19年毕业）</p>
<p>期望岗位：Java研发工程师</p>
<p>电子简历：<a href="http://8.141.63.144:8080/">YueYang_简历</a></p>
<p>个人博客：<a href="http://8.141.63.144:8081/">YueYang_博客</a></p>
<h1 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h1><ul>
<li>Java：<code>SpringBoot</code>，<code>SpringCloud</code>，<code>MyBatis</code>，</li>
<li>DB：<code>MySQL</code>，<code>Redis</code>，<code>MongoDB</code>，<code>达梦</code></li>
<li>安全架构：<code>Shiro</code>，<code>JWT</code></li>
<li>其他组件：<code>Dubbo+ZooKeeper</code>，<code>RabbitMQ</code></li>
</ul>
<h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="北京泛钛客科技有限公司"><a href="#北京泛钛客科技有限公司" class="headerlink" title="北京泛钛客科技有限公司"></a>北京泛钛客科技有限公司</h2><p><strong>任职时间</strong>：2021.03.18至今</p>
<p><strong>任职岗位</strong>：Java中级研发工程师</p>
<h3 id="互联网金融贷款产品"><a href="#互联网金融贷款产品" class="headerlink" title="互联网金融贷款产品"></a>互联网金融贷款产品</h3><p><strong>项目描述</strong>：该项目是百度和中信银行合资开发的面向购车群体的金融贷款APP，多层网关与安全框架保证交易过程的信息安全，类似于微服务基于业务拆分成多个服务进行分布式部署。业务流程中对数据的分析，并结合对实时数据得出欺诈风险等级，实现对整体经销商和用户的安全保障。</p>
<p><strong>技术架构</strong>：<code>SpringMVC</code>，<code>MySQL</code>，<code>Redis</code>，<code>MyBatis</code>，<code>Shiro</code>，<code>Dubbo+ZooKeeper</code>，<code>RabbitMQ</code></p>
<p><strong>主要职责</strong>：</p>
<ol>
<li>主导后端开发，业务实现流程，推动项目代码规范化。</li>
<li>多维度分析业务数据风险等级，提供数据风险预警和安全数据推送服务。</li>
<li>对系统的高危漏洞群，提供了有效解决方案；对Dubbo2.5.3版本到Dubbo2.7.3进行预研升级策略，并解决版本升级过程中的问题，给整个升级流程提供了完整的升级策略。</li>
<li>优化原有代码逻辑，使用逻辑代码方式避免了大量的数据库交互，减轻数据库压力；推动了组内对SQL以及表的注释规范。</li>
</ol>
<h2 id="北京中油龙慧科技信息分公司"><a href="#北京中油龙慧科技信息分公司" class="headerlink" title="北京中油龙慧科技信息分公司"></a>北京中油龙慧科技信息分公司</h2><p><strong>任职时间</strong>：2019.02.01至2021.03.17</p>
<p><strong>任职岗位</strong>：Java初级研发工程师</p>
<h3 id="二三维地理信息可视化平台"><a href="#二三维地理信息可视化平台" class="headerlink" title="二三维地理信息可视化平台"></a>二三维地理信息可视化平台</h3><p><strong>项目描述</strong>：针对石油管道业务开发的二三维视用一体话平台，高效、敏捷、简洁的展示管道运输整体状态以及其相关附属业务数据，将数据可视化以三维模型、动态感知警报、监控捕捉等技术呈现给用户。后台端的功能服务管理模块，支持自定义组件、功能模块拖拽、简单SQL拼接查询等功能实现后台管理人员的易用性。适用性方面支持多种数据库通用化处理，无论是国产化需求还是高性能高可用都给予所有功能的完整实现。</p>
<p><strong>技术架构</strong>：<code>SpringBoot</code>，<code>MySQL</code>，<code>Oracle</code>，<code>达梦</code>，<code>Postgresql</code>，<code>Redis</code>，<code>JWT</code>，<code>LiquiBase</code></p>
<p><strong>主要职责</strong>：</p>
<ol>
<li>负责所有业务数据与空间数据之间相关的数据整合工作，将关系型数据库中经纬度、航飞属性等数据字段高度封装，实现MongoDB的直接接入。</li>
<li>集成LiquiBase作为数据库版本管理工具，阅读并修改源码包，原来不适配的达梦数据库最终也完成了整合，从而实现多种数据库通用化处理。</li>
<li>推动组内对log4j日志的标准化输出，并搭建Jenkins实现项目自动化部署。</li>
<li>组内缺乏专业的GIS后端工程师的情况下，主动学习GIS相关技术和三维场景切片缓存技术，通过缓存网格片以及细化网格片达到综合条件下网格数据查询效率极大提高，我提出的这项改进很大影响了GIS项目前后端的开发思路。</li>
</ol>
<h3 id="智慧城市一体化平台"><a href="#智慧城市一体化平台" class="headerlink" title="智慧城市一体化平台"></a>智慧城市一体化平台</h3><p><strong>项目描述</strong>：面向服务的全生命周期管理平台，面向服务管理模式将管道城市的数据一体化展示，通过按钮、拖拽、绘制流程图、勾选填选等用户行为，解决了大部分规则的管理和配置，包含用户的角色、部门、权限以及复杂的流程管理。平台扩展功能也具有实际社会意义，疫情期间制作了疫情填报功能，保障了巡检人员的安全。</p>
<p><strong>技术架构</strong>：<code>SpringMVC</code>，<code>Oracle</code>，<code>Redis</code></p>
<p><strong>主要职责</strong>：</p>
<ol>
<li>主导Web端的后端开发，优化多处代码逻辑，并优化了原来执行时间长的SQL，大幅提高了系统响应性能。</li>
<li>负责巡检人员的调休换班模块，知识库管理模块，以及系统跳转的单点登录功能，并与之前系统进行跳转整合，最终达到单点登陆系统跳转的一致性。</li>
<li>推动部门接口管理规范，继承Swagger来对后端接口统一管理和测试，大大提升后端和前端的沟通效率，长久性降低了接口维护成本。</li>
</ol>
<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1><ul>
<li>熟悉Java基础知识，熟悉SpringBoot、MyBatis、Dubbo等Java开发中常用框架</li>
<li>熟悉SQL语法，有一定SQL优化经验</li>
<li>熟练使用各种IDE（IDEA、Eclipse）、版本管理工具（Git、SVN）、Jenkins等开发工具。</li>
<li>掌握Linux常用命令，能完成日常的项目部署、维护工作</li>
<li>执着于技术，日常就是维护博客、学习源码、学习技术</li>
<li>做事认真，喜欢钻研，保持细心，热爱学习，性格要强，脾气良好，乐观幽默，小开心果</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>试一试在这里写内容会发生什么</p>
]]></content>
  </entry>
</search>
