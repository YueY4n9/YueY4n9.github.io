<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dangling meta character ‘+‘ near index 1异常</title>
    <url>/2020/12/15/Dangling-meta-character-%E2%80%98-%E2%80%98-near-index-1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>  Java引用MongoTemplate操作时，报错Dangling meta character ‘+’ near index 1异常的原因和解决方法</p>
</blockquote>
<span id="more"></span>

<p>MongoTemple操作报错Dangling meta character ‘+’ near index 1异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Query</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">searchValue</span> <span class="operator">=</span> <span class="string">&quot;XQ03B13-FZL023+1+008-LW-LH-01B&quot;</span>;</span><br><span class="line"><span class="type">Criteria</span> <span class="variable">criteriaName</span> <span class="operator">=</span> Criteria.where(<span class="string">&quot;name&quot;</span>).regex(searchValue);</span><br></pre></td></tr></table></figure>

<p>代码这样写，regex的时候会报Dangling meta character ‘+’ near index 1，简单查了一下，发现当searchValue中包含 + 等特殊字符，需要转义一下。<br>转义可以转义成 [+] 或者 +<br>得到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Query</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">searchValue</span> <span class="operator">=</span> <span class="string">&quot;XQ03B13-FZL023+1+008-LW-LH-01B&quot;</span>;</span><br><span class="line">searchValue = searchValue.replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;[+]&quot;</span>);</span><br><span class="line"><span class="type">Criteria</span> <span class="variable">criteriaName</span> <span class="operator">=</span> Criteria.where(<span class="string">&quot;name&quot;</span>).regex(searchValue);</span><br></pre></td></tr></table></figure>

<p>雷霆嘎巴，查询成功，真不戳！</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpServletRequest request 简单使用方法</title>
    <url>/2020/08/18/HttpServletRequest/</url>
    <content><![CDATA[<blockquote>
<p>Java底层调用Servlet中HttpServletRequest的原理和常用函数</p>
</blockquote>
<span id="more"></span>

<h3 id="HttpServletRequest-详解"><a href="#HttpServletRequest-详解" class="headerlink" title="HttpServletRequest 详解"></a>HttpServletRequest 详解</h3><p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。</p>
<p>常用到的几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestURL() 返回全路径</span><br><span class="line">request.getRequestURI() 返回除去host（域名或者ip）部分的路径</span><br><span class="line">request.getContextPath() 返回工程名部分，如果工程映射为/，此处返回则为空</span><br><span class="line">request.getServletPath() 返回除去host和工程名部分的路径</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例如获取验证码的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestURL() is : http:<span class="comment">//localhost:8080/captchaImage</span></span><br><span class="line">request.getRequestURI() is : /captchaImage</span><br><span class="line">request.getContextPath() is : </span><br><span class="line">request.getServletPath() is : /captchaImage</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例如返回图片文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestURL() is : http:<span class="comment">//localhost:8080/profile/avatar/2020/07/31/8f04b7aa-c799-405b-90b0-4cfe36d89f35.jpeg</span></span><br><span class="line">request.getRequestURI() is : /profile/avatar/<span class="number">2020</span>/<span class="number">07</span>/<span class="number">31</span>/8f04b7aa-c799-405b-90b0-4cfe36d89f35.jpeg</span><br><span class="line">request.getContextPath() is : </span><br><span class="line">request.getServletPath() is : /profile/avatar/<span class="number">2020</span>/<span class="number">07</span>/<span class="number">31</span>/8f04b7aa-c799-405b-90b0-4cfe36d89f35.jpeg</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA获取主机硬件唯一标识CPUID+MAC地址。</title>
    <url>/2020/08/17/Java%E8%8E%B7%E5%8F%96%E7%A1%AC%E4%BB%B6%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86CPUID+MAC%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<blockquote>
<p>  Java为表示主机的唯一性而做出的获取主机CPUID和MAC地址时所进行的操作，整体是为了解决不同主机能在访问服务器时能通过某个唯一标识来进行权限认证，以此达到控制权限的目的</p>
</blockquote>
<span id="more"></span>

<h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>结合上一篇博文，我需要拿到一台主机的唯一标识，并且这个标识是不可修改的，经查阅发现，MAC地址虽然是唯一标识，但是可修改，所以不可采用。现在选取当前主机唯一标识——CPU序列，本篇说下LINUX系统和WINSOWS系统获取CPU序列，顺带说下MAC地址的方法。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主要思路就是使用Runtime.getRuntime().exec()执行命令来获取参数。毕竟是Java代码，要考虑多个平台的问题，而且linux和windows系统的命令又不同，所以分出处理。不多说，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前系统CPU序列，可区分linux系统和windows系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCpuId</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    String cpuId;</span><br><span class="line">    <span class="comment">// 获取当前操作系统名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">os</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    os = os.toUpperCase();</span><br><span class="line">    System.out.println(os);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// linux系统用Runtime.getRuntime().exec()执行 dmidecode -t processor 查询cpu序列</span></span><br><span class="line">    <span class="comment">// windows系统用 wmic cpu get ProcessorId 查看cpu序列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;LINUX&quot;</span>.equals(os)) &#123;</span><br><span class="line">        cpuId = getLinuxCpuId(<span class="string">&quot;dmidecode -t processor | grep &#x27;ID&#x27;&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cpuId = getWindowsCpuId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cpuId.toUpperCase().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取linux系统CPU序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLinuxCpuId</span><span class="params">(String cmd, String record, String symbol)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">execResult</span> <span class="operator">=</span> executeLinuxCmd(cmd);</span><br><span class="line">    String[] infos = execResult.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String info : infos) &#123;</span><br><span class="line">        info = info.trim();</span><br><span class="line">        <span class="keyword">if</span> (info.indexOf(record) != -<span class="number">1</span>) &#123;</span><br><span class="line">            info.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            String[] sn = info.split(symbol);</span><br><span class="line">            <span class="keyword">return</span> sn[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">executeLinuxCmd</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Runtime</span> <span class="variable">run</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">    Process process;</span><br><span class="line">    process = run.exec(cmd);</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n; (n = in.read(b)) != -<span class="number">1</span>; ) &#123;</span><br><span class="line">        out.append(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    process.destroy();</span><br><span class="line">    <span class="keyword">return</span> out.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取windows系统CPU序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getWindowsCpuId</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;wmic&quot;</span>, <span class="string">&quot;cpu&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;ProcessorId&quot;</span>&#125;);</span><br><span class="line">    process.getOutputStream().close();</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(process.getInputStream());</span><br><span class="line">    sc.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">serial</span> <span class="operator">=</span> sc.next();</span><br><span class="line">    <span class="keyword">return</span> serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>PerAuthorize 注解</title>
    <url>/2020/08/14/PerAuthorize%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>介绍 PerAuthorize 注解授权情况下的使用</p>
</blockquote>
<span id="more"></span>

<p>@PerAuthorizr 这个注解我相信很多不使用SpringSecurity的小伙伴都不是很了解。<br>使用他的初衷是最近需要做一个对授权的客户做判断，让他买了哪些模块的代码才能使用哪些模块的代码，需要进行一波模块过滤。<br>@PreAuthorize是可以用来控制一个方法或类是否能够被调用的，通俗一点就是看看你有没有权利用被注解的东西。怎么用呢？直接上代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取部门列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ac.hasPermi(&#x27;dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AjaxResult <span class="title function_">list</span><span class="params">(SysDept dept)</span> &#123;</span><br><span class="line">    List&lt;SysDept&gt; depts = deptService.selectDeptList(dept);</span><br><span class="line">    <span class="keyword">return</span> AjaxResult.success(depts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里@PreAuthorize(“@ac.hasPermi(‘dept:list’)”)是调用别名为as类的hasPermi方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 根据授权文件获取接口权限</span><br><span class="line">*/</span><br><span class="line">public boolean hasPermi(String permission) &#123;</span><br><span class="line">	log.debug(&quot; 当前模块：&#123;&#125; 当前权限：&#123;&#125; &quot;, permission, AuthorizationConfig.isAccess() &amp;&amp; authorizationConfig.getMk().indexOf(permission) &gt;= 0);</span><br><span class="line">    return AuthorizationConfig.isAccess() &amp;&amp; authorizationConfig.getMk().indexOf(permission) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里就简单写一下供大家参考。<br>判断结果返回true则正常调用接口，false则接口返回403。</p>
<p>加在类头上依然有效，上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部门信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ac.hasPermi(&#x27;mk&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/dept&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysDeptController</span> <span class="keyword">extends</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISysDeptService deptService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放了类头上会在每次调用改类方法的时候都会进行一次判断。</p>
<p>这样授权给用户的功能实现了，但是一个用户登录过之后，每次请求接口都要进行一次权限判断，这显然不合理，所以我想加上一个给每个用户本次登录判断完权限有之后加一个标识。这个写好了就更新~</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2021/05/31/interview/</url>
    <content><![CDATA[<blockquote>
<p>整理了面试过程中个人遇到的问题, 并附带了 chatgpt 的回答. 希望能对个人提升和习惯养成有所帮助.</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>2023年04月11日23:13:39</p>
</blockquote>
<p>mihoyo 面试准备内容</p>
<ul>
<li>go 里面使用 map 时应注意问题和数据结构?</li>
<li>go map 如何扩容?</li>
<li>哈希分桶的结构，用哈希值的高八位和低八位分别来做桶内定位的依据和分桶的依据等</li>
<li>map 的 panic 能被 recover 掉吗? 了解 panic 和 recover 的机制吗?</li>
<li>map 怎么知道自己处于竞争状态? 是 go 编码实现的还是底层硬件实现的?</li>
<li>cas 具体是怎么实现的呢?</li>
<li>并发使用 map 除了加锁还有什么其他方案吗?</li>
<li>有对比过 sync.Map 和加锁的区别吗?</li>
<li>说一下 redis 分布式锁的实现?</li>
<li>基于 redis 的分布式锁会有什么问题?</li>
<li>redis 分布式锁超时可以超时时间设长一点可以吗?不可以的话需要怎么解决?</li>
<li>对 redis 锁续期这个怎么实现呢?</li>
<li>日常在用的 redis 集群都是什么架构?在主从模式和 redis Cluster 中分布式锁会有什么问题?</li>
</ul>
<blockquote>
<p>2023年04月11日22:44:12</p>
</blockquote>
<h3 id="goroutine-并发问题一般怎么处理"><a href="#goroutine-并发问题一般怎么处理" class="headerlink" title="goroutine 并发问题一般怎么处理"></a>goroutine 并发问题一般怎么处理</h3><p>goroutine 并发问题的处理方法可以有多种，常见的包括以下几个方面：</p>
<ol>
<li><p>互斥锁：通过在临界区（共享资源）的访问前加锁，在访问完后释放锁，来保证同一时刻只有一个 goroutine<br>访问该资源。这是最基本也是最常用的并发控制手段。</p>
</li>
<li><p>通道（channel）：goroutine 可以通过通道来进行数据交换和同步，通道会自动进行同步和阻塞，从而避免竞争条件和死锁问题。</p>
</li>
<li><p>WaitGroup：通过 WaitGroup 来等待一组 goroutine 全部完成任务，可以避免并发中处理未完成的任务。</p>
</li>
<li><p>原子操作：原子操作是指不可分割的操作，它可以保证对于同一共享资源的操作是原子的，不会出现并发问题。在<br>Go<br>中，使用 atomic 包提供的原子操作可以很方便地解决一些常见的并发问题，如计数器增减等。</p>
</li>
<li><p>Select 语句：Select 语句可以使 goroutine 阻塞在多个通道上，从而实现多路复用和超时等功能。</p>
</li>
</ol>
<p>需要注意的是，并发编程需要特别小心处理各种细节，一定要保证代码正确性和可靠性。例如，避免死锁、竞争条件、资源泄露等问题，需要对并发编程有一定的深度理解和实践。</p>
<h3 id="介绍一下你理解的-DDD-说说领域驱动的优缺点"><a href="#介绍一下你理解的-DDD-说说领域驱动的优缺点" class="headerlink" title="介绍一下你理解的 DDD, 说说领域驱动的优缺点"></a>介绍一下你理解的 DDD, 说说领域驱动的优缺点</h3><ul>
<li>DDD 的优点：<ul>
<li>更好地理解业务领域：DDD 强调对业务领域的深入理解和建模，使得开发团队更加了解业务需求和问题，并有助于构建更符合业务需求的软件系统。</li>
<li>更好的代码组织结构：DDD 强调分层架构，并且在领域驱动设计中使用聚合根以及其它概念，使用这些技术可以帮助我们划分更清晰的代码组织结构，易于扩展和维护。</li>
<li>更好的模块化和可重用性：DDD 的模块可以独立开发、测试、部署和维护，这增强了代码和库的可重用性。</li>
<li>更好的代码质量：DDD 在代码设计和实现方面注重质量和可测试性，强调软件的可读性和可维护性，有助于减少代码漏洞和提高软件质量。</li>
<li>更容易与领域专家协作：DDD 鼓励开发团队与领域专家紧密合作，共同理解业务需求和问题，确保软件系统符合业务需求。</li>
</ul>
</li>
<li>DDD 的缺点：<ul>
<li>初始成本较高：使用 DDD 时需要时间和精力来理解业务领域以及进行领域建模和设计，这需要一定的成本和资源才能实现。</li>
<li>不适用于所有项目：DDD 更适用于大型复杂软件系统，对于小型简单项目可能会显得过于繁琐和复杂。</li>
<li>需要高水平的技能：使用 DDD 需要开发人员具备领域建模、业务分析和软件设计等方面的高水平技能，否则可能会造成代码质量不佳的问题。</li>
<li>架构复杂度高：DDD 引入了很多概念和技术，可能会增加架构的复杂度和难度。</li>
<li>协作开发成本高</li>
</ul>
</li>
</ul>
<h3 id="go-切片线程安全吗-安全的话为什么安全-不安全的话为什么不安全-如果保证线程安全"><a href="#go-切片线程安全吗-安全的话为什么安全-不安全的话为什么不安全-如果保证线程安全" class="headerlink" title="go 切片线程安全吗? 安全的话为什么安全? 不安全的话为什么不安全? 如果保证线程安全?"></a>go 切片线程安全吗? 安全的话为什么安全? 不安全的话为什么不安全? 如果保证线程安全?</h3><p>go 切片本身是线程不安全的</p>
<p>在 Go 中，切片是引用类型，底层结构包括指向底层数组的指针、切片长度和容量等信息。当多个协程或线程同时对同一个切片进行操作时，可能会发生数据竞争，导致程序出现不可预期的结果。</p>
<p>如果要保证切片的线程安全，可以采用以下方法：</p>
<ol>
<li>使用互斥锁（Mutex）来保护切片访问：在对切片进行读写操作前，先获取互斥锁，操作完成后释放锁。这种做法能够保证同一时间只有一个协程可以访问切片，从而避免了数据竞争问题。</li>
<li>使用读写锁（RWMutex）进行保护：如果对于切片的读取操作比写入操作更频繁，可以使用读写锁来提高效率。读写锁允许多个协程或线程同时读取切片，但只允许一个协程或线程进行写入操作。</li>
<li>使用通道（channel）来控制协程访问：可以将切片转换成通道，通过在通道上发送和接收数据来达到同步的目的。在此情况下，只能有一个协程写入切片，其他协程需要等待写入完成才能去访问。</li>
<li>不共享切片(我只想说这是个逆天方法)：在并发环境下，可以将切片复制一份，每个协程对自己的副本进行读写操作，从而避免了多个协程访问同一个切片的问题。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">个人理解：slice 是引用类型，底层指向的数组是值类型，数组本身是线程安全的，但切片涉及到了扩容，导致了切片并不是线程安全的。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2023年04月10日17:25:23</p>
</blockquote>
<h3 id="go-map-并发不安全的表现"><a href="#go-map-并发不安全的表现" class="headerlink" title="go map 并发不安全的表现"></a>go map 并发不安全的表现</h3><p>在 Go 中使用 map 存储数据时，如果多个协程同时对同一个 map 进行读写操作，会导致数据不一致。常见的表现有以下几种：</p>
<ol>
<li><p>写入冲突：如果两个或多个协程同时对同一个 map 的某个 key 进行写入操作，会出现竞争条件，容易导致数据被覆盖或漏写。</p>
</li>
<li><p>读写冲突：如果一个协程正在写入 map，而另外一个协程同时读取 map，可能会读到不一致的数据。</p>
</li>
<li><p>事件顺序混乱：如果多个协程同时对同一个 map 进行读写操作，那么事件的执行顺序可能会混乱，这也可能导致数据不一致的情况。</p>
</li>
</ol>
<p>为了解决这些问题，Go 提供了如下几种方案：</p>
<ol>
<li><p>加锁：使用 Mutex 或者 RWMutex 来保证 map 的并发安全，确保只有一个协程对 map 进行读写操作。</p>
</li>
<li><p>使用 sync.Map：sync.Map 是 Go 1.9 引入的，它提供了一种并发安全的<br>map，内部实现了读写锁和单独的实例存储机制，可以在并发环境下安全地进行读写操作。</p>
</li>
<li><p>使用 channel：通过 channel 来协调各个协程的读写操作，确保每个协程都能够正确地读写数据，从而避免竞争条件。</p>
</li>
</ol>
<p>综上所述，Go 中的 map 在并发操作时可能会出现不安全的情况，需要使用加锁、使用 sync.Map 或者使用 channel<br>等方案来确保其安全性。</p>
<h3 id="go-context-Context-使用场景"><a href="#go-context-Context-使用场景" class="headerlink" title="go context.Context 使用场景"></a>go context.Context 使用场景</h3><p>在 Go 中，context.Context 是一种用来传递请求特定的数据、取消协程的机制，它可以被用于多种场景，包括以下几个方面：</p>
<ol>
<li><p>协程间传递参数：在 Go 中启动一个协程很容易，但是如何向协程中传递参数就需要采用 context.Context 了。通过<br>WithValue 方法，可以将一些请求特定的数据传递到下游协程中，从而简化代码实现。</p>
</li>
<li><p>控制超时/取消：context.Context 提供了 Deadline 和 Cancel<br>方法，可以在指定时间或特定时机完成对协程的取消操作，从而避免程序因为等待某些资源而陷入死锁状态。</p>
</li>
<li><p>链路追踪：context.Context 可以被用于链路追踪，通过在 context 中注入 TraceID、SpanID<br>等信息，可以实现全链路跟踪和监测。</p>
</li>
<li><p>限制资源：context.Context 也可以被用于限制资源，例如数据库连接池中的最大连接数，通过使用<br>context.WithTimeout 和 context.WithDeadline 方法，可以确保在超过预设的时间后，不再向连接池中请求连接，从而避免连接池溢出。</p>
</li>
<li><p>处理错误：在处理请求时，可能会发生错误，这个时候可以通过传递一个被取消的 context<br>来通知下游协程退出，同时上游协程可以收到这个错误并进行处理。</p>
</li>
</ol>
<p>综上所述，context.Context 可以用于多种场景，包括协程间传递参数、超时/取消控制、链路追踪、资源限制和错误处理等。使用<br>context.Context 能够帮助我们更加优雅地实现代码逻辑，提高可维护性，并减少因为超时、死锁等问题带来的系统异常。</p>
<h3 id="线程中阻塞有哪些方式"><a href="#线程中阻塞有哪些方式" class="headerlink" title="线程中阻塞有哪些方式?"></a>线程中阻塞有哪些方式?</h3><ol>
<li>channel 阻塞: 当一个 goroutine 向一个已满的 channel 中写入数据或一个空 channel 中读取数据时，会发生阻塞。这时<br>goroutine 会暂停执行，等待其他 goroutine 从 channel 中读取或写入数据，从而使得自己可以继续执行。</li>
<li>Mutex 互斥锁阻塞: 在访问共享资源时，需要加锁来避免数据竞争。当一个 goroutine 访问到被 Mutex<br>锁住的共享资源时，如果 Mutex 被其他 goroutine 锁住了，当前 goroutine 就会阻塞在 Lock 操作上，等待<br>Mutex 解锁。</li>
<li>WaitGroup 阻塞：WaitGroup 可以用于等待多个 goroutine 的完成。在调用 WaitGroup 的 Wait 方法时，当前<br>goroutine 会阻塞在 Wait 方法上，直到计数器归零。</li>
<li>Timer 阻塞：在某个时间点触发某个操作，需要使用 Timer。Timer 的 C 成员变量通常会阻塞当前<br>goroutine，直到定时器到期后才能继续执行。</li>
</ol>
<h3 id="mysql-mongo-应用场景"><a href="#mysql-mongo-应用场景" class="headerlink" title="mysql mongo 应用场景"></a>mysql mongo 应用场景</h3><ul>
<li>mysql<ol>
<li>需要高度事务支持的应用</li>
<li>数据量大、数据结构稳定(不容易扩展的表)</li>
<li>复杂查询较多的场景</li>
</ol>
</li>
<li>mongo<ol>
<li>高度可扩展的</li>
<li>结构松散(json格式): 数据格式多样化，结构相对松散的应用：MongoDB 是文档型数据库，支持非常灵活的数据格式和动态的数据结构。这使得<br>MongoDB 更适合于数据结构相对自由的应用，例如社交网络、博客平台、物联网等。</li>
<li>需要实时数据处理和分析的应用：MongoDB 支持内置的 MapReduce<br>和聚合框架，能够高效地进行数据分析和处理。此外，它还提供了全文检索和地理空间查询等功能，非常适合需要实时分析和处理数据的应用。</li>
</ol>
</li>
</ul>
<h3 id="mysql-慢查询怎么处理"><a href="#mysql-慢查询怎么处理" class="headerlink" title="mysql 慢查询怎么处理?"></a>mysql 慢查询怎么处理?</h3><p>MySQL 慢查询是指执行时间较长的 SQL 查询语句，可能会对系统性能和响应时间造成影响。通常情况下，长时间查询是由于<br>SQL 语句写法不当、查询条件错误或者数据量过大等原因导致的。</p>
<p>以下是处理 MySQL 慢查询的方法：</p>
<ol>
<li><p>开启慢查询日志：通过在 MySQL 配置文件中开启慢查询日志（slow_query_log），MySQL 会记录执行时间超过设定阈值的<br>SQL 语句，并将其保存到日志文件中。可以利用这些记录来优化性能较慢的查询语句。</p>
</li>
<li><p>分析查询语句：可以使用 EXPLAIN 关键字查看查询语句的执行计划，以确定是否需要添加索引或者优化查询语句。</p>
</li>
<li><p>优化查询语句：通过调整查询语句的写法、缩小查询范围等手段来尽量减少查询返回的结果集大小，从而提升查询速度。</p>
</li>
<li><p>添加索引：索引可以加速查询操作，但是过多、重复或者不合理的索引会带来额外的开销。因此，在添加索引前需要理性分析数据表的结构和访问模式。</p>
</li>
<li><p>优化 MySQL 参数：通过配置 MySQL 中的参数（如max_connections，query_cache_size 等）来提高 MySQL 的性能。</p>
</li>
<li><p>升级硬件：如果以上方法都无法解决慢查询问题，可以考虑升级硬件（如更换 CPU、加大内存、升级硬盘等）来提高系统性能。</p>
</li>
</ol>
<p>以上是处理 MySQL 慢查询的常用方法，需要综合考虑应用场景和具体情况来选择最优的解决方案。</p>
<h3 id="redis-雪崩是什么-怎么解决"><a href="#redis-雪崩是什么-怎么解决" class="headerlink" title="redis 雪崩是什么?怎么解决?"></a>redis 雪崩是什么?怎么解决?</h3><p>redis 雪崩是指 redis 缓存中大量的 key 在同一时间失效或者过期，导致瞬时请求全部落在数据库上，从而引起数据库性能问题、甚至宕机的现象。通常情况下，redis<br>雪崩是由于系统设计不合理、缺乏容错机制、缓存框架异常等原因导致的。</p>
<p>以下是处理 redis 雪崩的方法：</p>
<ol>
<li><p>设置过期时间随机化：可以通过给 redis 中的 key 设置随机过期时间，避免大量的 key 同一时间过期。例如，可以在<br>redis 中设置一个过期时间的范围，在这个范围内随机生成一个时间来设置过期时间。</p>
</li>
<li><p>缓存预热: 可以通过缓存预热的方式，提前将部分常用的 key 加载到 redis 缓存中，避免一次性访问大量数据库，从而减轻数据库负担。</p>
</li>
<li><p>数据库限流：可以通过设置连接数、并发数等参数，限制数据库的最大请求频率，避免大量请求同时打到数据库上，导致宕机。</p>
</li>
<li><p>加强监控：要对 redis 的运行情况进行监控，包括 key 过期时间、内存使用情况等信息，以便及时发现异常和预测故障。</p>
</li>
<li><p>分布式部署：将 redis 集群化，将数据分散到多个 redis 节点上，可以降低单个节点的负载，提高系统的容错性。</p>
</li>
<li><p>备份和恢复：定期备份 redis 数据，保证在 redis 宕机或者数据错误的情况下可以快速恢复数据，减少故障恢复时间。</p>
</li>
</ol>
<p>综上所述，通过设置过期时间随机化、缓存预热、数据库限流、加强监控、分布式部署和备份和恢复等方法，可以有效地解决<br>redis 雪崩问题，并提高系统的稳定性和可靠性。</p>
<h3 id="redis-分布式锁的上限如何设置"><a href="#redis-分布式锁的上限如何设置" class="headerlink" title="redis 分布式锁的上限如何设置?"></a>redis 分布式锁的上限如何设置?</h3><p>在 redis 中实现分布式锁时，可以考虑使用 SETNX（SET if Not<br>eXists）指令。但是，当多个客户端同时竞争同一个锁时，会导致竞争激烈，从而导致大量的锁请求超时，影响系统性能。</p>
<p>为了避免这种情况，可以给分布式锁添加一个过期时间（即锁的最大持续时间），当锁到期之后自动释放。但是，需要合理地设置锁的过期时间，以避免太短影响业务操作，太长则可能导致死锁等问题。</p>
<p>一般来说，锁的过期时间应该根据业务特点和数据处理时间来确定。例如，如果业务数据处理时间在 10 秒钟内完成，可以设置<br>15 秒的过期时间；如果业务数据处理时间较长，可以适当延长过期时间。但是，过长的过期时间会增加单点故障的风险，因此需要综合考虑。</p>
<p>除了设置过期时间外，还可以考虑引入 Redlock 算法、基于 Lua<br>脚本实现分布式锁等技术，以提高分布式锁的稳定性和可靠性。但是，需要根据具体情况进行选择和实现。</p>
<blockquote>
<p>2021-07-22</p>
</blockquote>
<h3 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h3><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务</p>
<p>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</p>
<p>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>
<h3 id="Zookeeper是什么框架"><a href="#Zookeeper是什么框架" class="headerlink" title="Zookeeper是什么框架"></a>Zookeeper是什么框架</h3><p>Zookeeper是分布式系统协调服务的框架，也叫作服务注册中心</p>
<h3 id="Dubbo一般用什么注册中心-还有别的选择吗"><a href="#Dubbo一般用什么注册中心-还有别的选择吗" class="headerlink" title="Dubbo一般用什么注册中心?还有别的选择吗?"></a>Dubbo一般用什么注册中心?还有别的选择吗?</h3><p>Dubbo一般使用Zookeeper，也可以使用redis，consul，数据库</p>
<h3 id="为什么说Spring是一个容器"><a href="#为什么说Spring是一个容器" class="headerlink" title="为什么说Spring是一个容器?"></a>为什么说Spring是一个容器?</h3><p>Spring的核心思想是更方便的管理Java Bean，有Spring创建的Bean放入一个Map中，这个Map就可以理解成装Bean的容器，也就是IOC容器。</p>
<h3 id="JVM生命周期和体系结构"><a href="#JVM生命周期和体系结构" class="headerlink" title="JVM生命周期和体系结构"></a>JVM生命周期和体系结构</h3><p>JVM声明周期是跟随程序一起的，JVM开始运行时就是程序启动时，JVM停止运行程序也随之结束。</p>
<p>JVM体系结构包含：类加载器、内存区、执行引擎、本地方法调用。</p>
<blockquote>
<p>2021-06-07</p>
</blockquote>
<h3 id="ConcurrentHashMap为什么是CAS-Synchronized"><a href="#ConcurrentHashMap为什么是CAS-Synchronized" class="headerlink" title="ConcurrentHashMap为什么是CAS+Synchronized?"></a>ConcurrentHashMap为什么是CAS+Synchronized?</h3><p>用CAS是为了减小锁的粒度，毕竟CAS是JUC下面使用最多的锁，用Synchronized是因为Synchronized可以不断优化，并且粒度也不高。</p>
<h3 id="MyBatis是怎么实现的-不用Spring怎么集成"><a href="#MyBatis是怎么实现的-不用Spring怎么集成" class="headerlink" title="MyBatis是怎么实现的?不用Spring怎么集成?"></a>MyBatis是怎么实现的?不用Spring怎么集成?</h3><h3 id="CAS会出现什么问题-怎么解决的"><a href="#CAS会出现什么问题-怎么解决的" class="headerlink" title="CAS会出现什么问题?怎么解决的?"></a>CAS会出现什么问题?怎么解决的?</h3><p>ABA问题</p>
<h3 id="MySQL和redis的重要数据，必须完全一致，这个怎么实现"><a href="#MySQL和redis的重要数据，必须完全一致，这个怎么实现" class="headerlink" title="MySQL和redis的重要数据，必须完全一致，这个怎么实现?"></a>MySQL和redis的重要数据，必须完全一致，这个怎么实现?</h3><h3 id="MySQL是可重复读是怎么实现的"><a href="#MySQL是可重复读是怎么实现的" class="headerlink" title="MySQL是可重复读是怎么实现的?"></a>MySQL是可重复读是怎么实现的?</h3><p>使用MVCC（多版本并发控制），每次SELECT之前会找到上一个数据版本，只读当前版本的数据。innoDB已经实现”<br>秒级快照版本”</p>
<h3 id="springboot做了哪些事-深入到底层是怎么实现的"><a href="#springboot做了哪些事-深入到底层是怎么实现的" class="headerlink" title="springboot做了哪些事?深入到底层是怎么实现的?"></a>springboot做了哪些事?深入到底层是怎么实现的?</h3><h3 id="redis的Key过期后会立即删除么"><a href="#redis的Key过期后会立即删除么" class="headerlink" title="redis的Key过期后会立即删除么?"></a>redis的Key过期后会立即删除么?</h3><p>不会的，三种删除策略：定时删除、惰性删除（?还有什么?原理是什么）</p>
<h3 id="redis的集群用过吗-是怎么的架构-哨兵机制呢"><a href="#redis的集群用过吗-是怎么的架构-哨兵机制呢" class="headerlink" title="redis的集群用过吗?是怎么的架构?哨兵机制呢?"></a>redis的集群用过吗?是怎么的架构?哨兵机制呢?</h3><h3 id="分布式集群下怎么执行定时任务"><a href="#分布式集群下怎么执行定时任务" class="headerlink" title="分布式集群下怎么执行定时任务?"></a>分布式集群下怎么执行定时任务?</h3><h3 id="为什么分布式要用RestTemplete而不用HttpUtils"><a href="#为什么分布式要用RestTemplete而不用HttpUtils" class="headerlink" title="为什么分布式要用RestTemplete而不用HttpUtils?"></a>为什么分布式要用RestTemplete而不用HttpUtils?</h3><h3 id="JWT的整体流程是怎样的"><a href="#JWT的整体流程是怎样的" class="headerlink" title="JWT的整体流程是怎样的?"></a>JWT的整体流程是怎样的?</h3><p>MySQL锁<br>redis集群</p>
<blockquote>
<p>2021-06-04</p>
</blockquote>
<h3 id="maven父类依赖冲突"><a href="#maven父类依赖冲突" class="headerlink" title="maven父类依赖冲突"></a>maven父类依赖冲突</h3><p>maven的依赖原则</p>
<h3 id="线城池参数、拒绝策略、流程"><a href="#线城池参数、拒绝策略、流程" class="headerlink" title="线城池参数、拒绝策略、流程"></a>线城池参数、拒绝策略、流程</h3><p>7个参数：核心线程数、总线程数、存活时间、时间单位、阻塞队列、工厂、拒绝策略</p>
<p>4个拒绝策略：拒绝并抛出异常、静默拒绝、移除队列中最前面的任务然后重新提交被拒绝的任务、由调用线程来执行该任务</p>
<p>流程：先看核心线程是否满了，满了再看阻塞队列是否满了，满了再看总线程数是否满了，满了再走拒绝策略</p>
<h3 id="ConcurrentHashMap的线程安全在JDK1-7和JDK1-8的区别"><a href="#ConcurrentHashMap的线程安全在JDK1-7和JDK1-8的区别" class="headerlink" title="ConcurrentHashMap的线程安全在JDK1.7和JDK1.8的区别"></a>ConcurrentHashMap的线程安全在JDK1.7和JDK1.8的区别</h3><p>JDK1.7：分段锁</p>
<p>JDK1.8 :  Synchronized+CAS</p>
<h3 id="SpringMVC工作流程（需要仔细研究底层执行流程）"><a href="#SpringMVC工作流程（需要仔细研究底层执行流程）" class="headerlink" title="SpringMVC工作流程（需要仔细研究底层执行流程）"></a>SpringMVC工作流程（需要仔细研究底层执行流程）</h3><ol>
<li>客户端发送请求到前端控制器DispatcherServlet</li>
<li>前端控制器DispatcherServlet根据URL来决定选择哪一个控制器Controller进行处理，并把请求委托给控制器</li>
<li>控制器Controller接收请求后，将请求参数绑定为一个对象，这个对象叫命令对象，并进行验证。然后将命令对象委托给业务对象进行处理，处理完毕后返回一个ModelAndView</li>
<li>前端控制器DispatcherServlet收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入，以便渲染</li>
<li>前端控制器DispatcherServlet再次收回控制权，将相应返回给用户</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>加载、验证、解析、准备、初始化</p>
<h3 id="了解双亲委派机制吗"><a href="#了解双亲委派机制吗" class="headerlink" title="了解双亲委派机制吗?"></a>了解双亲委派机制吗?</h3><p>一个类加载器加载类时，会将请求委托交给父加载器去加载，只要父加载器无法完成这个加载请求时，子加载器才会自己尝试完成加载。</p>
<p>好处：保证基础类环境的稳定运行</p>
<blockquote>
<p>2021-06-03</p>
</blockquote>
<h3 id="spring和springboot的区别"><a href="#spring和springboot的区别" class="headerlink" title="spring和springboot的区别"></a>spring和springboot的区别</h3><p>springboot就是spring的扩展，少了繁琐的配置，让开发、测试、部署方便了。</p>
<blockquote>
<p>2021-06-02</p>
</blockquote>
<h3 id="了解HashMap吗"><a href="#了解HashMap吗" class="headerlink" title="了解HashMap吗?"></a>了解HashMap吗?</h3><ul>
<li>HashMap的数据结构（数组+链表/红黑树）</li>
<li>哈希冲突的实现原理</li>
<li>HashMap扩容机制</li>
<li>线程不安全性</li>
<li>HashMap为什么初始容量是2的4幂（16）：按位运算</li>
</ul>
<h3 id="那想用线程安全的Map用什么呢-（踩过坑）"><a href="#那想用线程安全的Map用什么呢-（踩过坑）" class="headerlink" title="那想用线程安全的Map用什么呢?（踩过坑）"></a>那想用线程安全的Map用什么呢?（踩过坑）</h3><p>我答的ConcurrentHashMap是线程安全的，并且把线程安全的机制详细的描述了一遍；但是我记忆里大学期间学过了一段设计，就是说ConcurrentHashMap也不是完全保证线程安全的，在事务下，也会发生线程不安全。当时对ConcurrentHashMap的理解也仅限于此；但今天细究了一下，ConcurrentHashMap是可以完全保证每次操作的线程安全问题的，但是事务的安全那就得另算了，需要考虑的就是事务的隔离级别了！这点希望大家不要和我一起进入这个误区。过段时间会详细写一下事务的隔离级别的专题文章。</p>
<h3 id="了解MySQL索引吗"><a href="#了解MySQL索引吗" class="headerlink" title="了解MySQL索引吗?"></a>了解MySQL索引吗?</h3><ul>
<li>索引的数据结构（B+树）</li>
<li>B+树的自平衡（脑子清楚嘴笨）</li>
<li>MySQL索引能存储的数据量</li>
<li>事务的基本要素ACID</li>
<li>事务并发问题：脏读、不可重复读、幻读</li>
<li>事务的隔离级别（读未提交、不可重复读、重复读、串行化）</li>
</ul>
<h3 id="算法题：数组中求最大差值（股票的最大收益问题）"><a href="#算法题：数组中求最大差值（股票的最大收益问题）" class="headerlink" title="算法题：数组中求最大差值（股票的最大收益问题）"></a>算法题：数组中求最大差值（股票的最大收益问题）</h3><p>这题朴实无华的动态规划，2分钟解决了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        int[] nums;</span></span><br><span class="line"><span class="comment">//        nums = new int[0];</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;1&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;21, 12, 7, 3, 11, 20&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;21, 20, 19, 18, 10&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//        nums = new int[]&#123;22, 20, 20, 20, 10&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question1(nums));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划实现, 如果按照题意求最大差值的话需要返回零和负数情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">question1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - min &gt; max) &#123;</span><br><span class="line">                max = nums[i] - min;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; min) &#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法题：计算合法（）的最大长度"><a href="#算法题：计算合法（）的最大长度" class="headerlink" title="算法题：计算合法（）的最大长度"></a>算法题：计算合法<code>（）</code>的最大长度</h3><p>???这连中间都不穿插点加减号了???</p>
<p>直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        String str;</span></span><br><span class="line"><span class="comment">////        str = &quot;()()()()&quot;;</span></span><br><span class="line"><span class="comment">////        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">////        str = &quot;((((()()&quot;;</span></span><br><span class="line"><span class="comment">////        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;()(())&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;(()))))())&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;((((&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;)))((()((((()((&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//        str = &quot;(*(*)*)*)(())&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(question2(str));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈使用的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">question2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == str)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == str.charAt(i)) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    start = i + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                        result = Math.max(result, i - start + <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result = Math.max(result, i - stack.peek());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法题：实现LRU算法"><a href="#算法题：实现LRU算法" class="headerlink" title="算法题：实现LRU算法"></a>算法题：实现LRU算法</h3><p>这题我是最喜欢的^_^因为我脑子会，手不会写（我就想知道谁能记住LinkedHashMap里面的API啊），所以百度帮我做了，但想法我就是这样的。</p>
<p>给大家讲一下实现吧，首先LRU就叫做Least Recently<br>Used最少最近使用，就是把最老最久没碰过得数据给淘汰掉，刚好LinkedHashMap就已经做了按照访问顺序来实现节点排序，HashMap的put方法有一个实现，参数是accessOrder，当accessOrder=true时，访问节点和插入节点都会将当前节点放到链表最新处（如果是JDK1.6+那就是放到结尾去），那不就是LRU的想法么 ~<br>那我直接用就好了（源码解析我7月份会贡献笔记）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU算法：最少最近使用：利用LinkedHashMap实现了按访问顺序存储的特性来简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> initialCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> cacheSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.initialCapacity = cacheSize;</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil(cacheSize / loadFactor) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// accessOrder=true是重点, 该参数为true是按照访问顺序插入到链表最新节点后, false是按照插入顺序存储</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt;(capacity, loadFactor, <span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; LRUCache.<span class="built_in">this</span>.initialCapacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计一个门票限时销售系统"><a href="#设计一个门票限时销售系统" class="headerlink" title="设计一个门票限时销售系统"></a>设计一个门票限时销售系统</h3><p>听到这个题目我直接懵圈了，what?我设计一个系统?</p>
<p>提供系统架构图和业务流程图，what?画图?</p>
<p>这个考的不是我的专业技能，是对总体把控的能力，但我觉得我现在还不是把精力去花费在把一个个专业知识整合的时候，我更应该做的是去精通和扎实每一个我熟悉的技术（听起来像是在给自己找理由，嘻嘻），所以这题我就简单答了答，做了一个微服务，订单和商品的并发操作使用redis的分布式锁保证安全，然后限时功能也是就用redis的设置存活时间来实现。</p>
<blockquote>
<p>2021-06-01</p>
</blockquote>
<h3 id="算法题：求100以内质数的阶乘之和"><a href="#算法题：求100以内质数的阶乘之和" class="headerlink" title="算法题：求100以内质数的阶乘之和"></a>算法题：求100以内质数的阶乘之和</h3><p>思路是先求100以内的阶乘，放到数组中，再对数组中的质数一一求阶乘，再累加；</p>
<p>思路清晰，但编码过程中我发现了两个问题，一个就是10以上的阶乘其实是非常大的，那么他们的和很可能超过int和long的范围，所以尽可能使用其他更能长的数据结构来存储。果然，97的阶乘甚至都到达了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>那么就先用BigDecimal来试试够不够，上我的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">question2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 保存质数结果集</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断当前数字是否为质数</span></span><br><span class="line">        <span class="keyword">if</span> (isPrimeNumber(i)) &#123;</span><br><span class="line">            <span class="comment">// 将质数添加到结果集</span></span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印质数结果集, 为question5参考</span></span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 返回结果超出long长度, 使用BigDecimal保存最终结果和计算过程结果</span></span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : list) &#123;</span><br><span class="line">        <span class="comment">// 顺序添加BigDecimal类型的阶乘结果</span></span><br><span class="line">        result = result.add(getBigDecimalFactorial(num));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;结果:&quot;</span> + result); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个2-100的数字是否是质数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrimeNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= Math.sqrt(num); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算一个1-100之间数字的阶乘</span></span><br><span class="line"><span class="comment"> * 返回结果超过long长度, 使用BigDecima保存过程结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BigDecimal <span class="title function_">getBigDecimalFactorial</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; num; i++) &#123;</span><br><span class="line">        result = result.multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(num + <span class="string">&quot;的阶乘是&quot;</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运气不错，BigDecimal就存下了。但如果是BigDecimal也存储不下的话，就用String来存吧，就是要重写一个加减乘除方法来实现就比较麻烦了。</p>
<h3 id="智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多"><a href="#智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多" class="headerlink" title="智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多"></a>智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多</h3><p>这题我采用的数学的方式解决，也是需要转个弯就解决了。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 设一堆中朝上硬币是x, 另一堆则是10-x</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 那我需要做的令 x = 10-x</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 那么问题就来了, 错误的逻辑是让 x = 5, 思考无果后换个方向</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 如果还有一个10-x的变量, 那么尝试着解决交换变量种类可不可以</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 百度：如果令一堆硬币是10, 翻转这10枚硬币, 就可以了（啊啊啊, 我的思路没错, 就差一点点）</span></span><br></pre></td></tr></table></figure>

<h3 id="证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除"><a href="#证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除" class="headerlink" title="证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除"></a>证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除</h3><p>这个话不多说了，我思路都在我的回答上了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">question5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1 3 中间这个数字是2, 这个数字需要大于6*********************************</span></span><br><span class="line">    <span class="comment">// 2 4 不可能2结尾, 因为所有2结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 3 5 不可能5结尾, 因为所有5结尾的大于6的数字都可以被5整除(15, 25, 35)</span></span><br><span class="line">    <span class="comment">// 4 6 不可能4结尾, 因为所有4结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 5 7 不可能5结尾, 因为所有5结尾的大于6的数字都可以被5整除(15, 25, 35)</span></span><br><span class="line">    <span class="comment">// 6 8 不可能6结尾, 因为所有6结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 7 9 中间这个数字是8, 这个数字需要大于6***************************************</span></span><br><span class="line">    <span class="comment">// 8 0 不可能8结尾, 因为所有8结尾的数字都可以被2整除</span></span><br><span class="line">    <span class="comment">// 9 1 中间这个数字是0, 这个数字需要大于6*********************************</span></span><br><span class="line">    <span class="comment">// 0 2 不可能0结尾, 因为所有0结尾的数字都可以被5整除</span></span><br><span class="line">    <span class="comment">// 根据星号“*****”行的分析可知</span></span><br><span class="line">    <span class="comment">// 根据我的上面这个分析, 只需要证明这个数字一定可以被2整除, 那么该命题就可以转换成去证明这个数字可以被3整除</span></span><br><span class="line">    <span class="comment">// 假设质数对数字为x, x-1, x+1分别是质数</span></span><br><span class="line">    <span class="comment">// 而且x-1和x+1都是大于6的质数, 那么x-1不可能被三整除, 要么余1, 要么余2, 同理可知x+2, 要么余1, 要么余2</span></span><br><span class="line">    <span class="comment">// 并且关键是x-1与x+1之间只差了2, 所以这两个质数的余数一定是一个余1, 一个余2</span></span><br><span class="line">    <span class="comment">// 那么假设x不可能被3整除, 那么一定余1或者余2, 无论如何都是x+1和x-1余1余2的条件矛盾</span></span><br><span class="line">    <span class="comment">// 所以x一定可以被3整除</span></span><br><span class="line">    <span class="comment">// 最后得到结论, 质数对之前的数字一定可以被6整除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>百度的答案稍微复杂点，我是拆解了6，感觉更容易理解一些。</p>
<blockquote>
<p>2021-05-31</p>
</blockquote>
<h3 id="我在项目中遇到的难点"><a href="#我在项目中遇到的难点" class="headerlink" title="我在项目中遇到的难点"></a>我在项目中遇到的难点</h3><ul>
<li>地图切片的分组缓存</li>
<li>负责集成LiquiBase</li>
</ul>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4git</title>
    <url>/2020/08/27/learn4git/</url>
    <content><![CDATA[<blockquote>
<p>  日常使用Git操作，随笔整理持续更新</p>
</blockquote>
<span id="more"></span>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init -- 在当前目录下初始化一个git仓库, 如果是基本项目开发基本用不到这个命令</span><br></pre></td></tr></table></figure>

<h3 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git colne &lt;url&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加工作区文件到暂存区"><a href="#添加工作区文件到暂存区" class="headerlink" title="添加工作区文件到暂存区"></a>添加工作区文件到暂存区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;fileName&gt; -- 指定一个文件添加到暂存区</span><br><span class="line">git add . -- 常用, 将当前目录下的所有改动的文件添加到暂存区</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  工作区：项目目录下除了<code>.git</code>文件夹以外的区域，简单来说就是你的项目文件区域</p>
</blockquote>
<h3 id="查看工作状态"><a href="#查看工作状态" class="headerlink" title="查看工作状态"></a>查看工作状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status -- 查看当前工作区和暂存区的文件状态</span><br></pre></td></tr></table></figure>

<h3 id="提交暂存区文件到本地仓库"><a href="#提交暂存区文件到本地仓库" class="headerlink" title="提交暂存区文件到本地仓库"></a>提交暂存区文件到本地仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;本次提交的描述内容&quot;</span><br></pre></td></tr></table></figure>

<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard ] [HEAD]-- 将暂存区的文件取消暂存</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <code>--mixed</code>为默认参数，重置暂存区的文件与上一次提交保持一致，工作区内容不变。可以理解成把工作区的文件和上次一提交的文件重新比对。效果上就像把暂存区的文件重新拿到工作区。</p>
<p>  <code>--soft</code>为回退到上一个版本。</p>
<p>  <code>--hard</code>为撤销工作区中所有未提交的内容，将暂存区和工作区都回到上一次版本，并删除之前的所有信息。就把这个参数理解成回到某个版本”最初的样子”。效果上就像时间回溯到了上一个版本提交之前，重新开发上一个版本一样。</p>
</blockquote>
<blockquote>
<p>  其实<code>git reset</code>操作用好了还是挺有用的，比如你当前项目改了一堆没用的地方，你都不想要了，就可以：</p>
<p>  <code>git reset --hard HEAR</code>将当前工作区和暂存区恢复成当前版本”最初的样子”，本地代码瞬间全没了！妙~~~啊！(\狗头)</p>
</blockquote>
<h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h3 id="推送本地仓库到远程仓库"><a href="#推送本地仓库到远程仓库" class="headerlink" title="推送本地仓库到远程仓库"></a>推送本地仓库到远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; -- 最原始的命令</span><br><span class="line">git push -- 常用, 将当前分支推送到远程绑定的对应分支</span><br></pre></td></tr></table></figure>

<h3 id="更新远端分支"><a href="#更新远端分支" class="headerlink" title="更新远端分支"></a>更新远端分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote update origin -p</span><br></pre></td></tr></table></figure>

<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="查看本地所有分支"><a href="#查看本地所有分支" class="headerlink" title="查看本地所有分支"></a>查看本地所有分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a -- 展示的列表中*符号说明当前代码处于哪个分支</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  有时候远端的分支刷新了，你本地获取分支列表发现，”啊哈，分支列表和远端对应不上！”。这时候不用慌，是因为这个列表是保存在本地的，并不是从远端实时获取的，你需要做的就是刷新这个保存在本地的列表与远端同步：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote update origin -p -- 用远端来更新本地仓库</span><br></pre></td></tr></table></figure>

<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch &lt;name&gt; -- 从当前分支创建了名称为 dev 的分支</span><br></pre></td></tr></table></figure>

<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt; -- 切换到本地目标分支</span><br><span class="line">git checkout -b &lt;newBranchName&gt; -- 从当前分支创建一个新分支并切换到新分支上</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <code>git checkout -b</code>操作可以在任一分支的任何状态执行，执行成功之后，会将所有操作复制到新的分支上，并且会切换到新分支，如果新分支提交了修改，则原有分支的操作会撤销掉。</p>
</blockquote>
<h3 id="合并某分支到当前分支"><a href="#合并某分支到当前分支" class="headerlink" title="合并某分支到当前分支"></a>合并某分支到当前分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge &lt;branchName&gt; -- 合并目标分支到当前分支</span><br></pre></td></tr></table></figure>

<h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branchName&gt; -- 删除本地的目标分支</span><br></pre></td></tr></table></figure>

<h3 id="重新定基操作"><a href="#重新定基操作" class="headerlink" title="重新定基操作"></a>重新定基操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase &lt;branchName&gt; -- 以本地目标分支为基准，合并代码</span><br></pre></td></tr></table></figure>

<p>首先，说明一下rebase的作用：将目标分支的开发呈现一条直线，没有其他分支合并进来的节点，展示起来比较清晰。</p>
<p>那么能来点实际吗？——彳亍</p>
<p>git rebase相关流程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b [本地开发分支名] origin/[远程分支名] -- 以目标分支为基准创建新分支并关联远端分支</span><br><span class="line">....... -- 修改代码的操作</span><br><span class="line">git add . -- 添加所有本次修改的文件添加到暂存区</span><br><span class="line">git commit -m &quot;注释内容&quot; -- 提交代码，保存本地分支</span><br><span class="line">git checkout [主分支] -- 切换分支，这个分支是目标基点的分支，简单来说，就是把现在的代码变成从&quot;这个分支开始进行开发&quot;的分支</span><br><span class="line">git pull -- 拉取主分支代码，此时本地仓库主分支代码为最新代码，本地开发分支有所有修改的代码</span><br><span class="line">git checkout [本地开发分支] // 切回本地开发分支，准备rebase</span><br><span class="line">git rebase [主分支] -i HEAD~2 // 将当前分支合并提交到目标分支</span><br><span class="line">// rebase过程可能会出现冲突，解决冲突后继续rebase过程</span><br><span class="line">git rebase [主分支] --continue // 继续rebase过程</span><br><span class="line">git push // 推送远端</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  当然，如果你不愿意在提交代码的时候进行<code>rebase</code>操作，你可以将<code>git commit</code>暂存操作换乘<code>git stash</code>暂存，这将使你的<code>rebase</code>过程变的无比顺利</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>当进行了一个阶段的开发工作之后，就会需要对代码进行<code>提交</code>操作，推送到远端分支，这部分工作当然可以交给IDE来完成，不过我更推荐使用命令的形式，来更多的理解<code>git的工作原理</code></p>
<blockquote>
<p>  流程：暂存代码<code>-&gt;</code>提交到本地仓库<code>-&gt;</code>推送到远端分支</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 暂存代码：所有变化提交到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 提交到本地仓库，这步需要简介且明确的写出本次提交的所有内容</span></span><br><span class="line">git commit -m &quot;本次提交内容的注释说明&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 推送到远端分支</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; # 如果你看过了前面的内容后，应该可以轻松地简化这行命令</span><br></pre></td></tr></table></figure>

<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>如果你充分理解了分支操作的本质，就会对冲突的解决应对自如，这里还是给出拉取代码时出现代码冲突情况的解决办法：</p>
<blockquote>
<p>  流程：暂存(压栈)<code>-&gt;</code>拉取代码<code>-&gt;</code>释放代码（弹栈）<code>-&gt;</code>手动合并冲突代码</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果本地代码与线上代码有冲突，git pull 是会报错，如下：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">error: Your <span class="built_in">local</span> changes to <span class="string">&#x27;-----&#x27;</span> would be overwritten by merge. Aborting.Please, commit your changes or stash them before you can merge.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那么接下来，将是你需要做的几步：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 将本地代码暂存，将工作区代码恢复到上一个版本</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 拉取代码，将工作区代码更新为远端最新版本</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 释放代码，也就是弹栈，将之前暂存的代码取出</span></span><br><span class="line">git stash pop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 手动合并代码，如果使用ide工具进行，这项工作将变的更加容易</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 查看代码状态，会展示你这次合并代码过程中又对哪些文件进行了修改</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 之后就是继续进行开发工作，再对新代码进行add、commit操作啦~^v^</span></span><br></pre></td></tr></table></figure>

<h3 id="将本地项目提交到远程仓库（远程仓库是空项目）"><a href="#将本地项目提交到远程仓库（远程仓库是空项目）" class="headerlink" title="将本地项目提交到远程仓库（远程仓库是空项目）"></a>将本地项目提交到远程仓库（远程仓库是空项目）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 先进入项目文件夹</span></span><br><span class="line">cd 当前项目的完整路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 初始化这个目录变成git可以管理的仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 暂存并提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Init Project&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 关联到远程库</span></span><br><span class="line">git remote add origin &lt;你的远程库地址&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）</span></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4go</title>
    <url>/2021/06/16/learn4go/</url>
    <content><![CDATA[<blockquote>
<p>本文目的是记录我从 Java 开发转 Golang 开发的学习经历，分享一下学习过程来帮助想要 Java 转 Golang 的朋友一起进步一起学习！</p>
</blockquote>
<span id="more"></span> 

<h1 id="0、安装配置"><a href="#0、安装配置" class="headerlink" title="0、安装配置"></a>0、安装配置</h1><p>下载地址：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<p>下载好了用<code>go version</code>来校验</p>
<p>配置环境：GOPATH、Path</p>
<p>配置好了用<code>go env</code>来校验</p>
<h1 id="1、Golang基础"><a href="#1、Golang基础" class="headerlink" title="1、Golang基础"></a>1、Golang基础</h1><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul>
<li>并发编程优雅简单：Go语言原生支持协程（goroutine）和管道（channel），并提供了灵活而简单的并发编程机制。使用goroutine可以让我们非常方便地实现高并发、高性能的服务，同时也能有效避免线程安全问题。</li>
<li>零值机制：天生就有初始值，不用考虑空值情况。</li>
<li>内存管理自动化：Go语言的垃圾回收机制使得开发者可以不用关心内存的回收问题，极大地降低了程序出错的可能性和代码的复杂度。</li>
<li>语法简洁、易读易写：Go语言的语法简洁，没有像C++和Java那样繁琐的语法，特别是其强制规范化的代码风格更是方便了开发者对代码的理解和阅读。</li>
<li>静态类型系统：Go语言采用静态类型系统，可以在编译期检查出很多类型错误，避免了在运行时出现的错误。</li>
<li>良好的可移植性：Go语言的标准库支持多种操作系统和硬件平台，开发者可以轻松地将代码移植到不同的平台上。</li>
<li>开发效率高：Go语言的构建工具可以帮助开发者进行高效构建和测试。同时，Go语言的包管理工具go mod也是一个非常强大的工具，可以帮助开发者解决依赖管理和版本控制等问题。</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go build</span><br><span class="line">go build -o &quot;***.exe&quot;</span><br><span class="line">go run main.go</span><br><span class="line">go install</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名变量(就是一个下划线) -&gt; _ : 匿名变量不占用命名空间，不会分配内存（Lua里叫哑元变量）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(i <span class="type">int</span>, s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> i, s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, _ := foo(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>)</span><br><span class="line">	_, y := foo(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>)</span><br><span class="line">	fmt.Println(x, y)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> name <span class="type">string</span>  <span class="comment">// 声明</span></span><br><span class="line">	<span class="keyword">var</span> age <span class="type">int</span> = <span class="number">16</span> <span class="comment">// 声明并赋值</span></span><br><span class="line">	<span class="comment">// 类型推导</span></span><br><span class="line">	<span class="keyword">var</span> s1 <span class="type">string</span> = <span class="string">&quot;string1&quot;</span></span><br><span class="line">	<span class="keyword">var</span> s2 = <span class="string">&quot;string2&quot;</span> <span class="comment">// 上面可直接写成这样</span></span><br><span class="line">	<span class="comment">// 简短变量声明，只能在函数中使用，不能在全局使用</span></span><br><span class="line">	s3 := <span class="string">&quot;string3&quot;</span> <span class="comment">// 上面的简写</span></span><br><span class="line">	fmt.Println(name, age, s1, s2, s3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>函数外每个语句必须以关键字开始（var、func、const等）</li>
<li>:= 不能用于函数外</li>
<li>_用于占位符，表示忽略值</li>
<li>函数内声明变量不使用，编译不能通过（似乎不同版本有不同的要求）</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是恒定不变的值，使用关键字const</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个声明</span></span><br><span class="line"><span class="keyword">const</span> pai = <span class="number">3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量声明</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	statusOK = <span class="number">200</span></span><br><span class="line">	notFound = <span class="number">404</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种批量声明方式，没有赋值的常量默认和上面那个值一样</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="number">200</span></span><br><span class="line">	n2</span><br><span class="line">	n3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// iota: 常量计数器, iota将在const关键字出现时重置为0，const中每新增一行常量声明将使iota计数一次（iota可以理解成const语句块的行索引）。使用iota简化定义，在定义枚举时很有用</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	n2        <span class="comment">// 1</span></span><br><span class="line">	n3        <span class="comment">// 2</span></span><br><span class="line">	n4        <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	a2        <span class="comment">// 1</span></span><br><span class="line">	_         <span class="comment">// 2</span></span><br><span class="line">	a3        <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	b1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	b2 = <span class="number">100</span>  <span class="comment">// 100</span></span><br><span class="line">	b3 = <span class="literal">iota</span> <span class="comment">// 2</span></span><br><span class="line">	b4        <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个常量声明在一行</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	c1, c2 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// d1:0+1, d2:0+2</span></span><br><span class="line">	c3, c4 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// d3:1+1, d4:1+2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// iota的应用，举个例子</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_  = <span class="literal">iota</span></span><br><span class="line">	KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型有整型、浮点型、布尔型、字符串、数组、切片、结构体、函数、map、通道等</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>int8、int16、int32、int64、uint8、uint16、uint32、uint64</p>
<p>特殊整型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uinit</td>
<td align="center">32位操作系统上就是uint32，64位操作系统上就是uint64</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是int32，64位操作系统上就是int64</td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h4 id="八进制-amp-十六进制"><a href="#八进制-amp-十六进制" class="headerlink" title="八进制&amp;十六进制"></a>八进制&amp;十六进制</h4><p>Go语言中无法直接使用二进制，关于八进制和十六进制实例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num1 = <span class="number">101</span>               <span class="comment">// 十进制</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, num1)     <span class="comment">// 输出十进制数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, num1)     <span class="comment">// 输出二进制数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, num1)     <span class="comment">// 输出八进制数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, num1)     <span class="comment">// 输出十六进制数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, num1)     <span class="comment">// 输出数据类型</span></span><br><span class="line">	<span class="keyword">var</span> num2 = <span class="number">077</span>               <span class="comment">// 八进制</span></span><br><span class="line">	<span class="keyword">var</span> num3 = <span class="number">0x123456789abcdef</span> <span class="comment">// 十六进制</span></span><br><span class="line">	<span class="comment">// 强制声明int8类型</span></span><br><span class="line">	<span class="keyword">var</span> num4 <span class="type">int8</span> = <span class="number">100</span></span><br><span class="line">	fmt.Println(num2, num3, num4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float32、float64</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f1 := <span class="number">1.2345</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f1) <span class="comment">// float64 默认go语言中小数都是float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p><code>complex128</code>和<code>complex64</code></p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>Go语言中使用<code>bool</code>类型声明布尔型，只有<code>true</code>和<code>false</code>两个值</p>
<p>注意事项：</p>
<ul>
<li>布尔型默认值是<code>false</code></li>
<li>不允许将整型强转为布尔型</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go语言中字符串内部实现使用<code>UTF-8</code>编码，字符串的值为双引号的内容。</p>
<p>Go语言单引号包裹的是字符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">&quot;嘻嘻&quot;</span></span><br><span class="line">	s2 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">	s3 := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">	s4 := <span class="string">&#x27;岳&#x27;</span></span><br><span class="line">	<span class="comment">// 字节：1字节 = 8Bit（8个二进制位）</span></span><br><span class="line">	<span class="comment">// 定义多行字符串，使用``</span></span><br><span class="line">	s5 := <span class="string">`床前明月光</span></span><br><span class="line"><span class="string">疑是地上霜</span></span><br><span class="line"><span class="string">举头望明月</span></span><br><span class="line"><span class="string">低头思故乡</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">	fmt.Print(s1, s2, s3, s4, s5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">求长度</td>
<td align="center">len（str）</td>
</tr>
<tr>
<td align="center">拼接字符串</td>
<td align="center">加号或者fmt.Sprintf()</td>
</tr>
<tr>
<td align="center">分割</td>
<td align="center">strings.Split</td>
</tr>
<tr>
<td align="center">是否包含</td>
<td align="center">strings.contains</td>
</tr>
<tr>
<td align="center">前后缀判断</td>
<td align="center">strings.HasPrefix/strings.HasSuffix</td>
</tr>
<tr>
<td align="center">子串出现的位置</td>
<td align="center">strings.Index()/strings.LastIndex()</td>
</tr>
<tr>
<td align="center">join操作</td>
<td align="center">strings.Join(a []string, sep string)</td>
</tr>
</tbody></table>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>组成字符串的元素称为<code>字符</code>，Go语言字符有两种：</p>
<ol>
<li><code>uint8</code>，或者叫<code>byte</code>类型，代表了ASCII码的一个字符</li>
<li><code>rune</code>，代表一个<code>UTF-8</code>字符，当需要表示中文、日语或者其他复合字符时，就需要用到<code>rune</code>类型。<code>rune</code>类型实际上是一个<code>int32</code></li>
</ol>
<h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>字符串是无法直接修改的，如果修改，可以转换成字符切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">&quot;岳小杨超可爱&quot;</span></span><br><span class="line">	s2 := []<span class="type">rune</span>(s1)</span><br><span class="line">	s2[<span class="number">2</span>] = <span class="string">&#x27;羊&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="type">string</span>(s2)) <span class="comment">// 将s2强制转换成string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的长度是数组类型的一部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nums [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	fmt.Println(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>如果不初始化，默认元素为零值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 方式一</span></span><br><span class="line">	<span class="keyword">var</span> nums1 = [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">	<span class="comment">// 方式二</span></span><br><span class="line">	<span class="keyword">var</span> nums2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">	<span class="comment">// 方式三</span></span><br><span class="line">	<span class="keyword">var</span> nums3 = [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [1, 2, 0, 0]</span></span><br><span class="line">	<span class="comment">// 方式四</span></span><br><span class="line">	<span class="keyword">var</span> nums4 = [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">4</span>&#125; <span class="comment">// [1, 0, 0, 4]</span></span><br><span class="line">	fmt.Println(nums1, nums2, nums3, nums4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	names := [...]<span class="type">string</span>&#123;<span class="string">&quot;岳杨&quot;</span>, <span class="string">&quot;幂律&quot;</span>, <span class="string">&quot;GO语言&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// 方式一</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(names); i++ &#123;</span><br><span class="line">		fmt.Println(names[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 方式二</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> names &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组是值类型</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 证明数组是值类型</span></span><br><span class="line">	nums1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	nums2 := nums1</span><br><span class="line">	nums2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Println(nums1, nums2) <span class="comment">// [1, 2, 3] [100, 2, 3]    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片<code>Slice</code>是一个拥有相通类型元素的可变长度的序列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nums1 []<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> nums2 []<span class="type">int</span></span><br><span class="line">	fmt.Println(nums1 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(nums2 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">	nums1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	nums2 = []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	fmt.Println(nums1 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(nums2 == <span class="literal">nil</span>) <span class="comment">// false    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="长度和容量"><a href="#长度和容量" class="headerlink" title="长度和容量"></a>长度和容量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;           <span class="comment">// 切片</span></span><br><span class="line">	nums2 := [<span class="number">7</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 数组</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d %d\n&quot;</span>, <span class="built_in">len</span>(nums1), <span class="built_in">cap</span>(nums1))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d %d\n&quot;</span>, <span class="built_in">len</span>(nums2), <span class="built_in">cap</span>(nums2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := [<span class="number">7</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 数组</span></span><br><span class="line">	nums2 := nums1[<span class="number">0</span>:<span class="number">4</span>]                  <span class="comment">// [0, 1, 2, 3] // 数组得到切片，左闭右开</span></span><br><span class="line">	nums3 := nums1[<span class="number">1</span>:]</span><br><span class="line">	nums4 := nums1[:<span class="number">4</span>]</span><br><span class="line">	nums5 := nums1[:]</span><br><span class="line">	fmt.Println(nums1, nums2, nums3, nums4, nums5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、切片是引用类型，真正的数组都是保存在底层的数组里。</p>
<p>2、一个<code>nil</code>的切片是没有底层数组的。</p>
<p>3、判断切片为空应该判断<code>len() == 0</code>。</p>
<p>4、<code>nil</code>的切片就算没有底层数组，也可以进行<code>append</code>操作，<code>append</code>会自动为<code>nil</code>切片创建空间。</p>
</blockquote>
<h4 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>) <span class="comment">// 参数：切片类型，长度，容量</span></span><br><span class="line">	fmt.Println(nums1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	nums1[<span class="number">3</span>] = <span class="number">4</span> <span class="comment">// 错误写法，切片超过容量导致编译错误：索引越界</span></span><br><span class="line">	fmt.Println(nums1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// append函数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %d %d&quot;</span>, nums1, <span class="built_in">len</span>(nums1), <span class="built_in">cap</span>(nums1)) <span class="comment">// [1, 2, 3] len=3 cap=3</span></span><br><span class="line">	nums1 = <span class="built_in">append</span>(nums1, <span class="number">4</span>)                              <span class="comment">// 调用append函数必须用原来的切片变量接收返回值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %d %d&quot;</span>, nums1, <span class="built_in">len</span>(nums1), <span class="built_in">cap</span>(nums1)) <span class="comment">// [1, 2, 3, 4] len=4 cap=6    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用<code>append</code>函数必须用原来的切片变量接收返回值，底层涉及到数组的重新分配内存空间</p>
<p><code>append</code>函数会为空切片创建内存空间，并且会对容量不够的切片进行扩容操作</p>
</blockquote>
<h2 id="fmt包"><a href="#fmt包" class="headerlink" title="fmt包"></a>fmt包</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, num)</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">&quot;String&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, str)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	expression := <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 经典用法</span></span><br><span class="line">	<span class="keyword">if</span> expression &#123;</span><br><span class="line">		<span class="comment">// 执行操作</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 执行操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 特殊用法</span></span><br><span class="line">	<span class="keyword">if</span> age := <span class="number">19</span>; age &gt; <span class="number">18</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;青年&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 执行操作</span></span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="number">3</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// 跳过for循环</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; <span class="number">6</span> &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// 跳出for循环</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> breakLabel <span class="comment">// 跳出到标签</span></span><br><span class="line">	&#125;</span><br><span class="line">breakLabel: <span class="comment">// 标签</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;跳出来了，嘻嘻&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;yueyang&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d, %c\n&quot;</span>, i, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;0&quot;</span></span><br><span class="line">	<span class="keyword">switch</span> str &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;0&quot;</span>:</span><br><span class="line">		<span class="comment">// 操作</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">		<span class="comment">// 操作</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 操作    </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> str = <span class="string">&quot;1&quot;</span>; str &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>:</span><br><span class="line">		<span class="comment">// 操作</span></span><br><span class="line">		<span class="keyword">fallthrough</span> <span class="comment">// 向下穿透一个</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>:</span><br><span class="line">		<span class="comment">// 操作</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>&amp;</code>按位与</p>
<p><code>|</code>按位或</p>
<p><code>^</code>按位异或</p>
<p><code>&lt;&lt;</code>左移</p>
<p><code>&gt;&gt;</code>右移</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>取地址操作符<code>&amp;</code></p>
<p>取值操作符<code>*</code></p>
<p>注意事项：</p>
<ul>
<li>引用类型变量不仅要声明还要分配内存空间</li>
</ul>
<p>那么就引入了两个初始化方式<code>new</code> <code>make</code></p>
<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p><code>new</code>函数不太常用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(T)</span></span> *T <span class="comment">// 接收一个类型，返回该类型的指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="make函数-1"><a href="#make函数-1" class="headerlink" title="make函数"></a>make函数</h3><p>make也是用于内存分配的，区别于new，make函数只作用于slice、map、chan类型的内存创建，由于这些类型本身就是引用类型，make返回的就是类型本身。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t <span class="type">string</span>, size ...<span class="type">int</span>)</span></span> <span class="type">string</span> <span class="comment">// 接收一个类型和容量大小，返回类型本身</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>make函数是不可替代的函数，slice、map、chan都需要make函数初始化才能进行操作。</p>
<h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><ol>
<li>两者都是用来创建内存的</li>
<li>new用于类型的内存分配，内存对应的值为类型的零值，返回的是指向类型的指针</li>
<li>make作用于slice、map、chan类型，返回类型本身</li>
</ol>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>类型定义和类型别名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewInt 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyInt 类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a NewInt</span><br><span class="line">	<span class="keyword">var</span> b MyInt</span><br><span class="line">	fmt.Println(<span class="string">&quot;%T&quot;</span>, a) <span class="comment">// main.NewInt</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;%T&quot;</span>, b) <span class="comment">// int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言通过<code>struct</code>来面向对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person Person</span><br><span class="line">	person.name = <span class="string">&quot;yueyang&quot;</span></span><br><span class="line">	person.age = <span class="number">24</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, person)  <span class="comment">// &#123;yueyang, 24&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, person) <span class="comment">// main.Person&#123;name:&quot;yueyang&quot;, age:24&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="type">string</span></span><br><span class="line">		Age  <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	user.Name = <span class="string">&quot;yueyang&quot;</span></span><br><span class="line">	user.Age = <span class="number">24</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user) <span class="comment">// struct &#123; Name string; Age int &#125;&#123;Name:&quot;yueyang&quot;, Age:24&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> person = <span class="built_in">new</span>(Person)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v&quot;</span>, *person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2、Golang标准库"><a href="#2、Golang标准库" class="headerlink" title="2、Golang标准库"></a>2、Golang标准库</h1><h2 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h2><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><blockquote>
<p>将字符串转换成整形</p>
</blockquote>
<h3 id="Itoa"><a href="#Itoa" class="headerlink" title="Itoa()"></a>Itoa()</h3><blockquote>
<p>将整形转换成字符串</p>
</blockquote>
<h3 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h3><blockquote>
<p>解析字符串成布尔类型, 可以接受1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False; 否则返回错误</p>
</blockquote>
<h3 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h3><h3 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h3><blockquote>
<p>类似于ParseInt(), 区别在于不能接受正负号, 返回uint</p>
</blockquote>
<h3 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h3><h3 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h3><h3 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h3><h3 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h3><h3 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h3><h1 id="3、异常机制"><a href="#3、异常机制" class="headerlink" title="3、异常机制"></a>3、异常机制</h1><blockquote>
<p>go中追求简洁优雅，使用多返回值来返回错误解决异常情况。只有在除数为零时，才会真正的使用异常机制，<code>defer</code>、<code>panic</code>、<code>recover</code></p>
</blockquote>
<p>底层实现看<a href="https://blog.csdn.net/shidantong/article/details/106341159">这篇文章</a></p>
<blockquote>
<p>调用 defer 关键字会立刻对函数中引用的外部参数进行拷贝</p>
</blockquote>
<h1 id="4、Golang第三方包"><a href="#4、Golang第三方包" class="headerlink" title="4、Golang第三方包"></a>4、Golang第三方包</h1><h2 id="github-com-gin-gonic-gin"><a href="#github-com-gin-gonic-gin" class="headerlink" title="github.com/gin-gonic/gin"></a>github.com/gin-gonic/gin</h2><p>gin包提供golang一个基本web框架</p>
<p>gin.Context实现了Golang标准库中的net/http下Handler接口中的唯一方法ServeHttp(ReponseWriter, *Request)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Handler responds to an HTTP request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ServeHTTP should write reply headers and data to the ResponseWriter</span></span><br><span class="line"><span class="comment">// and then return. Returning signals that the request is finished; it</span></span><br><span class="line"><span class="comment">// is not valid to use the ResponseWriter or read from the</span></span><br><span class="line"><span class="comment">// Request.Body after or concurrently with the completion of the</span></span><br><span class="line"><span class="comment">// ServeHTTP call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Depending on the HTTP client software, HTTP protocol version, and</span></span><br><span class="line"><span class="comment">// any intermediaries between the client and the Go server, it may not</span></span><br><span class="line"><span class="comment">// be possible to read from the Request.Body after writing to the</span></span><br><span class="line"><span class="comment">// ResponseWriter. Cautious handlers should read the Request.Body</span></span><br><span class="line"><span class="comment">// first, and then reply.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Except for reading the body, handlers should not modify the</span></span><br><span class="line"><span class="comment">// provided Request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</span></span><br><span class="line"><span class="comment">// that the effect of the panic was isolated to the active request.</span></span><br><span class="line"><span class="comment">// It recovers the panic, logs a stack trace to the server error log,</span></span><br><span class="line"><span class="comment">// and either closes the network connection or sends an HTTP/2</span></span><br><span class="line"><span class="comment">// RST_STREAM, depending on the HTTP protocol. To abort a handler so</span></span><br><span class="line"><span class="comment">// the client sees an interrupted response but the server doesn&#x27;t log</span></span><br><span class="line"><span class="comment">// an error, panic with the value ErrAbortHandler.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是 Golang 实现 WebService 最基础的接口，通过实现其方法来</p>
<h1 id="Golang-的编译过程"><a href="#Golang-的编译过程" class="headerlink" title="Golang 的编译过程"></a>Golang 的编译过程</h1><ol>
<li>词法和语法分析：编译器读入源代码文件，对代码进行分词和语法分析，生成语法树的数据结构。</li>
<li>AST 转换：编译器会对语法树进行一些处理和转换，例如检查类型、解析函数调用等，在此过程中还会对代码进行优化。</li>
<li>代码生成：将转换后的语法树转换成机器码或字节码，并将其打包成可执行文件或库文件。</li>
<li>链接：链接器将被引用的库文件链接到目标程序中，生成最终的可执行文件。在 Golang 中，链接过程是由 go 工具自动完成的，开发人员无需显式执行链接命令。</li>
</ol>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4java</title>
    <url>/2021/03/19/learn4java/</url>
    <content><![CDATA[<blockquote>
<p>文章记录服务端开发小白的 Java 学习过程</p>
</blockquote>
<span id="more"></span>

<h1 id="1-Java"><a href="#1-Java" class="headerlink" title="1    Java"></a>1    Java</h1><h2 id="1-1-Java-基础"><a href="#1-1-Java-基础" class="headerlink" title="1.1    Java 基础"></a>1.1    Java 基础</h2><h3 id="1-1-1-面向对象"><a href="#1-1-1-面向对象" class="headerlink" title="1.1.1    面向对象"></a>1.1.1    面向对象</h3><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul>
<li>封装：</li>
</ul>
<p>将数据的属性和方法隐藏在内部，对外提供接口。</p>
<ul>
<li>继承：</li>
</ul>
<p>将数据的非私有属性和方法传递给子类。</p>
<p>父类引用指向子类对象成为<strong>向上转型</strong>。</p>
<ul>
<li>多态：</li>
</ul>
<p>多态分为编译时多态和运行时多态：</p>
<p>编译时多态：主要是指方法的重载</p>
<p>运行时多态：主要是指对象引用所指向的具体类型需要在运行期间确定</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型：</p>
<ul>
<li><p>byte/8</p>
</li>
<li><p>short/16</p>
</li>
<li><p>int/32</p>
</li>
<li><p>long/64</p>
</li>
<li><p>float/32</p>
</li>
<li><p>double/64</p>
</li>
<li><p>boolean/1</p>
</li>
<li><p>char/16</p>
</li>
</ul>
<h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><ul>
<li><p>new Integer(123)  每次都创建新的对象；</p>
</li>
<li><p>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一对象的引用。</p>
</li>
<li><p>valueOf() 会先判断值是否在缓存池中，如果有则直接返回缓存池中的内容，如果没有则在缓存池中创建值。</p>
</li>
<li><p>编译器会在基本数据类型缓冲范围内进行自动装箱过程中调用valueOf()。</p>
</li>
<li><p>Java 8中，基本数据类型的缓冲池范围：</p>
</li>
<li><p>Byte、Short、Integer缓存池的大小默认是 -128~127。</p>
</li>
<li><p>Boolean values true and false。</p>
</li>
<li><p>Character int the range \u0000 to \u007F （符号、数字、字母）</p>
</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 被 final 声明，因此不可被继承。</p>
<p>内部使用 char[] 存储数据，被 final 修饰，因此 String 不可被修改。</p>
<h5 id="不可变的好处？为什么String不可变？"><a href="#不可变的好处？为什么String不可变？" class="headerlink" title="不可变的好处？为什么String不可变？"></a>不可变的好处？为什么String不可变？</h5><ol>
<li><p>缓存 hash 值</p>
<p>因为 String 的 hash 经常被使用，比如 HashMap 的 Key，不可变可以使 hash 值不变，只需要进行一次 hash<br>计算。</p>
</li>
<li><p>String Pool 需要</p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用<br>String Pool。</p>
</li>
<li><p>安全性</p>
</li>
<li><p>线程安全</p>
<p>因为 String 不可变，因此天生线程安全。</p>
</li>
</ol>
<h5 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h5><ol>
<li><p>可变性</p>
<ul>
<li><p>String 不可变</p>
</li>
<li><p>StringBuffer、StringBuilder 可变</p>
</li>
</ul>
</li>
<li><p>线程安全</p>
<ul>
<li>String 不可变，所以线程安全</li>
<li>StringBuilder 线程不安全</li>
<li>StringBuffer 线程安全，内部使用 synchronized 进行同步</li>
</ul>
</li>
</ol>
<h5 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h5><p>intern() 可以保证相同内容的字符串变量引用同一内存对象。</p>
<p>当 String 调用 intern() 时，如果字符串常量池中没有该值，则在字符串常量池中先创建该值，再讲常量池中的字符串引用返回；如果常量池中已经存在该值，则直接返回常量池中的字符串引用。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><p>Java中的参数传递是值传递，而不是引用传递。</p>
<h4 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h4><p>1.1默认属于 double，不能直接赋值给float，因为不能隐式向下转型</p>
<p>1.1f 才属于 float</p>
<h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><p>隐式类型转换不能向下转型，只能向上转型，就是朝着比自己范围更大的类型转型。</p>
<h4 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException`</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><ol>
<li>作用于类：无法被继承；</li>
<li>作用于方法：无法被重载；</li>
<li>作用于对象：无法被再次赋值。</li>
</ol>
<h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><ol>
<li><p>静态变量：属于类的变量，类的所有实例共享静态变量；</p>
</li>
<li><p>静态方法：类加载时就存在，所有的静态方法必须被实现（换句话说静态方法不能抽象）；</p>
</li>
<li><p>静态代码块：类初始化时运行一次；</p>
</li>
<li><p>静态内部类：非静态内部类需要依赖于外部类的实例，而静态内部类不需要；静态内部类不能访问外部类非静态方法和属性；</p>
</li>
<li><p>静态导包：在使用静态变量和方法时不需要声明 ClassName，但可读性大大降低；</p>
</li>
<li><p>初始化顺序：静态变量和静态代码块优先于普通变量和普通代码块，最后才是构造函数的初始化。以下为类初始化的加载顺序：</p>
<p>父类静态变量、父类静态代码块</p>
<p>子类静态变量、子类静态代码块</p>
<p>父类普通变量、父类普通代码块</p>
<p>父类构造函数</p>
<p>子类普通变量、子类普通代码块</p>
<p>子类构造函数</p>
</li>
</ol>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>反射可以提供运行时的类信息。</p>
<p><a href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html">反射机制详解</a></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><a href="https://pdai.tech/md/java/basic/java-basic-x-exception.html">异常机制详解</a></p>
<p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5CPPjwP.png" alt="img"></p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">泛型机制详解</a></p>
<p>泛型是JDK1.5提出的新特性，泛型提供了在编译时期的类型安全检测机制，该机制允许程序员在编译时期检测到非法的类型。泛型的本质是参数化类型，也就是说将所操作的数据类型被指定为参数。</p>
<p>泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo06</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T&gt;&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span> ; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Info</span>&lt;T&gt;&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="built_in">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo24</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arsg[])</span>&#123;  </span><br><span class="line">        Info&lt;String&gt; i = <span class="literal">null</span>;        <span class="comment">// 声明接口对象  </span></span><br><span class="line">        i = <span class="keyword">new</span> <span class="title class_">InfoImpl</span>&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getObject</span><span class="params">(Class&lt;T&gt; c)</span>&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明一下，定义泛型方法时，必须在返回值前边加一个<code>&lt;T&gt;</code>，来声明这是一个泛型方法，持有一个泛型<code>T</code><br>，然后才可以用泛型T作为方法的返回值。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p><a href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html">注解机制详解</a></p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><h5 id="Java-SE-8"><a href="#Java-SE-8" class="headerlink" title="Java SE 8"></a>Java SE 8</h5><ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<h2 id="1-2-Java-集合框架"><a href="#1-2-Java-集合框架" class="headerlink" title="1.2    Java 集合框架"></a>1.2    Java 集合框架</h2><h3 id="Collection-关系图"><a href="#Collection-关系图" class="headerlink" title="Collection 关系图"></a>Collection 关系图</h3><p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5Cjava_collections_overview.png" alt="img"></p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>基于红黑树实现，支持有序性操作。查询的时间复杂度为 O(logN)。</p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>基于哈希实现，不支持有序性操作，插入无序。查询的时间复杂度为 O(1)。</p>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>具有HashSet的查询效率，且内部使用双向链表维护元素插入顺序。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>基于数组实现，查询效率高，但在数组内部进行添加删除元素效率低。线程不安全。</p>
<p>自动扩容：每当向数组中添加元素时，都会检测添加后元素个数是否超出数组长度，如果超出，调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br></pre></td></tr></table></figure>

<p>数组进行扩容时，会将老数组的元素重新拷贝一份到新数组，每次数组增加容量为原容量的 1.5<br>倍，这种操作代价很高，所以应尽量避免数组扩容，可以采用手动调用 ensureCapacity() 方法或者初始化时指定数组容量大小。</p>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>和 ArrayList 类似，线程安全。</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>基于双向链表实现，查询效率比 ArrayList 低，但可以快速在链表中间插入和删除元素。LinkedList<br>还可以用作栈、队列、双向队列。</p>
<p>LinkedList 同时实现了 List 和 Deque 接口，所以说既可以看做是一个列表，可以以看做是一个队列。当你需要使用栈时，还可以当做栈来使用，因为<br>Java 官方已经不推荐使用 Stack 了，当然，现在使用栈时更推荐使用 ArrayDeque，它比 LinkedList 当做栈使用时效率更高。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><h5 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>可以用来做双向队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>优先队列，基于堆结构实现。优先队列的作用是每次取出的元素都是队列中权值最小的（ Java 中的优先队列取权值最小的，C++<br>中的优先队列取权值最大的）。</p>
<p>小顶堆。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>基于哈希表实现，内部数据结构为链表+数组的形式，Java 8 以后改为链表+数组+红黑树的形式。</p>
<p>HashMap的扩容。</p>
<p>HashMap的查询时间复杂度 O(1)。</p>
<h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>基于红黑树实现。</p>
<h5 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h5><p>和 HashMap 类似，在 HashMap 基础上每个方法都加了 synchronized 关键字保证线程安全，但多线程访问时会锁住整个数据结构，不推荐使用。</p>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>线程安全，相比 HashTable 效率更高，JDK1.7使用分段锁加锁，JDK1.7使用Synchronized+CAS加锁。</p>
<p>简单总结一下JDK1.8的ConcurrentHashMap的加锁机制，当头结点为空时，使用CAS机制赋值，当头结点不为空时，Synchronized锁住当前头结点，判断当前头结点和期望头结点是否一致，这个过程就像CAS机制的判断过程一暗影，如果一致，则进行赋值操作，如果不一致，则重新对头结点进行赋值预期值，重新锁住头结点，巴拉巴拉。。。其实这样做的道理很简单，因为对头结点赋值的操作和锁住头结点的操作是两个时刻的操作，如果这个过程中有其他线程对头结点进行了一些修改，那就出问题了。</p>
<h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p>使用双向链表来维护元素顺序，顺序为插入顺序或者最近最少使用顺序（LRU）。</p>
<h3 id="集合框架相关问题"><a href="#集合框架相关问题" class="headerlink" title="集合框架相关问题"></a>集合框架相关问题</h3><ol>
<li><p>Stack，ArrayDeque，LinkedList的区别</p>
<p>底层存储结构方面：</p>
<ul>
<li><p>Stack 长度为 10 的数组；</p>
</li>
<li><p>ArrayDeque 长度为 16 的数组；</p>
</li>
<li><p>LinkedList 链表。</p>
</li>
</ul>
<p>线程安全方面：</p>
<ul>
<li>Stack 线程安全</li>
<li>ArrayDeque 线程不安全</li>
<li>LinkedList 线程不安全</li>
</ul>
<p>性能选择方面：</p>
<ul>
<li>需要线程同步的话，使用 Collections.synchronizedxxx() 讲ArrayDeque 或 LinkedList 转换成线程安全的。</li>
<li>频繁插入删除，使用 LinkedList。</li>
<li>频繁随机访问，使用ArrayDeque。</li>
<li>未知初始数据容量，使用 LinkedList。</li>
</ul>
</li>
<li><p>栈和队列</p>
<p>Java 中有 Stack 的类，没有 Queue 的类（ Queue 是接口）。当使用栈时，Java 官方已经不推荐使用 Stack<br>了，而是使用效率更高的 ArrayDeque。既然 Queue 只是一个接口，当需要使用队列时，首选 ArrayDeque（次选<br>LinkedList）。</p>
</li>
</ol>
<h2 id="1-3-Java-多线程与并发"><a href="#1-3-Java-多线程与并发" class="headerlink" title="1.3    Java 多线程与并发"></a>1.3    Java 多线程与并发</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol>
<li><p>什么是死锁？</p>
<p>死锁是多个线程抢占公共资源而出现线程僵持，若无外力作用，它们都将无法继续前进。</p>
</li>
<li><p>死锁产生的原因</p>
<p>资源竞争、进程推进顺序非法</p>
</li>
<li><p>死锁产生的四个必要条件</p>
<ul>
<li>互斥条件</li>
<li>请求保持</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ul>
</li>
<li><p>预防死锁的方式</p>
<ul>
<li>资源一次性分配（破坏请求条件）</li>
<li>不能一次性得到所有资源，则一个资源也不分配（破坏保持条件）</li>
<li>可剥夺资源（破坏不可剥夺）</li>
<li>资源有序分配法</li>
</ul>
</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>创建线程池的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, // 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, // 保持时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit, // 保持时间的单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 等待队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, // 线程工厂</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>; <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure>

<p>几种常用的线程池类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Excutors.newFixdThreadPool(<span class="type">int</span> nThread); <span class="comment">// 固定线程池</span></span><br><span class="line">Excutors.newCacheThreadPool(); <span class="comment">// 无边界线程池</span></span><br><span class="line">Excutors.newSingleThreadPool(); <span class="comment">// 单线程池</span></span><br></pre></td></tr></table></figure>

<p>拒绝策略（上源码，自己悟）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that runs the rejected task</span></span><br><span class="line"><span class="comment"> * directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span></span><br><span class="line"><span class="comment"> * unless the executor has been shut down, in which case the task</span></span><br><span class="line"><span class="comment"> * is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment"> * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment"> * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;..&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment"> * rejected task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;..&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h3><p>CAS机制叫做Compare And Swap，CAS机制中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>每次更新新值会判断内存地址V得值和预期值A是否一致，一致才会更新新值B，否则自旋，重新得到预期值A和计算新值B，这样来保证线程安全。</p>
<p>从思想上来说，synchronized是悲观锁，悲观的认为并发情况极其严重，所以无论如何也保证线程安全；CAS机制是乐观锁，乐观的认为并发情况并不严重，所以无限次的去重试更新。</p>
<h4 id="CAS机制的缺点"><a href="#CAS机制的缺点" class="headerlink" title="CAS机制的缺点"></a>CAS机制的缺点</h4><ul>
<li>CPU开销过大，毕竟都乐观锁了，不断地尝试肯定对CPU有不小的开销</li>
<li>不能保证代码块的原子性</li>
<li>ABA问题：这事CAS机制最大的问题所在</li>
</ul>
<h4 id="CAS机制的ABA问题"><a href="#CAS机制的ABA问题" class="headerlink" title="CAS机制的ABA问题"></a>CAS机制的ABA问题</h4><p>A线程：内存值为200，希望更改为100</p>
<p>B线程：内存值为200，希望更改为100</p>
<p>A线程执行完了，内存值为100，但是B线程卡住了，并且C线程进来了</p>
<p>C线程：内存值为100，希望更改为200</p>
<p>C线程执行完了，内存值为200，这之后B线程好了，B读取的内存值为200，确实是和期望的值一致，并且更改了值为100</p>
<p>这就是问题所在，解决的方式就是使用<code>版本号</code></p>
<blockquote>
<p>在Java中，AtomicStampedReference类就实现了用版本号作比较额CAS机制。</p>
</blockquote>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>保证原子性、可见性、有序性</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>修饰实例方法，对当前实例对象加锁</li>
<li>修饰静态方法，对当前类的Class对象加锁</li>
<li>修饰代码块，对synchronized括号内的对象加锁</li>
</ul>
<h4 id="Synchronized实现原理"><a href="#Synchronized实现原理" class="headerlink" title="Synchronized实现原理"></a>Synchronized实现原理</h4><p>JVM通过进入和退出Monitor对象来实现方法的同步和代码块的同步。</p>
<p>方法级的同步是隐式的，无需通过字节码指令来控制，它实现在方法调用和返回操作中。调用指令在会检测方法常量表中ACC_SYNCHRONIZED标志是否被设置，如果设置了，执行线程将持有monitor，然后再执行方法，在方法完成时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit两个字节码指令，它们位于代码块的开始和结束位置，当执行到monitorenter时，当前线程尝试获取monitor对象的所有权，如果未加锁或者已经被当前线程加锁，那么就把锁的计数器+1，当执行到monitorexit时，锁的计数器-1；如果锁计数器不为0，如获取monitor所有权失败，当前线程被阻塞，直到其他线程释放锁。</p>
<p>来举个栗子！^_^</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;    <span class="comment">//这个是同步方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;		<span class="comment">//这个是同步代码块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译来瞅一眼JVM底层指令走的过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -verbose SynchronizedDemo</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">public synchronized void f();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED # 兄弟们看这里, 对于方法就是加了标识位</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=1, args_size=1</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String Hello world</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 6: 0</span><br><span class="line">      line 7: 8</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       9     0  this   Lcom/yueyang/SynchronizedDemo;</span><br><span class="line"></span><br><span class="line">public void g();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: monitorenter  # 这里这里, 代码块开头加monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #3                  // String Hello world</span><br><span class="line">       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: monitorexit</span><br><span class="line">      14: goto          22</span><br><span class="line">      17: astore_2</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: monitorexit # 这里这里, 代码块结尾加monitorexit</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: athrow</span><br><span class="line">      22: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           4    14    17   any</span><br><span class="line">          17    20    17   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 10: 0</span><br><span class="line">      line 11: 4</span><br><span class="line">      line 12: 12</span><br><span class="line">      line 13: 22</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      23     0  this   Lcom/yueyang/SynchronizedDemo;</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 17</span><br><span class="line">        locals = [ class com/yueyang/SynchronizedDemo, class java/lang/Object ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = 250 /* chop */</span><br><span class="line">        offset_delta = 4</span><br></pre></td></tr></table></figure>

<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>作用：保证可见性</p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><h4 id="Java-并发的理论知识"><a href="#Java-并发的理论知识" class="headerlink" title="Java 并发的理论知识"></a>Java 并发的理论知识</h4><ul>
<li><p>多线程的出现是要解决什么问题？</p>
<p>众所周知，IO 设备、内存、CPU 之间速度有很大差异，为了更完全的使用 CPU<br>的高性能，平衡三者之间的速度差异，CPU、操作系统、编译程序都做出了贡献：</p>
<ul>
<li>CPU 增加缓存，平衡了 CPU 与内存的速度差异。导致可见性问题</li>
<li>操作系统增加了线程、进程，复用CPU，平衡了 CPU 与 IO 设备的速度差异。导致了原子性问题</li>
<li>编译程序优化指令执行次序，使缓存合理利用。导致有序性问题</li>
</ul>
</li>
<li><p>线程不安全是指什么?</p>
<p>线程不安全指的是多个线程对共享数据进行操作，会导致多次相同操作的结果不同。</p>
</li>
<li><p>并发出现线程不安全的本质什么? 可见性，原子性，有序性</p>
<ul>
<li><p>可见性：CPU 缓存引起的</p>
</li>
<li><p>原子性：分时复用问题</p>
<p>经典的<strong>转账问题</strong>：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行<br>往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
</li>
<li><p>有序性：重排序引起</p>
</li>
</ul>
</li>
<li><p>JAVA是怎么解决并发问题的: JMM(Java内存模型)</p>
<p><a href="https://www.infoq.cn/minibook/java_memory_model">https://www.infoq.cn/minibook/java_memory_model</a></p>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="1-4-Java-IO-NIO-AIO"><a href="#1-4-Java-IO-NIO-AIO" class="headerlink" title="1.4    Java IO/NIO/AIO"></a>1.4    Java IO/NIO/AIO</h2><h2 id="1-5-Java-新版本特性"><a href="#1-5-Java-新版本特性" class="headerlink" title="1.5    Java 新版本特性"></a>1.5    Java 新版本特性</h2><h2 id="1-6-Java-JVM相关"><a href="#1-6-Java-JVM相关" class="headerlink" title="1.6    Java JVM相关"></a>1.6    Java JVM相关</h2><h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>JDK1.7：<code>堆</code>，<code>栈</code>，<code>方法区</code>，<code>程序计数器</code>，<code>本地方法栈</code></p>
<p>JDK1.8：<code>堆</code>，<code>栈</code>，<code>程序计数器</code>，<code>本地方法栈</code></p>
<p>JDK1.8将<code>方法区</code>改成<code>元空间</code>，从虚拟机内存中移出到本地内存</p>
<p>方法区也称为永久代，存放<code>静态变量</code>、<code>常量</code>、<code>类信息</code>、<code>运行时常量池</code>；</p>
<h3 id="JVM-GC"><a href="#JVM-GC" class="headerlink" title="JVM GC"></a>JVM GC</h3><h4 id="JDK1-8默认垃圾收集器"><a href="#JDK1-8默认垃圾收集器" class="headerlink" title="JDK1.8默认垃圾收集器"></a>JDK1.8默认垃圾收集器</h4><p>查看方式：Java -XX:PrintCommandLineFlags -version</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=133385472 -XX:MaxHeapSize=2134167552 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC -- 默认垃圾收集器</span><br><span class="line">java version &quot;1.8.0_281&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_281-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode)</span><br></pre></td></tr></table></figure>

<p>JDK1.8的默认值是UseParallelGC，打开此开关后，使用<code>新生代（Parallel Scavenge）</code>，<code>老年代（Ps MarkSweep）</code><br>的收集器组合进行内存回收。</p>
<p><code>新生代收集器（Parallel Scavenge）</code>是采用标记复制算法、多线程模型进行垃圾收集。</p>
<p>与其他新生代垃圾收集器的差别是，它更关注于吞吐量，而不是停顿时间。一般来说，需要与用户交互的</p>
<p>程序更关注较短的停顿时间，而如果是需要达成尽量大的吞吐量的话，则该处理器会更加适合。</p>
<p>其通过<code>-XX：UseAdaptiveSizePolicy</code>参数，可以开启其自动调节功能，适用于对垃圾收集器的调优不太了解的</p>
<p>用户。</p>
<h4 id="如何查看GC日志？"><a href="#如何查看GC日志？" class="headerlink" title="如何查看GC日志？"></a>如何查看GC日志？</h4><p>JVM参数中添加：<code>-Xloggc : gc.log</code></p>
<h1 id="2-算法"><a href="#2-算法" class="headerlink" title="2    算法"></a>2    算法</h1><h2 id="2-1-数据结构基础"><a href="#2-1-数据结构基础" class="headerlink" title="2.1    数据结构基础"></a>2.1    数据结构基础</h2><h2 id="2-2-常见排序算法"><a href="#2-2-常见排序算法" class="headerlink" title="2.2    常见排序算法"></a>2.2    常见排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSortTest</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> array[i];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt; num)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                array[i++] = array[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt; num)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                array[j--] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        array[i] = num;</span><br><span class="line">        quickSortTest(array, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSortTest(array, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3    数据库"></a>3    数据库</h1><h2 id="3-1-关系型数据库"><a href="#3-1-关系型数据库" class="headerlink" title="3.1    关系型数据库"></a>3.1    关系型数据库</h2><p>关系型数据库查询的流程：</p>
<ol>
<li><p>客户端管理器</p>
<p>当连接数据库时：</p>
<ul>
<li>验证账号密码，验证访问权限</li>
<li>检查进程是否有空余</li>
<li>检查数据库负载是否严重</li>
<li>管理器花一段时间来获取资源</li>
<li>管理器发送查询语句给查询管理器</li>
<li>得到数据后保存到缓冲区，向你发送数据</li>
</ul>
</li>
<li><p>查询管理器</p>
<ul>
<li>查询解析器：解析，并判断是否合法</li>
<li>查询重写器：预优化，避免不必要的计算，给优化器提供最佳解决方案</li>
<li>统计</li>
<li>查询优化器</li>
<li></li>
</ul>
</li>
<li><p>数据管理器</p>
</li>
<li><p>客户端管理器</p>
</li>
</ol>
<h2 id="3-3非关系型数据库"><a href="#3-3非关系型数据库" class="headerlink" title="3.3非关系型数据库"></a>3.3非关系型数据库</h2><h2 id="3-4-事务"><a href="#3-4-事务" class="headerlink" title="3.4 事务"></a>3.4 事务</h2><h3 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h3><ul>
<li><strong>原子性</strong>：要么全部执行，要么全部不执行；就像一件事一样，是不可再分的。</li>
<li><strong>一致性</strong>：事务执行前后，数据库完整性不会被破坏；就像A给B转账，A少了钱，B不可能不加钱。</li>
<li><strong>隔离性</strong>：同一时间，只允许一个事务访问同一数据；就像A取钱到结束之前，B不可能对这个账号进行转账操作。</li>
<li><strong>持久性</strong>：事务结束之后，数据永久性保存在数据库中，不能再回滚。</li>
</ul>
<h3 id="事务并发会造成问题"><a href="#事务并发会造成问题" class="headerlink" title="事务并发会造成问题"></a>事务并发会造成问题</h3><ul>
<li><p><strong>脏读</strong>：事务A读到了事务B为提交的数据，然后B回滚了，A就读多了就叫脏读。</p>
</li>
<li><p><strong>不可重复读</strong>：事务A多次读取同一数据，但是B在A多次读取同一数据过程中，修改并提交了一部分数据，导致多次读取的数据结果不一致。</p>
</li>
<li><p><strong>幻读</strong>：事务A读取数据时，事务B插入了一条不太一致的数据，导致A读取到的数据和其他数据不太一致，就像幻觉一样。</p>
<p><code>不可重复读和幻读的区别在于，不可重复读是修改一条数据，幻读是增删了数据。所以解决方案上不可重复读只需要锁住行，幻读需要锁住表。</code></p>
</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><table>
<thead>
<tr>
<th align="center">事务隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（read-uncommited）<br>（可以读取到未提交的数据）</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">读提交（read-commited）<br>（）</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可重复读（repeatable-read）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">串行化（seriallizable）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：</p>
<ul>
<li>事务隔离级别为读提交时，写数据只会锁住相应的行</li>
<li>事务隔离级别为可重复读时，如果索引条件有索引的话，默认加锁方式是next-key锁；如果没有索引，那么会锁住整张表，这样可以方式幻读</li>
<li>事务隔离级别为串行化时，读写都会锁住整张表，完全保证了事务的安全情况下也具有极低的并发性，开发中不推荐使用</li>
<li>事务隔离级别越高，越能保证数据的完整性，但是相应的对并发的影响也越大</li>
</ul>
<h3 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PROPAGATION_REQUIRED<br/>（必须是事务）</td>
<td align="center">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td align="center">PROPAGATION_SUPPORTS<br>（支持事务，没有就算了）</td>
<td align="center">支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td align="center">PROPAGATION_MANDATORY<br>（强制性，如果没有事务报错）</td>
<td align="center">使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td align="center">PROPAGATION_REQUIRES_NEW<br>（必须新建，原来有事务就等着）</td>
<td align="center">新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NOT_SUPPORTED<br>（不支持事务，原来有事务就等着）</td>
<td align="center">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NEVER<br>（从不，不能以事务方式执行）</td>
<td align="center">以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NESTED<br>（嵌套，作为原事务中的一个子事务）</td>
<td align="center">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<h1 id="4-Spring"><a href="#4-Spring" class="headerlink" title="4    Spring"></a>4    Spring</h1><p>IOC</p>
<p>PCG中台</p>
<p>9500</p>
<p>Spring声明周期：</p>
<p>Bean定义、实例化前、实例化、实例化后、属性注入、初始化前、初始化、初始化后、得到Bean。</p>
<p>Spring三级缓存：</p>
<p>一级缓存：单例池，singletonObjects，存放成熟的Bean</p>
<p>二级缓存：earlySingletonObjects，存放循环依赖过程中不完整的Bean</p>
<p>三级缓存：AOP</p>
<p>单例Bean：可以通过唯一ID来定位唯一实例的Bean对象</p>
<p>单例池：单例Bean的实现方式，使用Map实现，key是beanName，value是bean对象</p>
<p>单例模式：一种设计模式，程序运行期间只存在一个实例</p>
<h1 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5    设计模式"></a>5    设计模式</h1><h2 id="5-1-策略模式"><a href="#5-1-策略模式" class="headerlink" title="5.1    策略模式"></a>5.1    策略模式</h2><p>废话不多说，上代码来理解吧，人类的语言很难将设计模式讲明白，起码我不行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateAdd</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateSubtract</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateMultiply</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPatternDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperateAdd</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperateSubtract</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperateMultiply</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心思想</strong>：<code>抽象实现共性，接口实现特性</code></p>
<p>多使用行为特性的组合，少用共性抽象，这样更有弹性。</p>
<hr>
<h1 id="等待解决的面试题"><a href="#等待解决的面试题" class="headerlink" title="等待解决的面试题"></a>等待解决的面试题</h1><ul>
<li><p><input disabled="" type="checkbox">  了解一下 sonrt</p>
</li>
<li><p><input disabled="" type="checkbox">  了解一下 kafka</p>
</li>
<li><p><input disabled="" type="checkbox">  数据库：引擎、索引、事务、锁</p>
</li>
<li><p><input disabled="" type="checkbox">  计算机网络：TCP、UDP</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲 redis</p>
</li>
<li><p><input disabled="" type="checkbox">  面向对象的理解、面向过程的理解、多态的理解</p>
</li>
<li><p><input disabled="" type="checkbox">  深拷贝和浅拷贝，进行深拷贝的方式有那些？</p>
</li>
<li><p><input disabled="" type="checkbox">  讲一讲集合：List、Set、Map、ArrayList、LinkedList</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲泛型，如何使用？举个例子</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲异常</p>
</li>
<li><p><input disabled="" type="checkbox">  计算机网络分几层？分别使用什么协议？</p>
</li>
<li><p><input disabled="" type="checkbox">  MySql 事务特性的理解，并发问题，隔离级别</p>
</li>
<li><p><input disabled="" type="checkbox">  讲讲 cookie和session的区别、作用</p>
</li>
<li><p><input disabled="" type="checkbox">  linux常用命令：如何查看可用端口？lsof -i 和 netstat -aptn；如何查看日志？tail -f 、less、cat</p>
</li>
<li><p><input disabled="" type="checkbox">  什么是幂等？什么情况下需要考虑幂等？我是怎么解决幂等的？</p>
</li>
<li><p><input disabled="" type="checkbox">  多个线程同时读写，读线程的数量远远大于写线程，你认为应该如何解决<br>并发的问题？你会选择加什么样的锁？ReentrantReadWriteLock 读写锁；</p>
</li>
<li><p><input disabled="" type="checkbox">  JAVA的AQS是否了解，它是⼲嘛的？AbstractQueuedSynchronizer</p>
</li>
<li><p><input disabled="" type="checkbox">  除了synchronized关键字之外，你是怎么来保障线程安全的？加锁啊，就上面那个问题</p>
</li>
<li><p><input disabled="" type="checkbox">  什么时候需要加volatile关键字？它能保证线程安全吗？答案：在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：</p>
<ol>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>
</li>
<li><p>变量不需要与其他状态变量共同参与不变约束</p>
<p>能保证可见性、有序性，不能保证原子性，所以不能完全保证线程安全。</p>
</li>
</ol>
</li>
<li><p><input disabled="" type="checkbox">  线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部 塞满了之后，还是忙，再提交会发⽣什么？</p>
</li>
<li><p><input disabled="" type="checkbox">  TCP和UDP的区别？TCP可靠稳定传输慢，UDP迅速大量不可靠</p>
</li>
<li><p><input disabled="" type="checkbox">  互联网公司的分布式ID的生成策略？Redis生成ID并持久化、雪花算法</p>
</li>
<li><p><input disabled="" type="checkbox">  MySQL事务相关知识</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4linux</title>
    <url>/2022/05/01/learn4linux/</url>
    <content><![CDATA[<blockquote>
<p>整理 linux 的学习过程, 尝试通过单词全拼来理解命令含义</p>
</blockquote>
<span id="more"></span>

<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ol>
<li>cal = CALendar calendar 日历</li>
<li>cat = CATenate 链接 <code>该更多的情况是将文件内容输出以及合并多个文件内容</code></li>
<li>cd = Change Directory 更改目录</li>
<li>chgrp = CHange GRouP 改变组</li>
<li>chmod = CHange MODe 改变模式</li>
<li>chown = CHange OWNer 更改所有者</li>
<li>chsh = CHange SHell 更改壳</li>
<li>cmp = compare 比较</li>
<li>comm = common 常见的</li>
<li>cp = CoPy 复制</li>
<li>cpio = CoPy In and Out 拷贝进出<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录以及所有子目录中查找文件, 并将它们放入名为 archive.cpio 的归档文件中</span></span><br><span class="line">find . -depth -print | cpio -ov &gt; archive.cpio</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令会从名为 archive.cpio 的归档文件中提取所有文件, 并解压到当前目录中</span></span><br><span class="line">cpio -idv &lt; archive.cpio</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令会列出名为 archive.cpio 的归档文件中包含的所有文件列表</span></span><br><span class="line">cpio -itv &lt; archive.cpio</span><br></pre></td></tr></table></figure></li>
<li>cpp = C Pre Processor C预处理器</li>
<li>cron = Chronos 希腊文时间, 用于执行定时任务<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">cron 的配置文件为 /etc/crontab, 这个文件定义了系统级别的计划任务. 而每个用户都可以使用 crontab 命令来创建自己的计划任务表(也就是 crontab 文件), 这些任务只对该用户有效</span><br></pre></td></tr></table></figure></li>
<li>daemon = Disk And Execution MONitor 磁盘和执行监视器</li>
<li>dc = Desk Calculator 桌上计算器(逆波兰式计算器)</li>
<li>dd = Disk Dump 磁盘转储</li>
<li>df = Disk Free 查看磁盘空间使用情况<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h # 选项表示以可读的方式输出结果, 易于阅读</span><br></pre></td></tr></table></figure></li>
<li>diff = DIFFerence 差异<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本语法</span></span><br><span class="line">diff file1 file2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">额外参数</span></span><br><span class="line">diff -c file1 file2 # 以上下文模式输出差异信息</span><br><span class="line">diff -u file1 file2 # 以合并模式输出差异信息</span><br><span class="line">diff -i file1 file2 # 忽略大小写进行比较</span><br><span class="line">diff -B file1 file2 # 忽略空格进行比较</span><br><span class="line">diff -w file1 file2 # 忽略所有空白字符进行比较</span><br></pre></td></tr></table></figure></li>
<li>du = Disk Usage 磁盘使用<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">du [-Aclnx] [-H | -L | -P] [-g | -h | -k | -m] [-a | -s | -d depth] [-B blocksize] [-I mask] [-t threshold] [file ...]</span><br><span class="line"></span><br><span class="line">下面对这些参数和选项进行一一解释：</span><br><span class="line">-A : 将大文件(超过2GB)的大小正确计算为1KB, 而不是512字节；</span><br><span class="line">-c : 显示指定文件或目录总共的大小；</span><br><span class="line">-l : 统计符号链接占据磁盘空间的大小, 而不是链接指向的文件的大小；</span><br><span class="line">-n : 不递归显示大小；</span><br><span class="line">-x : 显示当前文件系统的大小, 不会统计挂载在其上的其他文件系统的大小；</span><br><span class="line">-H : 递归处理命令行中指定的目录, 当遇到符号链接时, 直接使用链接所指向的文件的大小；</span><br><span class="line">-L : 与 -H 类似, 但是当遇到符号链接时, 直接计算链接本身的大小；</span><br><span class="line">-P : 与 -H 和 -L 相反, 不跟踪任何符号链接, 直接计算链接本身的大小；</span><br><span class="line">-g, -h, -k, -m : 以不同的大小单位显示输出结果(用于人类可读)</span><br><span class="line">-a : 显示所有文件和目录的大小；</span><br><span class="line">-s : 只显示目录总大小, 不显示各子目录和文件的大小；</span><br><span class="line">-d depth : 指定显示目录树的深度, 即子目录的最大层数；</span><br><span class="line">-B blocksize : 指定块大小, 以字节为单位；</span><br><span class="line">-I mask : 指定忽略某些文件或目录(按照 shell 的语法来进行匹配)；</span><br><span class="line">-t threshold : 只对大于或等于指定大小的文件和目录进行计算磁盘空间使用情况</span><br><span class="line"></span><br><span class="line">注意：在使用 du 命令时, 请谨慎选择文件或目录, 不要将它用于根目录 (&quot;/&quot;) 或 &quot;/home&quot; 等包含大量文件的目录, 否则可能会导致系统崩溃或性能下降</span><br></pre></td></tr></table></figure></li>
<li>ed = editor 编辑</li>
<li>egrep = Extended GREP 扩展的grep</li>
<li>emacs = Editor MACroS 编辑宏, 一款强大的编辑器, 和 vim 并称两大最强编辑器</li>
<li>eval = EVALuate 用于将命令行参数作为 shell 命令来执行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mycmd=&quot;ls&quot; &amp;&amp; eval result=$mycmd &amp;&amp; echo $result</span><br></pre></td></tr></table></figure></li>
<li>ex = EXtended 是一个文本编辑器, 是 vi 编辑器的前身. ex 编辑器相对来说比较老旧, 因为现在更常用的文本编辑器是 vi、nano、emacs 等</li>
<li>exec = EXECute 执行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">它用于执行一个命令并替换当前 shell 进程(即将当前进程替换为指定命令). <span class="built_in">exec</span> 命令通常在 shell 脚本中使用, 可以用于执行其他程序并将其输出/错误输出重新定向到脚本中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体来说, 当你执行 <span class="built_in">exec</span> 命令时, 它会首先关闭当前的 shell 进程, 然后创建一个新的进程来运行指定的命令, 这个新的进程将继承当前 shell 进程的环境变量和文件描述符等信息。因此, 通过 <span class="built_in">exec</span> 命令可以让脚本中的命令取代 shell 进程, 从而达到更高效的执行效果。</span></span><br></pre></td></tr></table></figure></li>
<li>fd = file descriptors 文件描述符</li>
<li>fg = ForeGround 前景</li>
<li>fgrep = Fixed GREP 固定grep(非正则表达式匹配)</li>
<li>fish = the Friendly Interactive SHell 是一款现代化的、用户友好的命令行 Shell</li>
<li>file = file 查看文件类型, 是否是二进制等</li>
<li>fmt = format 格式化文件</li>
<li>grep = Global Regular Expression Print 全局正则表达式打印</li>
<li>ksh = Korn SHell 是一个Unix和Linux系统上的命令行解释器和编程语言。它是由David Korn开发的，旨在提供一种功能更强大的shell，用于代替传统的Bourne shell和C shell。</li>
<li>lex = LEXical analyser 词法分析器</li>
<li>ln = LiNk</li>
<li>ls = list 列出当前或指定目录下的文件和目录<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l # 以长格式列出文件和目录信息，包括文件类型、权限、拥有者、大小、日期等</span><br><span class="line">ls -a # 列出所有文件和目录，包括 . 开头的隐藏文件和目录</span><br><span class="line">ls -h # 以易读的方式显示文件和目录的大小</span><br><span class="line">ls -t # 按修改时间排序，最近修改的文件或目录先显示</span><br><span class="line">ls -r # 反向排序，从后往前排列</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$ <span class="built_in">which</span> <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span>: aliased to <span class="built_in">ls</span> -G</span></span><br></pre></td></tr></table></figure></li>
<li>lsof = LiSt Open Files 列出打开的文件, 并显示哪些进程打开了这些文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -p 100     # 显示指定 PID 的进程打开的文件信息。</span><br><span class="line">lsof -u yueyang # 显示指定用户打开的文件信息</span><br><span class="line">lsof -c name    # 列出指定进程名字的进程打开的所有文件</span><br><span class="line">lsof -i         # 列出所有网络连接相关的文件</span><br><span class="line">lsof -n         # 不进行DNS解析，直接使用IP地址</span><br></pre></td></tr></table></figure></li>
<li>make = make 配合 makefile 使用的命令行工具</li>
<li>man = MANual pages 手册, 用于查看帮助文档</li>
<li>mc = Midnight Commander “午夜指挥官”, 可用于浏览和管理Linux或Unix操作系统中的文件和目录</li>
<li>mkfs = MaKe FileSystem 使文件系统</li>
<li>mknod = MaKe NODe 使节点</li>
<li>motd = Message of The Day 当天的信息</li>
<li>mozilla = MOsaic GodZILLa</li>
<li>mtab = Mount TABle 安装表</li>
<li>mv = MoVe</li>
<li>nano = Nano’s ANOther editor 纳米的另一个编辑</li>
<li>nawk = New AWK</li>
<li>nl = Number of Lines</li>
<li>nm = names</li>
<li>nohup = No HangUP 用于运行一个命令，使其不受终端关闭或网络中断的影响而继续在后台运行</li>
<li>nroff = New ROFF</li>
<li>od = Octal Dump 该命令的名称由来</li>
<li>passwd = PASSWorD</li>
<li>pg = pager</li>
<li>pico = PIne’s message COmposition editor 松的消息组合编辑器</li>
<li>pine = “Program for Internet News &amp; Email” = “Pine is not Elm”</li>
<li>ping = Packet InterNet Groper ping程序</li>
<li>pirntcap = PRINTer CAPability 打印机的能力</li>
<li>popd = POP Directory</li>
<li>pr = pre</li>
<li>printf = PRINT Formatted</li>
<li>ps = Processes Status 展示进程信息 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps      # 列出当前终端下所有进程的信息。</span><br><span class="line">ps -e   # 列出系统上所有进程的信息，不仅限于当前终端。</span><br><span class="line">ps -f   # 以全格式列出进程的信息，包括进程的UID、PID、PPID、C、STIME、TTY、TIME和CMD等。</span><br><span class="line">ps -aux # 列出所有进程信息，包括其他用户的进程，并显示更详细的CPU和内存占用情况。</span><br><span class="line">ps -ejH # 列出所有进程及其子进程，用树状结构表示。</span><br><span class="line">ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm # 自定义显示进程的信息，包括进程的PID、线程ID、调度类、实时优先级、静态优先级、绑定的处理器、CPU占用率、进程状态、等待的系统调用和进程命令等。</span><br></pre></td></tr></table></figure></li>
<li>pty = pseudo tty</li>
<li>pushd = PUSH Directory</li>
<li>pwd = Print Working Directory 打印工作目录</li>
<li>rc = runcom = run command</li>
<li>rev = REVerse</li>
<li>rm = ReMove</li>
<li>rn = Read News</li>
<li>roff = RunOFF</li>
<li>rpm = RPM Package Manager = RedHat Package Manager    RedHat软件包管理器</li>
<li>rsh, rlogin, rvim中的r = Remote</li>
<li>rxvt = ouR XVT</li>
<li>seamoneky = 我</li>
<li>sed = Stream EDitor</li>
<li>seq = SEQuence</li>
<li>shar = SHell ARchive</li>
<li>slrn = S-Lang rn</li>
<li>ssh = Secure SHell</li>
<li>ssl = Secure Sockets Layer</li>
<li>stty = Set TTY</li>
<li>su = Substitute User 或 Switch User(前者较常见)</li>
<li>sudo = superuser / substitue user do 在ubuntu下更倾向于superuser, 因为它代表了root权限</li>
<li>svn = SubVersioN</li>
<li>tar = Tape ARchive</li>
<li>tcsh = TENEX C shell</li>
<li>tee = T (T形水管接口)</li>
<li>telnet = TEminaL over Network</li>
<li>termcap = terminal capability</li>
<li>terminfo = terminal information</li>
<li>tex = τέχνη的缩写, 希腊文art</li>
<li>tr = translate</li>
<li>troff = Typesetter new ROFF 照排机新Roff</li>
<li>tsort = Topological SORT</li>
<li>tty = TeleTypewriter</li>
<li>twm = Tom’s Window Manager</li>
<li>tz = TimeZone</li>
<li>udev = Userspace DEV</li>
<li>ulimit = User’s LIMIT</li>
<li>umask = User’s MASK</li>
<li>uniq = UNIQue</li>
<li>vi = VIsual = Very Inconvenient 很不方便</li>
<li>vim = Vi IMproved</li>
<li>wall = write all</li>
<li>wc = Word Count</li>
<li>wine = WINE Is Not an Emulator 酒不是一个模拟器</li>
<li>xargs = eXtended ARGuments 扩展参数</li>
<li>xdm = X Display Manager X显示管理器</li>
<li>xlfd = X Logical Font Description 逻辑字体描述</li>
<li>xmms = X Multimedia System X多媒体系统</li>
<li>xrdb = X Resources DataBase X资源数据库</li>
<li>xwd = X Window Dump X窗口转储</li>
<li>yacc = yet another compiler compiler 另一个编译器的编译器</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4mongo</title>
    <url>/2020/08/27/learn4mongo/</url>
    <content><![CDATA[<blockquote>
<p>  MongoDB的一些基本操作，只适用于日常开发，深入了解MongoDB请略过本文</p>
</blockquote>
<span id="more"></span>

<h1 id="Mongo数据库操作"><a href="#Mongo数据库操作" class="headerlink" title="Mongo数据库操作"></a>Mongo数据库操作</h1><p>在学习Mongo之后因为没有系统的做过总结，就想在此写一篇比较系统比较全面的日常操作数据库的SQL操作总结。本文实时补充</p>
<p>增</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>添加语句</span><br><span class="line"></span><br><span class="line">db.COLLECTION_NAME.insert(document)</span><br><span class="line"></span><br><span class="line">db.data.insert(&#123;</span><br><span class="line">	title:<span class="string">&#x27;测试添加操作&#x27;</span>,</span><br><span class="line">	<span class="keyword">by</span>:<span class="string">&#x27;YueYang&#x27;</span>,</span><br><span class="line">	<span class="type">time</span>:<span class="string">&#x27;11:08&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : <span class="number">1</span>, &quot;writeConcernError&quot; : [ ] &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>删</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除操作</span><br><span class="line"></span><br><span class="line">db.collection.remove(</span><br><span class="line">   <span class="operator">&lt;</span>query<span class="operator">&gt;</span>,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span>,</span><br><span class="line">     writeConcern: <span class="operator">&lt;</span>document<span class="operator">&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.data.remove(&#123;</span><br><span class="line">	<span class="keyword">by</span>:<span class="string">&#x27;YueYang&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">WriteResult(&#123; &quot;nRemoved&quot; : <span class="number">1</span>, &quot;writeConcernError&quot; : [ ] &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 更改操作</span><br><span class="line"></span><br><span class="line">db.collection.update(</span><br><span class="line">   <span class="operator">&lt;</span>query<span class="operator">&gt;</span>,</span><br><span class="line">   <span class="operator">&lt;</span><span class="keyword">update</span><span class="operator">&gt;</span>,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span>,</span><br><span class="line">     multi: <span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span>,</span><br><span class="line">     writeConcern: <span class="operator">&lt;</span>document<span class="operator">&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.data.update(&#123;&quot;title&quot;:&quot;测试添加操作&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;&quot;title&quot;:&quot;测试更新操作&quot;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	&quot;nMatched&quot; : <span class="number">1</span>,</span><br><span class="line">	&quot;nUpserted&quot; : <span class="number">0</span>,</span><br><span class="line">	&quot;nModified&quot; : <span class="number">1</span>,</span><br><span class="line">	&quot;writeConcernError&quot; : [ ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.data.update(&#123;&quot;title&quot;:&quot;测试添加操作&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;&quot;title&quot;:&quot;测试更新操作&quot;&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">WriteResult(&#123;</span><br><span class="line">	&quot;nMatched&quot; : <span class="number">2</span>,</span><br><span class="line">	&quot;nUpserted&quot; : <span class="number">0</span>,</span><br><span class="line">	&quot;nModified&quot; : <span class="number">2</span>,</span><br><span class="line">	&quot;writeConcernError&quot; : [ ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询操作</span><br><span class="line"></span><br><span class="line">db.data.find(&#123;&quot;by&quot;:&quot;YueYang&quot;&#125;);</span><br><span class="line"></span><br><span class="line">_id            				title    	<span class="keyword">by</span>		<span class="type">time</span></span><br><span class="line"><span class="number">5</span>dafd24abc1b000007001bf7	测试更新操作	YueYang	<span class="number">11</span>:<span class="number">08</span></span><br><span class="line"><span class="number">5</span>dafd2e5bc1b000007001bf8	测试更新操作	YueYang	<span class="number">12</span>:<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>条件查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">大于		 $gt</span><br><span class="line">小于		 $lt</span><br><span class="line">大于等于 	gte</span><br><span class="line">小于等于	$lte</span><br><span class="line">不等于		 $ne</span><br><span class="line">等于		  $eq</span><br><span class="line">包含于 	 $<span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.data.find(&#123;age: &#123;$gt : <span class="number">18</span>&#125;&#125;); <span class="comment">-- select * from data where age &gt; 18;</span></span><br></pre></td></tr></table></figure>

<p>模糊查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询 title 包含&quot;测试&quot;字的文档：</span><br><span class="line">db.data.find(&#123;title:<span class="operator">/</span>测试<span class="operator">/</span>&#125;);</span><br><span class="line"></span><br><span class="line">查询 title 字段以&quot;教&quot;字开头的文档：</span><br><span class="line">db.data.find(&#123;title:<span class="operator">/</span><span class="operator">^</span>测试<span class="operator">/</span>&#125;);</span><br><span class="line"></span><br><span class="line">查询 titl e字段以&quot;教&quot;字结尾的文档：</span><br><span class="line">db.data.find(&#123;title:<span class="operator">/</span>教$<span class="operator">/</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>模糊查询查询字段掌握了正则表达式就很容易扩展出来啦~<br>三种正则表达式方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&#123; <span class="operator">&lt;</span> field <span class="operator">&gt;</span>： &#123; $ regex ： <span class="operator">/</span> <span class="keyword">pattern</span> <span class="operator">/</span> ， $ options ： ‘’ &#125; &#125;</span><br><span class="line">&#123; <span class="operator">&lt;</span> field <span class="operator">&gt;</span>： &#123; $ regex ： ‘<span class="keyword">pattern</span>’ ， $ options ： ‘’ &#125; &#125;</span><br><span class="line">&#123; <span class="operator">&lt;</span> field <span class="operator">&gt;</span> ： &#123; $ regex ： <span class="operator">/</span> <span class="keyword">pattern</span> <span class="operator">/</span> <span class="operator">&lt;</span> options <span class="operator">&gt;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 数据排序</span><br><span class="line"></span><br><span class="line">db.data.find().sort(&#123;title:<span class="number">1</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 其中 <span class="number">1</span> 为升序排列，而 <span class="number">-1</span> 是用于降序排列</span><br></pre></td></tr></table></figure>

<p>分组操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.data.aggregate([&#123;</span><br><span class="line">    $<span class="keyword">group</span>: &#123;</span><br><span class="line">        _id: &#123;</span><br><span class="line">            title: <span class="string">&#x27;$title&#x27;</span>,</span><br><span class="line">            <span class="keyword">by</span>: <span class="string">&#x27;$by&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        count: &#123;</span><br><span class="line">            $sum: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    $<span class="keyword">match</span>: &#123;</span><br><span class="line">        count: &#123;</span><br><span class="line">            $gt: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">$<span class="keyword">group</span></span><br><span class="line">将集合中的文档分组，可用于统计结果</span><br><span class="line">_id表示分组的依据，使用某个字段的格式为<span class="string">&#x27;$字段&#x27;</span>。</span><br><span class="line"></span><br><span class="line">$<span class="keyword">match</span></span><br><span class="line">用于过滤数据，只输出符合条件的文档</span><br></pre></td></tr></table></figure>

<p>删除重复数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 前面写查询语句，对结果数据进行去重</span><br><span class="line">.forEach(<span class="keyword">function</span>(it) &#123;</span><br><span class="line">    it.dups.shift();</span><br><span class="line">    db.data.remove(&#123;</span><br><span class="line">        _id: &#123;</span><br><span class="line">            $<span class="keyword">in</span>: it.dups</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>删除_id失败？</p>
<p>对id直接进行remove删除失败，是因为id是ObjectId类型，而id是字符串类型，类型对应不上就会导致删除失败。</p>
<p>解决方法就是把id转换成ObjectId：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.data.remove(&#123;_id:ObjectId(<span class="string">&#x27;1013&#x27;</span>)&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化笔记</title>
    <url>/2021/05/31/learn4mysql/</url>
    <content><![CDATA[<blockquote>
<p>最近更新时间：2021-05-31 09:41:56</p>
</blockquote>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SQL优化一般遵循五个原则：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">减少数据访问</span><br><span class="line">返回更少的数据：只返回需要的字段和数据分页处理，减少磁盘IO和网络IO</span><br><span class="line">减少交互次数：批量DML操作，来减少与数据库的交互次数</span><br><span class="line">减少服务器CPU开销：减少数据库排序操作以及全表查询，减少CPU内存占用</span><br><span class="line">利用更多资源：使用表分区，增加并行操作，最大限度使用CPU资源</span><br></pre></td></tr></table></figure>

<p>总结一下就是</p>
<blockquote>
<ul>
<li>最大化利用索</li>
<li>尽可能避免全表扫描</li>
<li>减少无效数据的查询</li>
</ul>
</blockquote>
<h1 id="SELECT语句——语法顺序"><a href="#SELECT语句——语法顺序" class="headerlink" title="SELECT语句——语法顺序"></a>SELECT语句——语法顺序</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="operator">&lt;</span>查询字段<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">left</span> <span class="operator">/</span> <span class="keyword">right</span> <span class="keyword">join</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>分组字段<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;</span>分组条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>排序字段<span class="operator">&gt;</span></span><br><span class="line">    limit <span class="operator">&lt;</span>参数<span class="number">1</span>, 参数<span class="number">2</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="SELECT语句——执行顺序"><a href="#SELECT语句——执行顺序" class="headerlink" title="SELECT语句——执行顺序"></a>SELECT语句——执行顺序</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="comment">-- 选取表, 如果是多个表通过笛卡尔积形成一个表</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span> <span class="comment">-- 对from的表进行筛选</span></span><br><span class="line"><span class="keyword">join</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="comment">-- 添加字段到on之后的结果中</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span> <span class="comment">-- 对结果再进行筛选</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>分组字段<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;</span>分组条件<span class="operator">&gt;</span> <span class="comment">-- 对分组之后的结果再进行筛选</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>字段<span class="operator">&gt;</span> <span class="comment">-- 筛选列, 返回的单列必须在group by中</span></span><br><span class="line">    <span class="keyword">distinct</span>  <span class="comment">-- 数据去重</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>排序字段<span class="operator">&gt;</span> <span class="comment">-- 排序</span></span><br><span class="line">    limit <span class="comment">-- 行数限制</span></span><br></pre></td></tr></table></figure>

<h1 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h1><h3 id="一、避免不走索引的场景"><a href="#一、避免不走索引的场景" class="headerlink" title="一、避免不走索引的场景"></a>一、避免不走索引的场景</h3><ol>
<li><p>避免在<code>字段开头模糊查询</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 尽量避免</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%岳%&#x27;</span></span><br><span class="line"><span class="comment">-- 优化方式</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;岳%&#x27;</span></span><br><span class="line"><span class="comment">-- 如果必须要在字段开头模糊查询, 建议使用以下策略:</span></span><br><span class="line"><span class="comment">-- 1. 使用FullText全文检索</span></span><br><span class="line"><span class="comment">-- 2. 数据量较大时使用ElasticSearch</span></span><br><span class="line"><span class="comment">-- 3. 使用MySQL内置函数INSTR(str,substr)来匹配</span></span><br><span class="line"><span class="comment">-- 4. 如果数据量少, 就不用花里胡哨的使用策略了, 直接%%</span></span><br></pre></td></tr></table></figure></li>
<li><p>避免使用<code>or</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;yueyang&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;mengwu&#x27;</span></span><br><span class="line"><span class="comment">-- 推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;yueyang&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;mengwu&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>避免<code>进行null值判断</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 优化方式:给字段设置默认值</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>避免<code>在where条件等号左侧使用表达式</code>，会放弃索引而全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score<span class="operator">/</span><span class="number">10</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="comment">-- 优化方式:把左侧表达式的操作移到右侧</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> score <span class="operator">=</span> <span class="number">8</span> <span class="operator">*</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二、SELECT-语句优化"><a href="#二、SELECT-语句优化" class="headerlink" title="二、SELECT 语句优化"></a>二、SELECT 语句优化</h3><ol>
<li><p>禁止出现<code>select *</code>，需要哪些字段必须明确标明， 原因是：</p>
<ol>
<li>增加了查询分析器解析成本</li>
<li>容易与resultMap配置不一致</li>
<li>无用字段增加了网络IO</li>
</ol>
</li>
<li><p>多表关联查询时，小表在前，大表在后</p>
<p>多表关联查询会全表扫描第一张表，所以第一张表尽可能小会提升不少性能</p>
</li>
<li><p>使用表的别名</p>
<p>SQL连接多个表时，使用表的别名并用表的别名来指定字段会减少解析时间</p>
</li>
</ol>
<h3 id="三、DML-语句优化"><a href="#三、DML-语句优化" class="headerlink" title="三、DML 语句优化"></a>三、DML 语句优化</h3><ol>
<li><p>批量<code>insert</code>数据使用<code>insert</code>多个值的方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, name, age) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;yueyang&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, name, age) <span class="keyword">values</span> (<span class="number">2</span>, <span class="string">&#x27;mengwu&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">-- 推荐</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, name, age) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;yueyang&#x27;</span>, <span class="number">18</span>),(<span class="number">2</span>, <span class="string">&#x27;mengwu&#x27;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四、查询条件优化"><a href="#四、查询条件优化" class="headerlink" title="四、查询条件优化"></a>四、查询条件优化</h3><ol>
<li><p>对于复杂查询，使用中间表暂存数据</p>
</li>
<li><p>优化<code>group by</code>语句</p>
<p>默认情况下, MySQL会对<code>group by</code>中所有的值进行排序，也就相当于在后面添加了一段<code>order by</code></p>
<p>因此，查询<code>group by</code>如果你不想对分组数据进行排序，可以在最后加上<code>order by null</code></p>
</li>
<li><p>优化<code>join</code>语句</p>
<p>对于逻辑顺畅的子查询来说，有时使用<code>join</code>替代会有更好的效率</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询没有成绩的学生ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> id <span class="keyword">from</span> grade <span class="keyword">where</span> score <span class="operator">=</span> <span class="number">0</span>);</span><br><span class="line"><span class="comment">-- 优化方式:减少了内存创建临时表的损耗 </span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> grade <span class="keyword">on</span> user.id <span class="operator">=</span> grade.id <span class="keyword">where</span> grade.socre <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>优化<code>union</code>语句</p>
<p>MySQL通过创建临时表并填充临时表的方式来执行<code>union</code>查询。</p>
<p>使用<code>union</code>时，会隐式的给临时表加<code>distinct</code><br>，从而对整个临时表做唯一性校验，非常损耗性能。因此如果不是非要去重，非常不建议使用<code>union</code><br>，建议改成<code>union all</code>。</p>
</li>
<li><p>合理的分页方式进行分页优化（^_^这个地方我还没学会呢，大家自己去研究深入一下，欢迎给我留言）</p>
</li>
</ol>
<h3 id="五、建表优化"><a href="#五、建表优化" class="headerlink" title="五、建表优化"></a>五、建表优化</h3><ol>
<li><p>在表中建立<code>索引</code>，优先考虑<code>where</code>、<code>order by</code>使用到的字段。</p>
</li>
<li><p>尽量使用数字型字段</p>
<p>举个例子：性别男（1）女（2），就不要设计成字符型字段，会增加查询和连接性能，并增加存储开销</p>
</li>
</ol>
<h3 id="六、事务优化"><a href="#六、事务优化" class="headerlink" title="六、事务优化"></a>六、事务优化</h3><ol>
<li><pre><code class="mysql"> -- 查询事务执行的锁情况
 select * from INFORMATION_SCHEMA.INNODB_TRX;
</code></pre>
</li>
</ol>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MVCC: 多版本并发控制技术的英文全称是 Multiversion Concurrency Control，简称 MVCC。</p>
<p>多版本并发控制（MVCC） 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4network</title>
    <url>/2023/01/30/learn4network/</url>
    <content><![CDATA[<blockquote>
<p>阅读《网络是怎么连接的》的阅读笔记, 目的是帮助阅读者更快的获得书中所有有价值的信息。</p>
</blockquote>
<span id="more"></span>

<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>名词介绍</p>
<p>TCP：传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">为啥老是说 TCP/IP 协议呢?</span><br><span class="line">最早的TCP/IP协议原型设计相当于现在的TCP和IP合在一起的样子，后来才拆分成为TCP和IP两个协议。</span><br></pre></td></tr></table></figure>

<p><code>UDP</code>：<code>User Datagram Protocol</code>的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）<br>参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF-RFC-768是UDP的正式规范。UDP在IP报文的协议号是17。<br>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。<br>在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。</p>
<p><code>ICMP</code>：<code>Internal Control Message Protocol</code></p>
<p><code>ARP</code>：<code>Address Resolution Protocol</code></p>
<p><code>HTTP</code>：<code>Hyper Text Transfer Protocol</code>，超文本传输协议，是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而[9]<br>消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使开发和部署非常地直截了当。<br>以太网：计算机局域网技术，规定了包括物理层连线，电子信号和介质访问层协议的内容，是目前应用最广泛的局域网技术。</p>
<p>MAC地址：Media Access Control Address，直译为媒体存取控制位址，也称为局域网地址（LAN<br>Address），以太网地址（Ethernet Address）或物理地址（Physical<br>Address），它是一个用来确认网路设备位置的位址。在OSI模型中，第三层网路层负责IP地址，第二层资料链结层则负责MAC位址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</p>
<p>套接字：应用程序委托操作系统创建一个套接字，然后返回一个描述符。套接字相当于是网络请求的大门，会包含所对应的门牌号码（端口号）。描述符为协议栈所则建的套接字，因此应用程序发生网络请求时，会给操作系统的协议栈传递描述符、IP地址、端口号。然后描述符所指带的套接字就会向对应的IP端□发送数据。</p>
<p>网络交换机：Network<br>switch，是一种网络硬件，通过报文交换接收和转发数据到目标设备，它能够在计算机网络上连接不同的设备。一般也简称为交换机。交换机是一种多端口的网桥，在数据链路层使用MAC地址转发数据。通过加入路由功能，一些交换机也可以在网络层转发数据，这种交换机一般被称为三层交换机或者多层交换机。以太网交换机是网络交换机最常见的形式。交换机的工作原理是根据IP包中的MAC地址和端口在自身的地址表中进行寻址，如果找不到，就在地址表中记录对应关系，并将包送给每一个端口。</p>
<p>一、探索浏览器内部</p>
<ol>
<li>互联网的本质结构是由无数个局域网（子网）组成的</li>
<li>怎么在网络中定位到目标计算机？<br>寻址！通过，IP地址可以定位到目标计算机。IP地址是由32位二进制数组成的，每8位为一组，即1个字节。要定位到网络中的某一台计算机，那么必须先定位到对应的网络，然后再在该子网中查找目标计算机。所以，IP地址结构由网络号和主机号组成，网络对应的是子网的地址，主机号对应的是子网中的目标主机。那么，32位的IP地址是如何区分网络号和主机号呢？子网掩码，就是用来界定网络号和主机号的，子网掩码中1对应的位是网络号，0对应的是主机号。注意，主机号中全为0表示整个子网，若全为1表示对整个子网中的主机发送数据包，即广播</li>
<li>既然IP能定位到目标主机，为什么还需要域名？<br>因为，IP毕竟是一串难以记忆的数字，在使用中不方便，所以就出现了域名这东西。但是，仅通过域名在现在的网络中是没法定位到目标主机的，并不是不能采用域名定位目标主机，而是采用域名这种方式定位，速度太慢，IP只要查询4个字节就历史以了，而域名则要查询更多字节了，所以，域名是方便人用的，DNS服务器的出现就是了折衷解决这个问题的，既让人方便记忆，又能让路由器快速定位到目标</li>
<li>浏览器通过解构URL地址生成请求信息，然后委托操作系统的协议栈发送请求信息，网卡设备把要发送的信息转换为电信号，服务器端的解构过程正好相反</li>
<li>客户端和服务器的通信需要“通信管道”来传送数据，整个通信过程包括：创建套接字，建立连接，传送数据，断开连接。套接字就是通信数据的出入口</li>
<li>PC客户端通过路由器连接，路由器后面连接的是运营商的网络，即接入网，这是连接互联网的入口。接入网连接着运营商的接入点，也就是离你们家最近的运营商的路由设备实体</li>
</ol>
<p>怎么理解 Socket 叫“套接字”？</p>
<p>从用户在浏览器上输入网址开始，都发生了什么？</p>
<ol>
<li>浏览器解析网址</li>
<li>浏览器根据网址的含义生成请求消息</li>
</ol>
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4redis</title>
    <url>/2021/05/26/learn4redis/</url>
    <content><![CDATA[<blockquote>
<p>  整理Redis整体且全面的知识架构，一片文章了解Redis大部分基础应用</p>
</blockquote>
<span id="more"></span>

<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-NoSQL应用场景"><a href="#1-NoSQL应用场景" class="headerlink" title="1. NoSQL应用场景"></a>1. NoSQL应用场景</h2><ul>
<li><p>数据模型比较简单</p>
</li>
<li><p>需要灵活性更强的IT系统</p>
</li>
<li><p>对数据库性能要求较高</p>
</li>
<li><p>不需要高度的数据一致性</p>
</li>
</ul>
<h2 id="2-什么是Redis"><a href="#2-什么是Redis" class="headerlink" title="2. 什么是Redis"></a>2. 什么是Redis</h2><blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<p>Redis 开源  遵循BSD  基于内存数据存储 被用于作为 数据库 缓存  消息中间件</p>
<ul>
<li>总结: redis是一个内存型的数据库</li>
</ul>
<h2 id="3-Redis特点"><a href="#3-Redis特点" class="headerlink" title="3. Redis特点"></a>3. Redis特点</h2><ul>
<li><p> Redis是一个高性能key/value内存型数据库</p>
</li>
<li><p> Redis支持丰富的数据类型 </p>
</li>
<li><p> Redis支持持久化 </p>
</li>
<li><p> Redis单线程,单进程</p>
</li>
</ul>
<hr>
<h2 id="4-Redis指令以及数据类型"><a href="#4-Redis指令以及数据类型" class="headerlink" title="4. Redis指令以及数据类型"></a>4. Redis指令以及数据类型</h2><h3 id="4-1-数据库操作指令"><a href="#4-1-数据库操作指令" class="headerlink" title="4.1 数据库操作指令"></a>4.1 数据库操作指令</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.Redis中库说明</span></span><br><span class="line"><span class="bullet">-</span> 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15</span><br><span class="line"><span class="bullet">-</span> 可以使用select 库的编号 来选择一个redis的库</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.Redis中操作库的指令</span></span><br><span class="line"><span class="bullet">-</span> 清空当前的库  FLUSHDB</span><br><span class="line"><span class="bullet">-</span> 清空全部的库  FLUSHALL</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.redis客户端显示中文</span></span><br><span class="line"><span class="bullet">-</span>	./redis-cli  -p 7000 --raw</span><br></pre></td></tr></table></figure>

<h3 id="4-2-操作key相关指令"><a href="#4-2-操作key相关指令" class="headerlink" title="4.2 操作key相关指令"></a>4.2 操作key相关指令</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.DEL指令</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  DEL key [key ...] </span><br><span class="line"><span class="bullet">-</span> 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 被删除key 的数量。 </span><br><span class="line"></span><br><span class="line"><span class="section"># 2.EXISTS指令</span></span><br><span class="line"><span class="bullet">-</span> 语法:  EXISTS key</span><br><span class="line"><span class="bullet">-</span> 作用:  检查给定key 是否存在。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 若key 存在，返回1 ，否则返回0。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.EXPIRE</span></span><br><span class="line"><span class="bullet">-</span> 语法:  EXPIRE key seconds</span><br><span class="line"><span class="bullet">-</span> 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 时间复杂度： O(1)</span><br><span class="line"><span class="bullet">-</span> 返回值：设置成功返回1 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 4.KEYS</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  KEYS pattern</span><br><span class="line"><span class="bullet">-</span> 作用 :  查找所有符合给定模式pattern 的key 。</span><br><span class="line"><span class="bullet">-</span> 语法:</span><br><span class="line"><span class="code">	KEYS * 匹配数据库中所有key 。</span></span><br><span class="line"><span class="code">	KEYS h?llo 匹配hello ，hallo 和hxllo 等。</span></span><br><span class="line"><span class="code">	KEYS h*llo 匹配hllo 和heeeeello 等。</span></span><br><span class="line"><span class="code">	KEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 &quot;\&quot; 隔开</span></span><br><span class="line"><span class="code">- 可用版本： &gt;= 1.0.0</span></span><br><span class="line"><span class="code">- 返回值： 符合给定模式的key 列表。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.MOVE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  MOVE key db</span><br><span class="line"><span class="bullet">-</span> 作用 :  将当前数据库的key 移动到给定的数据库db 当中。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 移动成功返回1 ，失败则返回0 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 6.PEXPIRE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PEXPIRE key milliseconds</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 时间复杂度： O(1)</span><br><span class="line"><span class="bullet">-</span> 返回值：设置成功，返回1  key 不存在或设置失败，返回0</span><br><span class="line"></span><br><span class="line"><span class="section"># 7.PEXPIREAT</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PEXPIREAT key milliseconds-timestamp</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)</span><br><span class="line"></span><br><span class="line"><span class="section"># 8.TTL</span></span><br><span class="line"><span class="bullet">-</span> 语法 :   TTL key</span><br><span class="line"><span class="bullet">-</span> 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：</span><br><span class="line"><span class="code">	当key 不存在时，返回-2 。</span></span><br><span class="line"><span class="code">	当key 存在但没有设置剩余生存时间时，返回-1 。</span></span><br><span class="line"><span class="code">	否则，以秒为单位，返回key 的剩余生存时间。</span></span><br><span class="line"><span class="code">- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.PTTL</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PTTL key</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。</span><br><span class="line"><span class="bullet">-</span> 否则，以毫秒为单位，返回key 的剩余生存时间。</span><br><span class="line"><span class="bullet">-</span> 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 10.RANDOMKEY</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  RANDOMKEY</span><br><span class="line"><span class="bullet">-</span> 作用 :  从当前数据库中随机返回(不删除) 一个key 。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 11.RENAME</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  RENAME key newkey</span><br><span class="line"><span class="bullet">-</span> 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 改名成功时提示OK ，失败时候返回一个错误。</span><br><span class="line"></span><br><span class="line"><span class="section"># 12.TYPE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  TYPE key</span><br><span class="line"><span class="bullet">-</span> 作用 :  返回key 所储存的值的类型。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：</span><br><span class="line"><span class="code">	none (key 不存在)</span></span><br><span class="line"><span class="code">	string (字符串)</span></span><br><span class="line"><span class="code">	list (列表)</span></span><br><span class="line"><span class="code">	set (集合)</span></span><br><span class="line"><span class="code">	zset (有序集)</span></span><br><span class="line"><span class="code">	hash (哈希表)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-String类型"><a href="#4-3-String类型" class="headerlink" title="4.3 String类型"></a>4.3 String类型</h3><h4 id="1-内存存储模型"><a href="#1-内存存储模型" class="headerlink" title="1. 内存存储模型"></a>1. 内存存储模型</h4><p>朴实无华的String类型</p>
<h4 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>设置一个key/value</td>
</tr>
<tr>
<td>get</td>
<td>根据key获得对应的value</td>
</tr>
<tr>
<td>mset</td>
<td>一次设置多个key value</td>
</tr>
<tr>
<td>mget</td>
<td>一次获得多个key的value</td>
</tr>
<tr>
<td>getset</td>
<td>获得原始key的值，同时设置新值</td>
</tr>
<tr>
<td>strlen</td>
<td>获得对应key存储value的长度</td>
</tr>
<tr>
<td>append</td>
<td>为对应key的value追加内容</td>
</tr>
<tr>
<td>getrange 索引0开始</td>
<td>截取value的内容</td>
</tr>
<tr>
<td>setex</td>
<td>设置一个key存活的有效期（秒）</td>
</tr>
<tr>
<td>psetex</td>
<td>设置一个key存活的有效期（毫秒）</td>
</tr>
<tr>
<td>setnx</td>
<td>存在不做任何操作,不存在添加</td>
</tr>
<tr>
<td>msetnx原子操作(只要有一个存在不做任何操作)</td>
<td>可以同时设置多个key,只有有一个存在都不保存</td>
</tr>
<tr>
<td>decr</td>
<td>进行数值类型的-1操作</td>
</tr>
<tr>
<td>decrby</td>
<td>根据提供的数据进行减法操作</td>
</tr>
<tr>
<td>Incr</td>
<td>进行数值类型的+1操作</td>
</tr>
<tr>
<td>incrby</td>
<td>根据提供的数据进行加法操作</td>
</tr>
<tr>
<td>Incrbyfloat</td>
<td>根据提供的数据加入浮点数</td>
</tr>
</tbody></table>
<h3 id="4-4-List类型"><a href="#4-4-List类型" class="headerlink" title="4.4 List类型"></a>4.4 List类型</h3><p>list 列表 相当于java中list 集合  特点  元素有序  且 可以重复</p>
<h4 id="1-内存存储模型-1"><a href="#1-内存存储模型-1" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p>是左右端都可以操作的双向链表</p>
<h4 id="2-常用操作指令"><a href="#2-常用操作指令" class="headerlink" title="2.常用操作指令"></a>2.常用操作指令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lpush</td>
<td>将某个值加入到一个key列表头部</td>
</tr>
<tr>
<td>lpushx</td>
<td>同lpush,但是必须要保证这个key存在</td>
</tr>
<tr>
<td>rpush</td>
<td>将某个值加入到一个key列表末尾</td>
</tr>
<tr>
<td>rpushx</td>
<td>同rpush,但是必须要保证这个key存在</td>
</tr>
<tr>
<td>lpop</td>
<td>返回和移除列表左边的第一个元素</td>
</tr>
<tr>
<td>rpop</td>
<td>返回和移除列表右边的第一个元素</td>
</tr>
<tr>
<td>lrange</td>
<td>获取某一个下标区间内的元素</td>
</tr>
<tr>
<td>llen</td>
<td>获取列表元素个数</td>
</tr>
<tr>
<td>lset</td>
<td>设置某一个指定索引的值(索引必须存在)</td>
</tr>
<tr>
<td>lindex</td>
<td>获取某一个指定索引位置的元素</td>
</tr>
<tr>
<td>lrem</td>
<td>删除重复元素</td>
</tr>
<tr>
<td>ltrim</td>
<td>保留列表中特定区间内的元素</td>
</tr>
<tr>
<td>linsert</td>
<td>在某一个元素之前，之后插入新元素</td>
</tr>
</tbody></table>
<h3 id="4-5-Set类型"><a href="#4-5-Set类型" class="headerlink" title="4.5 Set类型"></a>4.5 Set类型</h3><p>特点: Set类型 Set集合 元素无序  不可以重复</p>
<h4 id="1-内存存储模型-2"><a href="#1-内存存储模型-2" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p>朴实无华的Set类型</p>
<h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sadd</td>
<td>为集合添加元素</td>
</tr>
<tr>
<td>smembers</td>
<td>显示集合中所有元素 无序</td>
</tr>
<tr>
<td>scard</td>
<td>返回集合中元素的个数</td>
</tr>
<tr>
<td>spop</td>
<td>随机返回一个元素 并将元素在集合中删除</td>
</tr>
<tr>
<td>smove</td>
<td>从一个集合中向另一个集合移动元素  必须是同一种类型</td>
</tr>
<tr>
<td>srem</td>
<td>从集合中删除一个元素</td>
</tr>
<tr>
<td>sismember</td>
<td>判断一个集合中是否含有这个元素</td>
</tr>
<tr>
<td>srandmember</td>
<td>随机返回元素</td>
</tr>
<tr>
<td>sdiff</td>
<td>去掉第一个集合中其它集合含有的相同元素</td>
</tr>
<tr>
<td>sinter</td>
<td>求交集</td>
</tr>
<tr>
<td>sunion</td>
<td>求和集</td>
</tr>
</tbody></table>
<h3 id="4-6-ZSet类型"><a href="#4-6-ZSet类型" class="headerlink" title="4.6 ZSet类型"></a>4.6 ZSet类型</h3><p>特点: 可排序的set集合  排序  不可重复 </p>
<p>ZSET 官方  可排序SET  sortSet   </p>
<h4 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p>朴实无华的ZSet集合</p>
<h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>zadd</td>
<td>添加一个有序集合元素</td>
</tr>
<tr>
<td>zcard</td>
<td>返回集合的元素个数</td>
</tr>
<tr>
<td>zrange 升序 zrevrange 降序</td>
<td>返回一个范围内的元素</td>
</tr>
<tr>
<td>zrangebyscore</td>
<td>按照分数查找一个范围内的元素</td>
</tr>
<tr>
<td>zrank</td>
<td>返回排名</td>
</tr>
<tr>
<td>zrevrank</td>
<td>倒序排名</td>
</tr>
<tr>
<td>zscore</td>
<td>显示某一个元素的分数</td>
</tr>
<tr>
<td>zrem</td>
<td>移除某一个元素</td>
</tr>
<tr>
<td>zincrby</td>
<td>给某个特定元素加分</td>
</tr>
</tbody></table>
<h3 id="4-7-hash类型"><a href="#4-7-hash类型" class="headerlink" title="4.7 hash类型"></a>4.7 hash类型</h3><p>特点: value 是一个map结构 存在key value  key 无序的  </p>
<h4 id="1-内存模型-1"><a href="#1-内存模型-1" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p>朴实无华的HashMap</p>
<h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>hset</td>
<td>设置一个key/value对</td>
</tr>
<tr>
<td>hget</td>
<td>获得一个key对应的value</td>
</tr>
<tr>
<td>hgetall</td>
<td>获得所有的key/value对</td>
</tr>
<tr>
<td>hdel</td>
<td>删除某一个key/value对</td>
</tr>
<tr>
<td>hexists</td>
<td>判断一个key是否存在</td>
</tr>
<tr>
<td>hkeys</td>
<td>获得所有的key</td>
</tr>
<tr>
<td>hvals</td>
<td>获得所有的value</td>
</tr>
<tr>
<td>hmset</td>
<td>设置多个key/value</td>
</tr>
<tr>
<td>hmget</td>
<td>获得多个key的value</td>
</tr>
<tr>
<td>hsetnx</td>
<td>设置一个不存在的key的值</td>
</tr>
<tr>
<td>hincrby</td>
<td>为value进行加法运算</td>
</tr>
<tr>
<td>hincrbyfloat</td>
<td>为value加入浮点值</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-持久化机制"><a href="#5-持久化机制" class="headerlink" title="5. 持久化机制"></a>5. 持久化机制</h2><p>client  redis[内存] —–&gt;  内存数据- 数据持久化–&gt;磁盘</p>
<p>Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:</p>
<ul>
<li>快照(Snapshot)</li>
<li>AOF (Append Only File) 只追加日志文件</li>
</ul>
<h3 id="5-1-快照-Snapshot"><a href="#5-1-快照-Snapshot" class="headerlink" title="5.1 快照(Snapshot)"></a>5.1 快照(Snapshot)</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><p>这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是<strong>redis的默认开启持久化方式</strong>,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。</p>
<h4 id="2-快照生成方式"><a href="#2-快照生成方式" class="headerlink" title="2.快照生成方式"></a>2.快照生成方式</h4><ul>
<li>客户端方式: BGSAVE 和 SAVE指令</li>
<li>服务器配置自动触发</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.客户端方式之BGSAVE</span></span><br><span class="line"><span class="bullet">-</span> a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。</span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.客户端方式之SAVE</span></span><br><span class="line"><span class="bullet">-</span> b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务</strong></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.服务器配置方式之满足配置自动触发</span></span><br><span class="line"><span class="bullet">-</span> 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.服务器接收客户端shutdown指令</span></span><br><span class="line"><span class="bullet">-</span> 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器</span><br></pre></td></tr></table></figure>

<h4 id="3-配置生成快照名称和位置"><a href="#3-配置生成快照名称和位置" class="headerlink" title="3.配置生成快照名称和位置"></a>3.配置生成快照名称和位置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#1.修改生成快照名称</span></span><br><span class="line"><span class="bullet">-</span> dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.修改生成位置</span></span><br><span class="line"><span class="bullet">-</span> dir ./</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-AOF-只追加日志文件"><a href="#5-2-AOF-只追加日志文件" class="headerlink" title="5.2 AOF 只追加日志文件"></a>5.2 AOF 只追加日志文件</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.</p>
<h4 id="2-开启AOF持久化"><a href="#2-开启AOF持久化" class="headerlink" title="2.开启AOF持久化"></a>2.开启AOF持久化</h4><p>在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启AOF持久化</span></span><br><span class="line"><span class="bullet">-</span> a.修改 appendonly yes 开启持久化</span><br><span class="line"><span class="bullet">-</span> b.修改 appendfilename &quot;appendonly.aof&quot; 指定生成文件名称</span><br></pre></td></tr></table></figure>

<h4 id="3-日志追加频率"><a href="#3-日志追加频率" class="headerlink" title="3.日志追加频率"></a>3.日志追加频率</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.always 【谨慎使用】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度</span><br><span class="line"><span class="bullet">-</span> 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;</span><br><span class="line"><span class="bullet">-</span> 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;</span><br><span class="line"><span class="bullet">-</span> 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.everysec 【推荐】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘</span><br><span class="line"><span class="bullet">-</span> 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.no	【不推荐】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 由操作系统决定何时同步 </span><br><span class="line"><span class="bullet">-</span> 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。</span><br></pre></td></tr></table></figure>

<h4 id="4-修改同步频率"><a href="#4-修改同步频率" class="headerlink" title="4.修改同步频率"></a>4.修改同步频率</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.修改日志同步频率</span></span><br><span class="line"><span class="bullet">-</span> 修改appendfsync everysec|always|no 指定</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-AOF文件的重写"><a href="#5-3-AOF文件的重写" class="headerlink" title="5.3 AOF文件的重写"></a>5.3 AOF文件的重写</h3><h4 id="1-AOF带来的问题"><a href="#1-AOF带来的问题" class="headerlink" title="1. AOF带来的问题"></a>1. AOF带来的问题</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。</p>
<h4 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2. AOF重写"></a>2. AOF重写</h4><p>用来在一定程度上减小AOF文件的体积</p>
<h4 id="3-触发重写方式"><a href="#3-触发重写方式" class="headerlink" title="3. 触发重写方式"></a>3. 触发重写方式</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.客户端方式触发重写</span></span><br><span class="line"><span class="bullet">-</span> 执行BGREWRITEAOF命令  不会阻塞redis的服务</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.服务器配置方式自动触发</span></span><br><span class="line"><span class="bullet">-</span> 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓</span><br><span class="line"><span class="bullet">-</span> 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大</span><br></pre></td></tr></table></figure>

<h4 id="4-重写原理"><a href="#4-重写原理" class="headerlink" title="4. 重写原理"></a>4. 重写原理</h4><p> <strong>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 重写流程</span></span><br><span class="line"><span class="bullet">-</span> 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令</span><br><span class="line"><span class="bullet">-</span> 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。</span><br><span class="line"><span class="bullet">-</span> 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。</span><br><span class="line"><span class="bullet">-</span> 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5Cimage-20210527105149362.png" alt="image-20210527105149362"></p>
<hr>
<h3 id="5-4-持久化总结"><a href="#5-4-持久化总结" class="headerlink" title="5.4 持久化总结"></a>5.4 持久化总结</h3><p>两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。</p>
<p>无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。</p>
<hr>
<h2 id="6-SpringBoot整合Redis"><a href="#6-SpringBoot整合Redis" class="headerlink" title="6. SpringBoot整合Redis"></a>6. SpringBoot整合Redis</h2><p>Spring Boot Data(数据) Redis 中提供了<strong>RedisTemplate和StringRedisTemplate</strong>，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，<strong>RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。</strong></p>
<p><code>注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口</code></p>
<h3 id="11-1-环境准备"><a href="#11-1-环境准备" class="headerlink" title="11.1 环境准备"></a>11.1 环境准备</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-配置application-propertie"><a href="#2-配置application-propertie" class="headerlink" title="2.配置application.propertie"></a>2.配置application.propertie</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<h3 id="11-2-使用StringRedisTemplate和RedisTemplate"><a href="#11-2-使用StringRedisTemplate和RedisTemplate" class="headerlink" title="11.2 使用StringRedisTemplate和RedisTemplate"></a>11.2 使用StringRedisTemplate和RedisTemplate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;  <span class="comment">//对字符串支持比较友好,不能存储对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;  <span class="comment">//存储对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(redisTemplate);</span><br><span class="line">        <span class="comment">//设置redistemplate值使用对象序列化策略</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>());<span class="comment">//指定值使用对象序列化</span></span><br><span class="line">        <span class="comment">//redisTemplate.opsForValue().set(&quot;user&quot;,new User(&quot;21&quot;,&quot;小黑&quot;,23,new Date()));</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"><span class="comment">//      Set keys = redisTemplate.keys(&quot;*&quot;);</span></span><br><span class="line"><span class="comment">//      keys.forEach(key -&gt; System.out.println(key));</span></span><br><span class="line">        <span class="comment">/*Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(name);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object xiaohei = redisTemplate.opsForValue().get(&quot;xiaohei&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(xiaohei);</span></span><br><span class="line">        <span class="comment">/*redisTemplate.opsForValue().set(&quot;name&quot;,&quot;xxxx&quot;);</span></span><br><span class="line"><span class="comment">        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(name);*/</span></span><br><span class="line">        <span class="comment">/*redisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;xxxx&quot;,&quot;1111&quot;);</span></span><br><span class="line"><span class="comment">        List lists = redisTemplate.opsForList().range(&quot;lists&quot;, 0, -1);</span></span><br><span class="line"><span class="comment">        lists.forEach(list-&gt; System.out.println(list));*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key</span></span><br><span class="line">    <span class="comment">//boundValueOps 用来对String值绑定key</span></span><br><span class="line">    <span class="comment">//boundListOps 用来对List值绑定key</span></span><br><span class="line">    <span class="comment">//boundSetOps 用来对Set值绑定key</span></span><br><span class="line">    <span class="comment">//boundZsetOps 用来对Zset值绑定key</span></span><br><span class="line">    <span class="comment">//boundHashOps 用来对Hash值绑定key</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBoundKey</span><span class="params">()</span>&#123;</span><br><span class="line">        BoundValueOperations&lt;String, String&gt; nameValueOperations = stringRedisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        nameValueOperations.set(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//yuew</span></span><br><span class="line">        nameValueOperations.set(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> nameValueOperations.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash相关操作 opsForHash</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;maps&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(<span class="string">&quot;maps&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//zset相关操作 opsForZSet</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;zsets&quot;</span>,<span class="string">&quot;小黑&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(<span class="string">&quot;zsets&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        zsets.forEach(value-&gt; System.out.println(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set相关操作 opsForSet</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;sets&quot;</span>,<span class="string">&quot;xiaosan&quot;</span>,<span class="string">&quot;xiaosi&quot;</span>,<span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(<span class="string">&quot;sets&quot;</span>);</span><br><span class="line">        sets.forEach(value-&gt; System.out.println(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list相关的操作opsForList</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// stringRedisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</span></span><br><span class="line">        List&lt;String&gt; lists = stringRedisTemplate.opsForList().range(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        lists.forEach(key -&gt; System.out.println(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String相关的操作 opsForValue</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//stringRedisTemplate.opsForValue().set(&quot;166&quot;,&quot;好同学&quot;);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;166&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().size(<span class="string">&quot;166&quot;</span>);</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key相关的操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.keys(<span class="string">&quot;*&quot;</span>);<span class="comment">//查看所有key</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.hasKey(<span class="string">&quot;name&quot;</span>);<span class="comment">//判断某个key是否存在</span></span><br><span class="line">        stringRedisTemplate.delete(<span class="string">&quot;age&quot;</span>);<span class="comment">//根据指定key删除</span></span><br><span class="line">        stringRedisTemplate.rename(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//修改key的名称</span></span><br><span class="line">        stringRedisTemplate.expire(<span class="string">&quot;key&quot;</span>,<span class="number">10</span>, TimeUnit.HOURS);</span><br><span class="line">      	<span class="comment">//设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位</span></span><br><span class="line">        stringRedisTemplate.move(<span class="string">&quot;&quot;</span>,<span class="number">1</span>);<span class="comment">//移动key</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-Redis-主从复制"><a href="#7-Redis-主从复制" class="headerlink" title="7. Redis 主从复制"></a>7. Redis 主从复制</h2><h3 id="7-1-主从复制"><a href="#7-1-主从复制" class="headerlink" title="7.1 主从复制"></a>7.1 主从复制</h3><p>主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据</p>
<p><strong>无法解决: 1.master节点出现故障的自动故障转移</strong></p>
<h3 id="7-2-搭建主从复制"><a href="#7-2-搭建主从复制" class="headerlink" title="7.2 搭建主从复制"></a>7.2 搭建主从复制</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.准备3台机器并修改配置</span></span><br><span class="line"><span class="bullet">-</span> master</span><br><span class="line"><span class="code">	port 6379</span></span><br><span class="line"><span class="code">	bind 0.0.0.0</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- slave1</span></span><br><span class="line"><span class="code">	port 6380</span></span><br><span class="line"><span class="code">	bind 0.0.0.0</span></span><br><span class="line"><span class="code">	slaveof masterip masterport</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> slave2</span><br><span class="line"><span class="code">	port 6381</span></span><br><span class="line"><span class="code">	bind 0.0.0.0</span></span><br><span class="line"><span class="code">	slaveof masterip masterport</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.启动3台机器进行测试</span></span><br><span class="line"><span class="bullet">-</span> cd /usr/redis/bin</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/master/redis.conf</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/slave1/redis.conf</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/slave2/redis.conf</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-Redis哨兵机制"><a href="#8-Redis哨兵机制" class="headerlink" title="8. Redis哨兵机制"></a>8. Redis哨兵机制</h2><h3 id="8-1-哨兵Sentinel机制"><a href="#8-1-哨兵Sentinel机制" class="headerlink" title="8.1 哨兵Sentinel机制"></a>8.1 哨兵Sentinel机制</h3><p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有<strong>自动故障转移功能的主从架构</strong>。</p>
<p><strong>无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限</strong></p>
<h3 id="8-2-搭建哨兵架构"><a href="#8-2-搭建哨兵架构" class="headerlink" title="8.2 搭建哨兵架构"></a>8.2 搭建哨兵架构</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在主节点上创建哨兵配置</span></span><br><span class="line"><span class="bullet">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span></span><br><span class="line"><span class="bullet">-</span> sentinel monitor 被监控数据库名字（自己起名字） ip port 1</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.启动哨兵模式进行测试</span></span><br><span class="line"><span class="bullet">-</span> redis-sentinel  /root/sentinel/sentinel.conf</span><br><span class="line"><span class="code">	说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-通过springboot操作哨兵"><a href="#8-3-通过springboot操作哨兵" class="headerlink" title="8.3 通过springboot操作哨兵"></a>8.3 通过springboot操作哨兵</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis sentinel 配置</span></span><br><span class="line"><span class="comment"># master书写是使用哨兵监听的那个名称</span></span><br><span class="line"><span class="attr">spring.redis.sentinel.master</span>=<span class="string">mymaster</span></span><br><span class="line"><span class="comment"># 连接的不再是一个具体redis主机,书写的是多个哨兵节点</span></span><br><span class="line"><span class="attr">spring.redis.sentinel.nodes</span>=<span class="string">192.168.202.206:26379</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)</strong></li>
<li><strong>解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限</strong></li>
</ul>
<h2 id="9-Redis集群"><a href="#9-Redis集群" class="headerlink" title="9. Redis集群"></a>9. Redis集群</h2><h3 id="9-1-集群"><a href="#9-1-集群" class="headerlink" title="9.1 集群"></a>9.1 集群</h3><p>Redis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持节点的自动发现,支持slave-master选举和容错,支持在线分片(sharding shard )等特性。reshard</p>
<h3 id="9-2-集群细节"><a href="#9-2-集群细节" class="headerlink" title="9.2 集群细节"></a>9.2 集群细节</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</span><br><span class="line"><span class="bullet">-</span> 节点的fail是通过集群中超过半数的节点检测失效时才生效. </span><br><span class="line"><span class="bullet">-</span> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</span><br><span class="line"><span class="bullet">-</span> redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</span><br></pre></td></tr></table></figure>

<h3 id="9-3-集群搭建"><a href="#9-3-集群搭建" class="headerlink" title="9.3 集群搭建"></a>9.3 集群搭建</h3><p>判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数，<strong>搭建集群至少需要三个主节点,三个从节点,至少需要6个节点</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.准备环境安装ruby以及redis集群依赖</span></span><br><span class="line"><span class="bullet">-</span> yum install -y ruby rubygems</span><br><span class="line"><span class="bullet">-</span> gem install redis-xxx.gem</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.在一台机器创建7个目录</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.每个目录复制一份配置文件</span></span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.修改不同目录配置文件</span></span><br><span class="line"><span class="bullet">-</span> port 	6379 .....                		 //修改端口</span><br><span class="line"><span class="bullet">-</span> bind  0.0.0.0                   		 //开启远程连接</span><br><span class="line"><span class="bullet">-</span> cluster-enabled  yes 	        			 //开启集群模式</span><br><span class="line"><span class="bullet">-</span> cluster-config-file  nodes-port.conf //集群节点配置文件</span><br><span class="line"><span class="bullet">-</span> cluster-node-timeout  5000      	   //集群节点超时时间</span><br><span class="line"><span class="bullet">-</span> appendonly  yes   		               //开启AOF持久化</span><br><span class="line"></span><br><span class="line"><span class="section"># 5.指定不同目录配置文件启动七个节点</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7000/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7001/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7002/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7003/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7004/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7005/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7006/redis.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.查看进程</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ps aux|grep redis</span><br></pre></td></tr></table></figure>

<h4 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1.创建集群"></a>1.创建集群</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.复制集群操作脚本到bin目录中</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# cp /root/redis-4.0.10/src/redis-trib.rb .</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.创建集群</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb create --replicas 1 192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.集群创建成功</span></span><br></pre></td></tr></table></figure>

<h4 id="2-查看集群状态"><a href="#2-查看集群状态" class="headerlink" title="2.查看集群状态"></a>2.查看集群状态</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.查看集群状态 check [原始集群中任意节点] [无]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb check 192.168.202.205:7000</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.集群节点状态说明</span></span><br><span class="line"><span class="bullet">-</span> 主节点 </span><br><span class="line"><span class="code">	主节点存在hash slots,且主节点的hash slots 没有交叉</span></span><br><span class="line"><span class="code">	主节点不能删除</span></span><br><span class="line"><span class="code">	一个主节点可以有多个从节点</span></span><br><span class="line"><span class="code">	主节点宕机时多个副本之间自动选举主节点</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 从节点</span><br><span class="line"><span class="code">	从节点没有hash slots</span></span><br><span class="line"><span class="code">	从节点可以删除</span></span><br><span class="line"><span class="code">	从节点不负责数据的写,只负责数据的同步</span></span><br></pre></td></tr></table></figure>

<h4 id="3-添加主节点"><a href="#3-添加主节点" class="headerlink" title="3.添加主节点"></a>3.添加主节点</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"><span class="code">	1.该节点必须以集群模式启动</span></span><br><span class="line"><span class="code">	2.默认情况下该节点就是以master节点形式添加</span></span><br></pre></td></tr></table></figure>

<h4 id="4-添加从节点"><a href="#4-添加从节点" class="headerlink" title="4.添加从节点"></a>4.添加从节点</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"><span class="code">	当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]</span></span><br><span class="line"><span class="code">- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000</span></span><br></pre></td></tr></table></figure>

<h4 id="5-删除副本节点"><a href="#5-删除副本节点" class="headerlink" title="5.删除副本节点"></a>5.删除副本节点</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.删除节点 del-node [集群中任意节点] [删除节点id]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"> 1.被删除的节点必须是从节点或没有被分配hash slots的节点</span><br></pre></td></tr></table></figure>

<h4 id="6-集群在线分片"><a href="#6-集群在线分片" class="headerlink" title="6.集群在线分片"></a>6.集群在线分片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在线分片 reshard [集群中任意节点] [无]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  reshard  192.168.1.158:7000</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-Redis实现分布式Session管理"><a href="#10-Redis实现分布式Session管理" class="headerlink" title="10.Redis实现分布式Session管理"></a>10.Redis实现分布式Session管理</h2><h3 id="10-1-管理机制"><a href="#10-1-管理机制" class="headerlink" title="10.1 管理机制"></a>10.1 管理机制</h3><p><strong>redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据。</strong></p>
<h3 id="10-2-开发Session管理"><a href="#10-2-开发Session管理" class="headerlink" title="10.2 开发Session管理"></a>10.2 开发Session管理</h3><h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-开发Session管理配置类"><a href="#2-开发Session管理配置类" class="headerlink" title="2. 开发Session管理配置类"></a>2. 开发Session管理配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSessionManager</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-打包测试即可"><a href="#3-打包测试即可" class="headerlink" title="3.打包测试即可"></a>3.打包测试即可</h4><hr>
<h2 id="11-总结面试"><a href="#11-总结面试" class="headerlink" title="11.总结面试"></a>11.总结面试</h2><h3 id="11-1缓存穿透、缓存击穿、缓存雪崩以及解决方案？"><a href="#11-1缓存穿透、缓存击穿、缓存雪崩以及解决方案？" class="headerlink" title="11.1缓存穿透、缓存击穿、缓存雪崩以及解决方案？"></a>11.1缓存穿透、缓存击穿、缓存雪崩以及解决方案？</h3><p>缓存穿透：<code>请求查询的ID是缓存和数据库中都不存在的，外部攻击频繁查询不存在的ID而不经过缓存，导致频繁查询数据库，而对数据库的压力过大。</code></p>
<p>解决方案：</p>
<ol>
<li>对查询ID进行校验，不符合的ID被拦截。</li>
<li>对缓存和数据库中都不取不到的ID进行缓存，key-value设置为key-null，缓存的有效时间设置短点。</li>
</ol>
<p>缓存击穿：<code>请求查询的ID是缓存中不存在，而数据库中存在的，情景理解成一个缓存在刚好失效的时候，大量的请求涌入，由于缓存不存在而去大量访问数据库，导致对数据库的压力过大。</code></p>
<p>解决方案：</p>
<ol>
<li>设置键永久期限（不推荐）</li>
<li>互斥锁：Redis使用SETNX（set if not exists）</li>
<li>布隆过滤器</li>
</ol>
<p>缓存雪崩：<code>多个请求查询的ID是缓存中不存在而数据库中存在,大量缓存设置了相同的生存时间后同时失效,高并发情况下大量的数据同时涌入数据库,导致数据库压力瞬间过大而挂起</code></p>
<p>解决方案：</p>
<ol>
<li>根据业务场景给不同的key设置不同的过期时间</li>
<li>设置键的永久期限（不推荐）</li>
</ol>
<h3 id="11-2Redis为什么这么快"><a href="#11-2Redis为什么这么快" class="headerlink" title="11.2Redis为什么这么快?"></a>11.2Redis为什么这么快?</h3><ol>
<li>完全基于内存操作</li>
<li>C语言编写，使用优化过的基本数据结构</li>
<li>单线程，无上下文切换成本</li>
<li>NIO：非阻塞的IO多路复用</li>
</ol>
<h3 id="11-3那为什么Redis6-0之后又改成了多线程？"><a href="#11-3那为什么Redis6-0之后又改成了多线程？" class="headerlink" title="11.3那为什么Redis6.0之后又改成了多线程？"></a>11.3那为什么Redis6.0之后又改成了多线程？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Redis使用多线程并非摒弃单线程，Redis的多线程只是在处理数据的读写和协议解析的时候使用，在执行命令时还是使用单线程。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 目的是Redis的性能瓶颈是网络IO而非CPU，使用多线程来处理IO读写效率从而提升整体Redis效率。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-4Redis的热key问题是什么？怎么解决热key问题？"><a href="#11-4Redis的热key问题是什么？怎么解决热key问题？" class="headerlink" title="11.4Redis的热key问题是什么？怎么解决热key问题？"></a>11.4Redis的热key问题是什么？怎么解决热key问题？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 所谓热key问题，就是一瞬间大量热点数据访问redis中某个key，瞬间达到物理网卡上限，导致Redis宕机。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 解决热key问题可以将热点key加入二级缓存，如果Redis宕机，直接从内存中读取。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-5持久化方式有那些？"><a href="#11-5持久化方式有那些？" class="headerlink" title="11.5持久化方式有那些？"></a>11.5持久化方式有那些？</h3><ol>
<li><p>RDB</p>
<p>内存快照</p>
</li>
<li><p>AOF</p>
<p>日志追加</p>
</li>
</ol>
<h3 id="11-6Redis如何实现高可用？"><a href="#11-6Redis如何实现高可用？" class="headerlink" title="11.6Redis如何实现高可用？"></a>11.6Redis如何实现高可用？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 主从复制架构</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 主从复制架构是最简单实现高可用的方案，核心就是主从同步。主从同步的原理：</span></span><br><span class="line"><span class="bullet">1.</span> slave发送sync命令到master</span><br><span class="line"><span class="bullet">2.</span> master收到sync之后，执行bgsave，生成RDB全量文件</span><br><span class="line"><span class="bullet">3.</span> master把slave的写命令记录到缓存</span><br><span class="line"><span class="bullet">4.</span> bgsave执行完毕之后，发送RDB文件到slave，slave执行</span><br><span class="line"><span class="bullet">5.</span> master发送缓存中的写命令到slave，slave执行</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 哨兵模式</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 哨兵模式解决了主从复制无法实现的自动故障转移、集群监控、消息通知。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-7Redis集群的原理是什么？"><a href="#11-7Redis集群的原理是什么？" class="headerlink" title="11.7Redis集群的原理是什么？"></a>11.7Redis集群的原理是什么？</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Redis集群</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Redis集群是Redis提供的分布式存储方案，利用分片sharding来对数据进行共享，同时还提供自动故障转移和复制功能。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 节点</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 一个Redis集群由多个节点构成，节点之间通过cluster meet命令进行链接。连接的握手过程：</span></span><br><span class="line"><span class="bullet">1.</span> 节点A收到客户端的cluster meet命令</span><br><span class="line"><span class="bullet">2.</span> 节点A根据接收到的IP和PORT向节点B发送meet消息</span><br><span class="line"><span class="bullet">3.</span> 节点B收到meet消息返回ping给节点A</span><br><span class="line"><span class="bullet">4.</span> 节点A收到ping消息返回pong给节点B，握手成功</span><br><span class="line"><span class="bullet">5.</span> 节点A通过gossip协议把节点B的信息传播给集群中其他节点，其他节点和节点B进行握手</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 补充：</span><br><span class="line"><span class="code">	发送meet消息是加入节点是发生的，发送ping-pong是每个节点每隔一秒就会从已知节点中随机选出5个节点，然后对这5个节点中最久没有发送过ping消息的节点发送ping，以此来检验被选中节点是否在线。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># Slot 槽</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 节点分为主节点、从节点，一个Reids集群中有16384个Slot槽，会均匀的分配到所有集群主节点中，读取数据时key进行哈希计算得到一个slot对应的值。主节点宕机从节点会接替主节点的所有slot槽。</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 故障转移</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 如果节点B在被ping后没有相应pong，那么节点A会标记节点B为fail状态，超过半数节点标记节点B为fail状态，则节点B为宕机状态，节点B下的备份数据最多的将替代节点B，接收节点B的所有slot槽。整个过程和哨兵非常类似，都是基于Raft协议做选举。</span></span><br></pre></td></tr></table></figure>

<h3 id="11-8了解Redis事务吗？"><a href="#11-8了解Redis事务吗？" class="headerlink" title="11.8了解Redis事务吗？"></a>11.8了解Redis事务吗？</h3><p><code>使用MULT、EXEC、WATCH命令来实现事务，事务的执行过程是多个命令按照顺序一次性执行完成，并在执行期间事务不会被中断，如果遇到其他正在执行的事务，会返回QUEUED。</code></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4vim</title>
    <url>/2022/10/01/learn4vim/</url>
    <content><![CDATA[<blockquote>
<p>整理 vim ide 的新手学习过程</p>
</blockquote>
<span id="more"></span>

<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="一般模式可用的按钮说明"><a href="#一般模式可用的按钮说明" class="headerlink" title="一般模式可用的按钮说明"></a>一般模式可用的按钮说明</h2><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>「h、j、k、l」分别控制光标左、下、上、右移一格<br>「ctrl+b」屏幕往”后”移动一页<br>「ctrl+f」屏幕往”前”移动一页<br>「n<space>」光标向右移动n个字符<br>「Home」移动到这一行的最前面字符处:0数字，但不能用数字小键盘上的数字<br>「End」移动到这一行的最后面字符处:$，我测试好像不行<br>「w」光标跳到下个字的开头<br>「e」光标跳到下个字的字尾<br>「H」光标移动到这个屏幕的最上方那一行的第一个字符<br>「M」光标移动到这个屏幕的中间那一行的第一个字符<br>「L」光标移动到这个屏幕的最下方那一行的第一个字符<br>「G」移动到这个文件的最后一行<br>「nG」移动到这个文件的第n行(可配合:set nu)<br>「gg」移动到这个文件的第一行，相当于1G<br>「n<Enter>」光标向下移动n行</p>
<h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><p>「/word」向光标向下寻找一个名称为word的字符串<br>「?word」向光标向上寻找一个名称为word的字符串<br>「n」代表重复前一个查找的动作<br>「N」与n刚好相反，为「反向」进行行前一个查找动作<br>「:n1,n2s/word1/word2/g」n1与n2为数字，在第n1与n2行之间查找word1 这个字符串，并将该字符串替换为word2<br>「:1,$s/word1/word2/g」从第一行到最后一行查找word1字符串，并将该字符串替换为word2<br>「:1,$s/word1/word2/gc」从第一行到最后一行查找word1字符串，并将该字符串替换为word2 ，且在替换前提示用户确认是否进行替换</p>
<h3 id="删除、复制与粘贴"><a href="#删除、复制与粘贴" class="headerlink" title="删除、复制与粘贴"></a>删除、复制与粘贴</h3><p>「x」为向后删除一个字符 (相当于「del」键)<br>「X」为向前删除一个字符(相当于「backspace」键)<br>「nx」连续向后删除n个字符<br>「dd」删除光标所在行<br>「ndd」删除光标所在的向下n行<br>「d1G」删除光标所在行到第一行的所有数据<br>「dG」删除光标所在到最后一行的所有数据<br>「d$」删除光标所在处，到该行的最后一个字符<br>「d0」删除光标所在处，到该行的最前一个字符<br>「yy」复制光标所在的那一行<br>「nyy」复制光标所在的向下n列<br>「y1G」复制光标所在行到第一行的所有数据<br>「yG」复制光标所在行到最后一行的所有数据<br>「y0」复制光标所在的那个字符到该行行首的所有数据<br>「y$」复制光标所在的那个字符到该行行尾的所有数据<br>「p」将已复制的数据在光标下一行粘贴上<br>「P」则为贴在光标的上一行<br>「u」恢复前一个操作<br>「Ctrl+r」重做上一个操作<br>「.」是重复前一个操作</p>
<h2 id="一般模式切换到编辑模式的可用的按钮说明"><a href="#一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="一般模式切换到编辑模式的可用的按钮说明"></a>一般模式切换到编辑模式的可用的按钮说明</h2><p>「i, I」进入编辑模式：</p>
<ul>
<li>i 为「从目前光标所在处插入」</li>
<li>I 为「在目前所在行的第一个非空格符处开始插入」<br>「a, A」进入编辑模式(Insert mode)：</li>
<li>a 为「从目前光标所在的下一个字符处开始插入」</li>
<li>A 为「从光标所在行的最后一个字符处开始插入」<br>「o, O」进入编辑模式：</li>
<li>o 为「在目前光标所在的下一行处插入新的一行」</li>
<li>O 为在目前光标所在处的上一行插入新的一行<br>「r, R」进入取代模式：</li>
<li>r 只会取代光标所在的那一个字符一次</li>
<li>R会一直取代光标所在的文字，直到按下 ESC 为止；<br>「Esc」退出编辑模式，回到一般模式</li>
</ul>
<h2 id="一般模式切换到命令行模式可用的按钮说明"><a href="#一般模式切换到命令行模式可用的按钮说明" class="headerlink" title="一般模式切换到命令行模式可用的按钮说明"></a>一般模式切换到命令行模式可用的按钮说明</h2><p>「:w」保存编辑的内容<br>「:w!」强制写入该文件，但跟你对该文件的权限有关<br>「:q」离开vi<br>「:q!」不想保存修改强制离开<br>「:wq」保存后离开<br>「:x」保存后离开<br>「ZZ」若文件没有更动，则不保存离开，若文件已经被更改过，则保存后离开<br>「:w filename」将编辑的数据保存成另一个文件（类似另存）<br>「:r filename」在编辑的数据中，读入另一个文件的数据。即将「filename」这个文件的内容加到光标所在行后面。<br>「:n1,n2 w filename」将n1到n2的内容保存成filename这个文件。<br>「:! command」暂时离开vi 到命令行模式下执行command的显示结果！例如 「:! ls /home」即可在 vi 当中察看/home底下以ls输出的文件信息！<br>「:set nu」显示行号<br>「:set nonu」与 set nu 相反，为取消行</p>
<h1 id="vim-plugins"><a href="#vim-plugins" class="headerlink" title="vim plugins"></a>vim plugins</h1><h2 id="nerdtree"><a href="#nerdtree" class="headerlink" title="nerdtree"></a>nerdtree</h2><p>「ctrl+w+r」切换当前窗口左右布局<br>「ctrl」+p 模糊搜索文件<br>「gT」切换到前一个tabgT<br>「gt」切换到后一个tab<br>「o」打开关闭文件或者目录，如果是文件的话，光标出现在打开的文件中<br>「O」打开结点下的所有目录<br>「X」合拢当前结点的所有目录<br>「x」合拢当前结点的父目录<br>「i」水平分割窗口打开文件<br>「s」纵向分割窗口打开文件<br>「u」打开上层目录<br>「t」在标签页中打开<br>「T」在后台标签页中打开<br>「p」到上层目录<br>「P」到根目录<br>「K」到同目录第一个节点<br>「J」到同目录最后一个节点<br>「m」显示文件系统菜单（添加、删除、移动操作）<br>「?」帮助<br>「:q」关闭</p>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>learn4springcloud</title>
    <url>/2021/05/26/learn4springcloud/</url>
    <content><![CDATA[<blockquote>
<p>  学习SpringCloud时参考的学习资料以及自己的理解和整理</p>
</blockquote>
<span id="more"></span>

<h1 id="Spring-Cloud-微服务工具集v1-1"><a href="#Spring-Cloud-微服务工具集v1-1" class="headerlink" title="Spring Cloud 微服务工具集v1.1"></a>Spring Cloud 微服务工具集v1.1</h1><ul>
<li><strong>版本: Hoxton SR6</strong></li>
</ul>
<h2 id="1-什么是微服务"><a href="#1-什么是微服务" class="headerlink" title="1.什么是微服务"></a>1.什么是微服务</h2><ul>
<li>官网: <a href="https://www.martinfowler.com/articles/microservices.html">https://www.martinfowler.com/articles/microservices.html</a></li>
</ul>
<p>In short, the microservice architectural(架构) style is an approach to developing a single application as <code>a suite(系列) of small services</code>, each <code>running in its own process(进程)</code> and communicating with lightweight mechanisms, often an HTTP resource API. These services are <code>built around business(业务) capabilities(单元)</code> and <code>independently(独立) deployable(部署)</code> by fully automated deployment machinery. <code>There is a bare(基于) minimum of centralized(分布式) management(管理) of these services</code>, which may be written in different programming languages and use different data storage technologies.                        —–[摘自官网]</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> a suite of small services                      				--一系列微小服务</span><br><span class="line"><span class="bullet">-</span> running in its own process                                    --运行在自己的进程里</span><br><span class="line"><span class="bullet">-</span> built around business capabilities                            --围绕自己的业务开发</span><br><span class="line"><span class="bullet">-</span> independently deployable                                      --独立部署</span><br><span class="line"><span class="bullet">-</span> bare minimum of centralized management of these services      --基于分布式管理</span><br></pre></td></tr></table></figure>

<ul>
<li>官方定义:<strong>微服务就是由一系列围绕自己业务开发的微小服务构成,他们独立部署运行在自己的进程里,基于分布式的管理</strong></li>
</ul>
<hr>
<h2 id="2-为什么是微服务"><a href="#2-为什么是微服务" class="headerlink" title="2.为什么是微服务?"></a>2.为什么是微服务?</h2><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.优点</span></span><br><span class="line"><span class="bullet">-</span>	单一架构模式在项目初期很小的时候开发方便，测试方便，部署方便，运行良好。</span><br><span class="line"><span class="section"># 2.缺点</span></span><br><span class="line"><span class="bullet">-</span> 应用随着时间的推进，加入的功能越来越多，最终会变得巨大，一个项目中很有可能数百万行的代码，互相之间繁琐的jar包。</span><br><span class="line"><span class="bullet">-</span> 久而久之，开发效率低，代码维护困难</span><br><span class="line"><span class="bullet">-</span> 还有一个如果想整体应用采用新的技术，新的框架或者语言，那是不可能的。</span><br><span class="line"><span class="bullet">-</span> 任意模块的漏洞或者错误都会影响这个应用，降低系统的可靠性</span><br></pre></td></tr></table></figure>

<h3 id="微服务架构应用"><a href="#微服务架构应用" class="headerlink" title="微服务架构应用"></a>微服务架构应用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.优点</span></span><br><span class="line"><span class="bullet">-</span> 将服务拆分成多个单一职责的小的服务，进行单独部署，服务之间通过网络进行通信</span><br><span class="line"><span class="bullet">-</span> 每个服务应该有自己单独的管理团队，高度自治</span><br><span class="line"><span class="bullet">-</span> 服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</span><br><span class="line"><span class="section"># 2.缺点</span></span><br><span class="line"><span class="bullet">-</span> 开发人员要处理分布式系统的复杂性</span><br><span class="line"><span class="bullet">-</span> 多服务运维难度，随着服务的增加，运维的压力也在增大</span><br><span class="line"><span class="bullet">-</span> 服务治理 和 服务监控 关键</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-微服务的解决方案"><a href="#3-微服务的解决方案" class="headerlink" title="3.微服务的解决方案"></a>3.微服务的解决方案</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Dubbo (阿里系)</span></span><br><span class="line"><span class="section"># Spring Cloud:</span></span><br><span class="line"><span class="bullet">-</span> Spring Cloud NetFlix  </span><br><span class="line"><span class="bullet">-</span> Spring Cloud alibaba</span><br><span class="line"><span class="bullet">-</span> Spring Cloud Spring</span><br></pre></td></tr></table></figure>

<h2 id="4-什么是SpringCloud"><a href="#4-什么是SpringCloud" class="headerlink" title="4.什么是SpringCloud"></a>4.什么是SpringCloud</h2><blockquote>
<p>springcloud是一个含概多个子项目的开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.SpringCloud在整合过程中主要是针对Netflix(耐非)开源组件的封装.SpringCloud的出现真正的简化了分布式架构的开发。NetFlix 是美国的一个在线视频网站,微服务业的翘楚,他是公认的大规模生产级微服务的杰出实践者,NetFlix的开源组件已经在他大规模分布式微服务环境中经过多年的生产实战验证,因此Spring Cloud中很多组件都是基于NetFlix</p>
</blockquote>
<h3 id="核心架构及其组件"><a href="#核心架构及其组件" class="headerlink" title="核心架构及其组件"></a>核心架构及其组件</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.核心组件说明</span></span><br><span class="line"><span class="bullet">-</span> eurekaserver、consul、nacos  	 服务注册中心组件</span><br><span class="line"><span class="bullet">-</span> rabbion &amp; openfeign  			  服务负载均衡 和 服务调用组件</span><br><span class="line"><span class="bullet">-</span> hystrix &amp; hystrix dashboard     服务断路器  和  服务监控组件</span><br><span class="line"><span class="bullet">-</span> zuul、gateway 					 服务网关组件</span><br><span class="line"><span class="bullet">-</span> config 						  统一配置中心组件</span><br><span class="line"><span class="bullet">-</span> bus                             消息总线组件</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-环境搭建"><a href="#5-环境搭建" class="headerlink" title="5.环境搭建"></a>5.环境搭建</h2><h3 id="版本命名"><a href="#版本命名" class="headerlink" title="版本命名"></a>版本命名</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 伦敦地铁站名称 [了解]</span></span><br><span class="line"><span class="bullet">-</span> Angel、Brixton、Camden、Dalston、Edgware、Finchley、Greenwich、Hoxton</span><br></pre></td></tr></table></figure>

<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> Finchley 									版本基于springboot2.0.x版本进行构建,不能兼容1.x版本</span><br><span class="line"><span class="bullet">-</span> Greenwich									版本基于springboot2.1.x版本进行构建,不能兼容1.x版本</span><br><span class="line"><span class="bullet">-</span> Hoxton									版本基于springboot2.2.x版本进行构建</span><br></pre></td></tr></table></figure>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> springboot 2.2.5.RELEASE</span><br><span class="line"><span class="bullet">-</span> springcloud Hoxton.SR6</span><br><span class="line"><span class="bullet">-</span> java8</span><br><span class="line"><span class="bullet">-</span> maven 3.3.9 </span><br><span class="line"><span class="bullet">-</span> idea 2018.3.5</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.创建springboot项目 指定版本为 2.2.5版本</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.引入springcloud的版本管理</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义springcloud使用版本号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR6<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--全局管理springcloud版本,并不会引入具体依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.完成上述操作springboot与springcloud环境搭建完成</span></span><br><span class="line"><span class="bullet">-</span> 接下来就是使用到具体的springcloud组件,在项目中引入具体的组件即可</span><br></pre></td></tr></table></figure>

<h2 id="6-服务注册中心"><a href="#6-服务注册中心" class="headerlink" title="6.服务注册中心"></a>6.服务注册中心</h2><h3 id="什么服务注册中心"><a href="#什么服务注册中心" class="headerlink" title="什么服务注册中心"></a>什么服务注册中心</h3><p>所谓服务注册中心就是在整个的微服务架构中单独提出一个服务，这个服务不完成系统的任何的业务功能，仅仅用来完成对整个微服务系统的服务注册和服务发现，以及对服务健康状态的监控和管理功能。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务注册中心</span></span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务的信息进行存储，如微服务的名称、IP、端口等</span><br><span class="line"><span class="bullet">-</span> 可以在进行服务调用时通过服务发现查询可用的微服务列表及网络地址进行服务调用</span><br><span class="line"><span class="bullet">-</span> 可以对所有的微服务进行心跳检测，如发现某实例长时间无法访问，就会从服务注册表移除该实例。</span><br></pre></td></tr></table></figure>

<h3 id="常用的注册中心"><a href="#常用的注册中心" class="headerlink" title="常用的注册中心"></a>常用的注册中心</h3><p>springcloud支持的多种注册中心Eureka、Consul、Zookeeper、以及阿里巴巴推出Nacos。这些注册中心在本质上都是用来管理服务的注册和发现以及服务状态的检查的。</p>
<h4 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1.Eureka"></a>1.Eureka</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务。SpringCloud将它集成在其子项目spring-cloud-netflix中，		以实现SpringCloud的服务注册和发现功能。</span><br><span class="line"><span class="bullet">-</span> Eureka包含两个组件：Eureka Server和Eureka Client。</span><br></pre></td></tr></table></figure>

<h5 id="Eureka-停止更新不推荐使用了"><a href="#Eureka-停止更新不推荐使用了" class="headerlink" title="Eureka 停止更新不推荐使用了"></a>Eureka 停止更新不推荐使用了</h5><h4 id="2-Consul"><a href="#2-Consul" class="headerlink" title="2.Consul"></a>2.Consul</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.consul 简介</span></span><br><span class="line"><span class="bullet">-</span> https://www.consul.io</span><br><span class="line"><span class="bullet">-</span> consul是一个可以提供服务发现，健康检查，多数据中心，Key/Value存储等功能的分布式服务框架，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、Windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署。</span><br></pre></td></tr></table></figure>

<h5 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.下载consul</span></span><br><span class="line"><span class="bullet">-</span> https://www.consul.io/downloads</span><br><span class="line"><span class="section"># 2.安装consul</span></span><br><span class="line"><span class="section"># 3.根据解压缩目录配置环境变量</span></span><br><span class="line"><span class="section"># 4.查看consul环境变量是否配置成功,执行命令出现如下信息代表成功</span></span><br><span class="line"><span class="bullet">-</span> consul -v</span><br><span class="line"><span class="section"># 5.启动consul服务</span></span><br><span class="line"><span class="bullet">-</span> consul agent -dev</span><br><span class="line"><span class="section"># 6.访问consul的web服务端口</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:8500</span><br><span class="line"><span class="code">	`consul默认服务端口是8500</span></span><br></pre></td></tr></table></figure>

<h5 id="开发consul-客户端即微服务"><a href="#开发consul-客户端即微服务" class="headerlink" title="开发consul 客户端即微服务"></a>开发consul 客户端即微服务</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建项目并引入consul客户端依赖</span></span><br><span class="line">&lt;!--引入consul依赖--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.cloud<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-cloud-starter-consul-discovery<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="section"># 2.编写properties配置</span></span><br><span class="line">server.port=8889</span><br><span class="line">spring.application.name=consulclient8889</span><br><span class="line">spring.cloud.consul.host=localhost														#注册consul服务的主机</span><br><span class="line">spring.cloud.consul.port=8500																	#注册consul服务的端口号</span><br><span class="line"><span class="section"># 3.启动服务查看consul界面服务信息</span></span><br><span class="line"><span class="bullet">-</span> 访问localhost:8500</span><br></pre></td></tr></table></figure>

<h5 id="consul-开启健康监控检查"><a href="#consul-开启健康监控检查" class="headerlink" title="consul 开启健康监控检查"></a>consul 开启健康监控检查</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启consul健康监控</span></span><br><span class="line"><span class="bullet">-</span> 默认情况consul监控健康是开启的,但是必须依赖健康监控依赖才能正确监控健康状态所以直接启动会显示错误,引入健康监控依赖之后服务正常</span><br><span class="line">&lt;!-- 这个包是用做健康度监控的--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span></span>org.springframework.boot<span class="language-xml"><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span>spring-boot-starter-actuator<span class="language-xml"><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="consul-关闭健康监控检查"><a href="#consul-关闭健康监控检查" class="headerlink" title="consul 关闭健康监控检查"></a>consul 关闭健康监控检查</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.consul.discovery.register-health-check</span>=<span class="string">false	    						#关闭consu了服务的健康检查[不推荐]</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">$&#123;spring.application.name&#125; 					#指定注册的服务名称 默认就是应用名</span></span><br></pre></td></tr></table></figure>

<h3 id="不同注册中心区别"><a href="#不同注册中心区别" class="headerlink" title="不同注册中心区别"></a>不同注册中心区别</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.CAP定理</span></span><br><span class="line"><span class="bullet">-</span> CAP定理：CAP定理又称CAP原则，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</span><br><span class="line"><span class="code">	`一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</span></span><br><span class="line"><span class="code">	`可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</span></span><br><span class="line"><span class="code">	`分区容忍性（P），就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.Eureka特点</span></span><br><span class="line"><span class="bullet">-</span> Eureka中没有使用任何的数据强一致性算法保证不同集群间的Server的数据一致，仅通过数据拷贝的方式争取注册中心数据的最终一致性，虽然放弃数据强一致性但是换来了Server的可用性，降低了注册的代价，提高了集群运行的健壮性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.Consul特点</span></span><br><span class="line"><span class="bullet">-</span> 基于Raft算法，Consul提供强一致性的注册中心服务，但是由于Leader节点承担了所有的处理工作，势必加大了注册和发现的代价，降低了服务的可用性。通过Gossip协议，Consul可以很好地监控Consul集群的运行，同时可以方便通知各类事件，如Leader选择发生、Server地址变更等。</span><br><span class="line"></span><br><span class="line"><span class="section"># 4.zookeeper特点</span></span><br><span class="line"><span class="bullet">-</span> 基于Zab协议，Zookeeper可以用于构建具备数据强一致性的服务注册与发现中心，而与此相对地牺牲了服务的可用性和提高了注册需要的时间。</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CWeiBo%5Csource%5Cnotes%5Cimages%5Cimage-20210527110515877.png" alt="image-20210527110515877"></p>
<hr>
<h2 id="7-服务间通信方式"><a href="#7-服务间通信方式" class="headerlink" title="7. 服务间通信方式"></a>7. 服务间通信方式</h2><p>接下来在整个微服务架构中,我们比较关心的就是服务间的服务改如何调用,有哪些调用方式?</p>
<blockquote>
<p>在springcloud中服务间调用方式主要是使用 http restful方式进行服务间调用</p>
</blockquote>
<h3 id="基于RestTemplate的服务调用"><a href="#基于RestTemplate的服务调用" class="headerlink" title="基于RestTemplate的服务调用"></a>基于RestTemplate的服务调用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。</span><br></pre></td></tr></table></figure>

<h4 id="1-RestTemplate-服务调用"><a href="#1-RestTemplate-服务调用" class="headerlink" title="1. RestTemplate 服务调用"></a>1. RestTemplate 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建两个服务并注册到consul注册中心中</span></span><br><span class="line"><span class="bullet">-</span> users    代表用户服务 端口为 9999</span><br><span class="line"><span class="bullet">-</span> products 代表商品服务 端口为 9998</span><br><span class="line"><span class="code">	`注意:这里服务仅仅用来测试,没有实际业务意义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.在商品服务中提供服务方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;商品服务查询所有调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;服务调用成功,服务提供端口为: &quot;</span>+port);</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在用户服务中使用restTemplate进行调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;调用用户服务...&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用restTemplate调用商品服务</span></span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:9998/product/findAll&quot;</span>, </span><br><span class="line">                                                     String.class);</span><br><span class="line">        <span class="keyword">return</span> forObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动服务</span></span><br><span class="line"><span class="section"># 5.测试服务调用</span></span><br><span class="line"><span class="bullet">-</span> 浏览器访问用户服务 http://localhost:9999/user/findAll</span><br><span class="line"><span class="section"># 6.总结</span></span><br><span class="line"><span class="bullet">-</span> rest Template是直接基于服务地址调用没有在服务注册中心获取服务,也没有办法完成服务的负载均衡如果需要实现服务的负载均衡需要自己书写服务负载均衡策略。</span><br></pre></td></tr></table></figure>

<h3 id="基于Ribbon的服务调用"><a href="#基于Ribbon的服务调用" class="headerlink" title="基于Ribbon的服务调用"></a>基于Ribbon的服务调用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 官方网址: https://github.com/Netflix/ribbon</span><br><span class="line"><span class="bullet">-</span> Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</span><br></pre></td></tr></table></figure>

<h4 id="1-Ribbon-服务调用"><a href="#1-Ribbon-服务调用" class="headerlink" title="1.Ribbon 服务调用"></a>1.Ribbon 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入依赖</span></span><br><span class="line"><span class="bullet">-</span> 说明: </span><br><span class="line"><span class="code">	1.如果使用的是eureka client 和 consul client,无须引入依赖,因为在eureka,consul中默认集成了ribbon组件</span></span><br><span class="line"><span class="code">	2.如果使用的client中没有ribbon依赖需要显式引入如下依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入ribbon依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.查看consul client中依赖的ribbon</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用restTemplate + ribbon进行服务调用</span></span><br><span class="line"><span class="bullet">-</span> 使用discovery client  进行客户端调用</span><br><span class="line"><span class="bullet">-</span> 使用loadBalanceClient 进行客户端调用</span><br><span class="line"><span class="bullet">-</span> 使用@loadBalanced     进行客户端调用</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.1 使用discovery Client形式调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取服务列表</span></span><br><span class="line">List&lt;ServiceInstance&gt; products = discoveryClient.getInstances(<span class="string">&quot;服务ID&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (ServiceInstance product : products) &#123;</span><br><span class="line">  log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">  log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">  log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br><span class="line">  log.info(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.2 使用loadBalance Client形式调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"><span class="comment">//根据负载均衡策略选取某一个服务调用</span></span><br><span class="line"><span class="type">ServiceInstance</span> <span class="variable">product</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;服务ID&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.3 使用@loadBalanced</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.整合restTemplate + ribbon</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.调用服务位置注入RestTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="comment">//3.调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://服务ID/hello/hello?name=&quot;</span> + name, String.class);</span><br></pre></td></tr></table></figure>

<h4 id="2-Ribbon负载均衡策略"><a href="#2-Ribbon负载均衡策略" class="headerlink" title="2.Ribbon负载均衡策略"></a>2.Ribbon负载均衡策略</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.ribbon负载均衡算法</span></span><br><span class="line"><span class="bullet">-</span> RoundRobinRule         		轮询策略	按顺序循环选择 Server</span><br><span class="line"><span class="bullet">-</span> RandomRule             		随机策略	随机选择 Server</span><br><span class="line"><span class="bullet">-</span> AvailabilityFilteringRule 可用过滤策略</span><br><span class="line"> 	`会先过滤由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> WeightedResponseTimeRule  响应时间加权策略   </span><br><span class="line"><span class="code">	`根据平均响应的时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时如果统计信息不足，则使用		</span></span><br><span class="line"><span class="code">		RoundRobinRule策略，等统计信息足够会切换到</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> RetryRule                 重试策略          </span><br><span class="line"><span class="code">	`先按照RoundRobinRule的策略获取服务，如果获取失败则在制定时间内进行重试，获取可用的服务。</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- BestAviableRule           最低并发策略     </span></span><br><span class="line"><span class="code">	`会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务  </span></span><br></pre></td></tr></table></figure>

<h4 id="3-修改服务的默认负载均衡策略"><a href="#3-修改服务的默认负载均衡策略" class="headerlink" title="3.修改服务的默认负载均衡策略"></a>3.修改服务的默认负载均衡策略</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.修改服务默认随机策略</span></span><br><span class="line"><span class="bullet">-</span> 服务id.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule</span><br><span class="line"><span class="code">	`下面的products为服务的唯一标识</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">products.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Ribbon停止维护"><a href="#4-Ribbon停止维护" class="headerlink" title="4.Ribbon停止维护"></a>4.Ribbon停止维护</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.官方停止维护说明</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/ribbon</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-OpenFeign组件的使用"><a href="#8-OpenFeign组件的使用" class="headerlink" title="8.OpenFeign组件的使用"></a>8.OpenFeign组件的使用</h2><ul>
<li>思考: 使用RestTemplate+ribbon已经可以完成对端的调用，为什么还要使用feign？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">restTemplateForObject</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://服务名/url?参数&quot;</span> + name, String.class);</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 存在问题:</span></span><br><span class="line"><span class="bullet">-</span> 1.每次调用服务都需要写这些代码,存在大量的代码冗余</span><br><span class="line"><span class="bullet">-</span> 2.服务地址如果修改,维护成本增高</span><br><span class="line"><span class="bullet">-</span> 3.使用时不够灵活</span><br></pre></td></tr></table></figure>

<h3 id="OpenFeign-组件"><a href="#OpenFeign-组件" class="headerlink" title="OpenFeign 组件"></a>OpenFeign 组件</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-openfeign/reference/html/</span><br><span class="line"><span class="bullet">-</span> Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性(可以使用springmvc的注解)，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，默认实现了负载均衡的效果并且springcloud为feign添加了springmvc注解的支持。</span><br></pre></td></tr></table></figure>

<h4 id="1-openFeign-服务调用"><a href="#1-openFeign-服务调用" class="headerlink" title="1.openFeign 服务调用"></a>1.openFeign 服务调用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务调用方法引入依赖OpenFeign依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Open Feign依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.入口类加入注解开启OpenFeign支持</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Users9999Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Users9999Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.创建一个客户端调用接口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//value属性用来指定:调用服务名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/findAll&quot;)</span> <span class="comment">//书写服务调用路径</span></span><br><span class="line">    String <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.使用feignClient客户端对象调用服务</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/findAllFeignClient&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findAllFeignClient</span><span class="params">()</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;通过使用OpenFeign组件调用商品服务...&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> productClient.findAll();</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.访问并测试服务</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:9999/user/findAllFeignClient</span><br></pre></td></tr></table></figure>

<h4 id="2-调用服务并传参"><a href="#2-调用服务并传参" class="headerlink" title="2.调用服务并传参"></a>2.调用服务并传参</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 服务和服务之间通信,不仅仅是调用,往往在调用过程中还伴随着参数传递,接下来重点来看看OpenFeign在调用服务时如何传递参数</span><br></pre></td></tr></table></figure>

<h6 id="GET方式调用服务传递参数"><a href="#GET方式调用服务传递参数" class="headerlink" title="GET方式调用服务传递参数"></a>GET方式调用服务传递参数</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.GET方式调用服务传递参数</span></span><br><span class="line"><span class="bullet">-</span> 在商品服务中加入需要传递参数的服务方法来进行测试</span><br><span class="line"><span class="bullet">-</span> 在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.商品服务中添加如下方法</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/product/findOne&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">findOne</span><span class="params">(String productId)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品信息的id:[&#123;&#125;]&quot;</span>,productId);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;productId&quot;</span>,productId);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123; </span><br><span class="line">	<span class="meta">@GetMapping(&quot;/product/findOne&quot;)</span></span><br><span class="line"> 	String <span class="title function_">findOne</span><span class="params">(<span class="meta">@RequestParam(&quot;productId&quot;)</span> String productId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.用户服务中调用并传递参数</span></span><br><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/findAllFeignClient&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findAllFeignClient</span><span class="params">()</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;通过使用OpenFeign组件调用商品服务...&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> productClient.findAll();</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="post方式调用服务传递参数"><a href="#post方式调用服务传递参数" class="headerlink" title="post方式调用服务传递参数"></a>post方式调用服务传递参数</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.post方式调用服务传递参数</span></span><br><span class="line"><span class="bullet">-</span> 在商品服务中加入需要传递参数的服务方法来进行测试</span><br><span class="line"><span class="bullet">-</span> 在用户服务中进行调用商品服务中需要传递参数的服务方法进行测试</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.商品服务加入post方式请求并接受name</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/product/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">save</span><span class="params">(String name)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务保存商品调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品名称:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="comment">//value属性用来指定:调用服务名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/product/save&quot;)</span></span><br><span class="line">    String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.用户服务中调用并传递参数</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(String productName)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收到的商品信息名称:[&#123;&#125;]&quot;</span>,productName);</span><br><span class="line">  <span class="type">String</span> <span class="variable">save</span> <span class="operator">=</span> productClient.save(productName);</span><br><span class="line">  log.info(<span class="string">&quot;调用成功返回结果: &quot;</span>+save);</span><br><span class="line">  <span class="keyword">return</span> save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.传递对象类型参数</span></span><br><span class="line"><span class="bullet">-</span> 商品服务定义对象</span><br><span class="line"><span class="bullet">-</span> 商品服务定义对象接收方法</span><br><span class="line"><span class="bullet">-</span> 用户服务调用商品服务定义对象参数方法进行参数传递</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.商品服务定义对象</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date bir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.商品服务定义接收对象的方法</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/product/saveProduct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">saveProduct</span><span class="params">(<span class="meta">@RequestBody</span> Product product)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;商品服务保存商品信息调用成功,当前服务端口:[&#123;&#125;]&quot;</span>,port);</span><br><span class="line">  log.info(<span class="string">&quot;当前接收商品名称:[&#123;&#125;]&quot;</span>,product);</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;商品服务查询商品信息调用成功,当前服务端口: &quot;</span>+port);</span><br><span class="line">  map.put(<span class="string">&quot;status&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">  map.put(<span class="string">&quot;product&quot;</span>,product);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.将商品对象复制到用户服务中</span></span><br><span class="line"><span class="comment">//4.用户服务中在product客户端中声明方法</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;PRODUCTS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(&quot;/product/saveProduct&quot;)</span></span><br><span class="line">  String <span class="title function_">saveProduct</span><span class="params">(<span class="meta">@RequestBody</span> Product product)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.在用户服务中调用保存商品信息服务</span></span><br><span class="line"><span class="comment">//注入客户端对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/saveProduct&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveProduct</span><span class="params">(Product product)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收到的商品信息:[&#123;&#125;]&quot;</span>,product);</span><br><span class="line">  <span class="type">String</span> <span class="variable">save</span> <span class="operator">=</span> productClient.saveProduct(product);</span><br><span class="line">  log.info(<span class="string">&quot;调用成功返回结果: &quot;</span>+save);</span><br><span class="line">  <span class="keyword">return</span> save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-OpenFeign超时设置"><a href="#3-OpenFeign超时设置" class="headerlink" title="3.OpenFeign超时设置"></a>3.OpenFeign超时设置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.超时说明</span></span><br><span class="line"><span class="bullet">-</span> 默认情况下,openFiegn在进行服务调用时,要求服务提供方处理业务逻辑时间必须在1S内返回,如果超过1S没有返回则OpenFeign会直接报错,不会等待服务执行,但是往往在处理复杂业务逻辑是可能会超过1S,因此需要修改OpenFeign的默认服务调用超时时间。</span><br><span class="line"><span class="bullet">-</span> 调用超时会出现如下错误：</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.模拟超时</span></span><br><span class="line"><span class="bullet">-</span> 服务提供方加入线程等待阻塞</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.进行客户端调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.修改OpenFeign默认超时时间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign.client.config.PRODUCTS.connectTimeout</span>=<span class="string">5000  		#配置指定服务连接超时</span></span><br><span class="line"><span class="attr">feign.client.config.PRODUCTS.readTimeout</span>=<span class="string">5000		  	#配置指定服务等待超时</span></span><br><span class="line"><span class="comment">#feign.client.config.default.connectTimeout=5000  		#配置所有服务连接超时</span></span><br><span class="line"><span class="comment">#feign.client.config.default.readTimeout=5000			#配置所有服务等待超时</span></span><br></pre></td></tr></table></figure>

<h4 id="4-OpenFeign调用详细日志展示"><a href="#4-OpenFeign调用详细日志展示" class="headerlink" title="4.OpenFeign调用详细日志展示"></a>4.OpenFeign调用详细日志展示</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> 往往在服务调用时我们需要详细展示feign的日志,默认feign在调用是并不是最详细日志输出,因此在调试程序时应该开启feign的详细日志展示。feign对日志的处理非常灵活可为每个feign客户端指定日志记录策略，每个客户端都会创建一个logger默认情况下logger的名称是feign的全限定名需要注意的是，feign日志的打印只会DEBUG级别做出响应。</span><br><span class="line"><span class="bullet">-</span> 我们可以为feign客户端配置各自的logger.lever对象，告诉feign记录那些日志logger.lever有以下的几种值</span><br><span class="line"><span class="code">	`NONE  不记录任何日志</span></span><br><span class="line"><span class="code">	`BASIC 仅仅记录请求方法，url，响应状态代码及执行时间</span></span><br><span class="line"><span class="code">	`HEADERS 记录Basic级别的基础上，记录请求和响应的header</span></span><br><span class="line"><span class="code">	`FULL 记录请求和响应的header，body和元数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.开启日志展示</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign.client.config.PRODUCTS.loggerLevel</span>=<span class="string">full  #开启指定服务日志展示</span></span><br><span class="line"><span class="comment">#feign.client.config.default.loggerLevel=full  #全局开启服务日志展示</span></span><br><span class="line"><span class="attr">logging.level.com.baizhi.feignclients</span>=<span class="string">debug    #指定feign调用客户端对象所在包,必须是debug级别</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.测试服务调用查看日志</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-Hystrix组件使用"><a href="#9-Hystrix组件使用" class="headerlink" title="9.Hystrix组件使用"></a>9.Hystrix组件使用</h2><h3 id="Hystrix组件"><a href="#Hystrix组件" class="headerlink" title="Hystrix组件"></a>Hystrix组件</h3><p>In a distributed environment, inevitably some of the many service dependencies will fail. Hystrix is a library that helps you control the interactions between these distributed services by adding latency tolerance and fault tolerance logic. Hystrix does this by isolating points of access between the services, stopping cascading failures across them, and providing fallback options, all of which improve your system’s overall resiliency.        –[摘自官方]</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/Hystrix</span><br><span class="line"><span class="bullet">-</span> 译: 在分布式环境中，许多服务依赖项不可避免地会失败。Hystrix是一个库，它通过添加延迟容忍和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、停止它们之间的级联故障以及提供后备选项来实现这一点，所有这些都可以提高系统的整体弹性。</span><br><span class="line"><span class="bullet">-</span> 通俗定义: Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障(服务雪崩现象)，提高分布式系统的弹性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 1.作用</span></span><br><span class="line"><span class="bullet">-</span> hystrix 用来保护微服务系统 实现 服务降级  服务熔断</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 服务雪崩  </span><br><span class="line"><span class="bullet">-</span> 服务降级</span><br><span class="line"><span class="bullet">-</span> 服务熔断</span><br></pre></td></tr></table></figure>

<h4 id="1-服务雪崩"><a href="#1-服务雪崩" class="headerlink" title="1.服务雪崩"></a>1.服务雪崩</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.服务雪崩</span></span><br><span class="line"><span class="bullet">-</span> 在微服务之间进行服务调用是由于某一个服务故障，导致级联服务故障的现象，称为雪崩效应。雪崩效应描述的是提供方不可用，导致消费方不可用并将不可用逐渐放大的过程。</span><br><span class="line"><span class="section"># 2.图解雪崩效应</span></span><br><span class="line"><span class="bullet">-</span> 如存在如下调用链路:</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 而此时，Service A的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求。此时，如果Service C因为抗不住请求，变得不可用。那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用。紧接着，Service A也会不可用，这一过程如下图所示</span><br></pre></td></tr></table></figure>

<h4 id="2-服务熔断"><a href="#2-服务熔断" class="headerlink" title="2.服务熔断"></a>2.服务熔断</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务熔断</span></span><br><span class="line"><span class="bullet">-</span> “熔断器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器(hystrix)的故障监控，某个异常条件被触发，直接熔断整个服务。向调用方法返回一个符合预期的、可处理的备选响应(FallBack),而不是长时间的等待或者抛出调用方法无法处理的异常，就保证了服务调用方的线程不会被长时间占用，避免故障在分布式系统中蔓延，乃至雪崩。如果目标服务情况好转则恢复调用。服务熔断是解决服务雪崩的重要手段。</span><br><span class="line"></span><br><span class="line"><span class="section"># 服务熔断图示</span></span><br></pre></td></tr></table></figure>

<h4 id="3-服务降级"><a href="#3-服务降级" class="headerlink" title="3.服务降级"></a>3.服务降级</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务降级说明</span></span><br><span class="line"><span class="bullet">-</span> 服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行。同时保证部分甚至大部分任务客户能得到正确的响应。也就是当前的请求处理不了了或者出错了，给一个默认的返回。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 服务降级: 关闭微服务系统中某些边缘服务 保证系统核心服务正常运行</span><br><span class="line"><span class="bullet">-</span> 12 淘宝  京东</span><br><span class="line"><span class="bullet">-</span> 删除订单 --- 关闭订单    确认收货 ----&gt;     服务繁忙,!!!</span><br><span class="line"></span><br><span class="line"><span class="section"># 服务降级图示</span></span><br></pre></td></tr></table></figure>

<h4 id="4-降级和熔断总结"><a href="#4-降级和熔断总结" class="headerlink" title="4.降级和熔断总结"></a>4.降级和熔断总结</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.共同点</span></span><br><span class="line"><span class="bullet">-</span> 目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</span><br><span class="line"><span class="bullet">-</span> 最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</span><br><span class="line"><span class="bullet">-</span> 粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</span><br><span class="line"><span class="bullet">-</span> 自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；sentinel</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.异同点</span></span><br><span class="line"><span class="bullet">-</span> 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</span><br><span class="line"><span class="bullet">-</span> 管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务边缘服务开始）</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.总结</span></span><br><span class="line"><span class="bullet">-</span> 熔断必会触发降级,所以熔断也是降级一种,区别在于熔断是对调用链路的保护,而降级是对系统过载的一种保护处理</span><br></pre></td></tr></table></figure>

<h4 id="5-服务熔断的实现"><a href="#5-服务熔断的实现" class="headerlink" title="5.服务熔断的实现"></a>5.服务熔断的实现</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.服务熔断的实现思路</span></span><br><span class="line"><span class="bullet">-</span> 引入hystrix依赖,并开启熔断器(断路器)</span><br><span class="line"><span class="bullet">-</span> 模拟降级方法</span><br><span class="line"><span class="bullet">-</span> 进行调用测试</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入hystrix依赖 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启断路器</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span>  <span class="comment">//用来开启断路器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Products9998Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Products9998Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用HystrixCommand注解实现断路</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/product/break&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;testBreakFall&quot; )</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testBreak</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收的商品id为: &quot;</span>+ id);</span><br><span class="line">  <span class="keyword">if</span>(id&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数据不合法!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;当前接收商品id: &quot;</span>+id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testBreakFall</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;当前数据不合法: &quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.访问测试</span></span><br><span class="line"><span class="bullet">-</span> 正常参数访问</span><br><span class="line"><span class="bullet">-</span> 错误参数访问</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.总结</span></span><br><span class="line"><span class="bullet">-</span> 从上面演示过程中会发现如果触发一定条件断路器会自动打开,过了一点时间正常之后又会关闭。那么断路器打开条件是什么呢？</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.断路器打开条件</span></span><br><span class="line"><span class="bullet">-</span> 官网: https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix</span><br></pre></td></tr></table></figure>

<p>A service failure in the lower level of services can cause cascading failure all the way up to the user. When calls to a particular service exceed <code>circuitBreaker.requestVolumeThreshold</code> (default: 20 requests) and the failure percentage is greater than <code>circuitBreaker.errorThresholdPercentage</code> (default: &gt;50%) in a rolling window defined by <code>metrics.rollingStats.timeInMilliseconds</code> (default: 10 seconds), the circuit opens and the call is not made. In cases of error and an open circuit, a fallback can be provided by the developer.                                                                        –摘自官方</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 原文翻译之后,总结打开关闭的条件:</span></span><br><span class="line"><span class="bullet">-</span> 1、  当满足一定的阀值的时候（默认10秒内超过20个请求次数）</span><br><span class="line"><span class="bullet">-</span> 2、  当失败率达到一定的时候（默认10秒内超过50%的请求失败）</span><br><span class="line"><span class="bullet">-</span> 3、  到达以上阀值，断路器将会开启</span><br><span class="line"><span class="bullet">-</span> 4、  当开启的时候，所有请求都不会进行转发</span><br><span class="line"><span class="bullet">-</span> 5、  一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。</span><br><span class="line"></span><br><span class="line"><span class="section"># 面试重点问题: 断路器流程</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.默认的服务FallBack处理方法</span></span><br><span class="line"><span class="bullet">-</span> 如果为每一个服务方法开发一个降级,对于我们来说,可能会出现大量的代码的冗余,不利于维护,这个时候就需要加入默认服务降级处理方法</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/product/hystrix&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;testHystrixFallBack&quot;)</span> <span class="comment">//通过HystrixCommand降级处理 指定出错的方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHystrix</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  log.info(<span class="string">&quot;接收名称为: &quot;</span> + name);</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;服务[&quot;</span> + port + <span class="string">&quot;]响应成功,当前接收名称为:&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务降级处理</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHystrixFallBack</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> port + <span class="string">&quot;当前服务已经被降级处理!!!,接收名称为: &quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-服务降级的实现"><a href="#6-服务降级的实现" class="headerlink" title="6.服务降级的实现"></a>6.服务降级的实现</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务降级: 站在系统整体负荷角度 实现: 关闭系统中某些边缘服务 保证系统核心服务运行</span></span><br><span class="line"><span class="code">	Emps 核心服务   Depts 边缘服务</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 1.客户端openfeign + hystrix实现服务降级实现</span></span><br><span class="line"><span class="bullet">-</span> 引入hystrix依赖</span><br><span class="line"><span class="bullet">-</span> 配置文件开启feign支持hystrix</span><br><span class="line"><span class="bullet">-</span> 在feign客户端调用加入fallback指定降级处理</span><br><span class="line"><span class="bullet">-</span> 开发降级处理方法</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启openfeign支持服务降级</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign.hystrix.enabled</span>=<span class="string">true #开启openfeign支持降级</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在openfeign客户端中加如Hystrix</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;PRODUCTS&quot;,fallback = ProductFallBack.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/hystrix&quot;)</span></span><br><span class="line">    String <span class="title function_">testHystrix</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.开发fallback处理类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductFallBack</span> <span class="keyword">implements</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHystrix</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是客户端的Hystrix服务实现!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-Hystrix-Dashboard-仪表盘"><a href="#7-Hystrix-Dashboard-仪表盘" class="headerlink" title="7.Hystrix Dashboard(仪表盘)"></a>7.Hystrix Dashboard(仪表盘)</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Hystrix DashBoard 仪表盘 </span></span><br><span class="line"></span><br><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> Hystrix Dashboard的一个主要优点是它收集了关于每个HystrixCommand的一组度量。Hystrix仪表板以高效的方式显示每个断路器的运行状况。</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入hystrix dashboard 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.入口类中开启hystrix dashboard</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span> <span class="comment">//开启监控面板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hystrixdashboard9990Application</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(Hystrixdashboard9990Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动hystrix dashboard应用</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:9990(dashboard端口)/hystrix</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.监控的项目中入口类中加入监控路径配置[新版本坑],并启动监控项目</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">  <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">  registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">  registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">  registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.通过监控界面监控</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.点击监控,一致loading,打开控制台发现报错[特别坑]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 解决方案</span></span><br><span class="line"><span class="bullet">-</span> 新版本中springcloud将jquery版本升级为3.4.1，定位到monitor.ftlh文件中，js的写法如下：</span><br><span class="line"><span class="code">	$(window).load(function() </span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- jquery 3.4.1已经废弃上面写法</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 修改方案 修改monitor.ftlh为如下调用方式：</span><br><span class="line"><span class="code">	$(window).on(&quot;load&quot;,function()</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- 编译jar源文件，重新打包引入后，界面正常响应。</span></span><br></pre></td></tr></table></figure>

<h4 id="8-Hystrix停止维护"><a href="#8-Hystrix停止维护" class="headerlink" title="8.Hystrix停止维护"></a>8.Hystrix停止维护</h4><p><img src="C:%5CUsers%5CYueYang%5CDocuments%5CGitHub%5CStudyNote%5Cimg%5Cimage-20200717161400285.png" alt="image-20200717161400285"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 官方地址:https://github.com/Netflix/Hystrix</span></span><br><span class="line"><span class="bullet">-</span> 翻译:Hystrix（版本1.5.18）足够稳定，可以满足Netflix对我们现有应用的需求。同时，我们的重点已经转移到对应用程序的实时性能作出反应的更具适应性的实现，而不是预先配置的设置（例如，通过自适应并发限制）。对于像Hystrix这样的东西有意义的情况，我们打算继续在现有的应用程序中使用Hystrix，并在新的内部项目中利用诸如resilience4j这样的开放和活跃的项目。我们开始建议其他人也这样做。 ----&gt; sentinel 流量卫兵</span><br><span class="line"><span class="bullet">-</span> Dashboard也被废弃</span><br></pre></td></tr></table></figure>

<h2 id="10-Gateway组件使用"><a href="#10-Gateway组件使用" class="headerlink" title="10.Gateway组件使用"></a>10.Gateway组件使用</h2><h3 id="什么是服务网关"><a href="#什么是服务网关" class="headerlink" title="什么是服务网关"></a>什么是服务网关</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 网关统一服务入口，可方便实现对平台众多服务接口进行管控，对访问服务的身份认证、防报文重放与防数据篡改、功能调用的业务鉴权、响应数据的脱敏、流量与并发控制，甚至基于API调用的计量或者计费等等。</span><br><span class="line"><span class="bullet">-</span> 网关 =  路由转发 + 过滤器</span><br><span class="line"><span class="code">	`路由转发：接收一切外界请求，转发到后端的微服务上去；</span></span><br><span class="line"><span class="code">	`在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 2.为什么需要网关</span></span><br><span class="line"><span class="code"> - 1.网关可以实现服务的统一管理</span></span><br><span class="line"><span class="code"> - 2.网关可以解决微服务中通用代码的冗余问题(如权限控制,流量监控,限流等)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.网关组件在微服务中架构</span></span><br></pre></td></tr></table></figure>

<h3 id="服务网关组件"><a href="#服务网关组件" class="headerlink" title="服务网关组件"></a>服务网关组件</h3><h4 id="zuul-1-x-2-x-netflix-组件"><a href="#zuul-1-x-2-x-netflix-组件" class="headerlink" title="zuul 1.x  2.x(netflix 组件)"></a>zuul 1.x  2.x(netflix 组件)</h4><p>Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security.</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/Netflix/zuul/wiki</span><br><span class="line"><span class="bullet">-</span> zul是从设备和网站到Netflix流媒体应用程序后端的所有请求的前门。作为一个边缘服务应用程序，zul被构建为支持动态路由、监视、弹性和安全性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.zuul版本说明</span></span><br><span class="line"><span class="bullet">-</span> 目前zuul组件已经从1.0更新到2.0，但是作为springcloud官方不再推荐使用zuul2.0，但是依然支持zuul2.</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.springcloud 官方集成zuul文档</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-netflix/2.2.x/reference/html/#netflix-zuul-starter</span><br></pre></td></tr></table></figure>

<h4 id="gateway-spring"><a href="#gateway-spring" class="headerlink" title="gateway (spring)"></a>gateway (spring)</h4><p>This project provides a library for building an API Gateway on top of Spring MVC. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> https://spring.io/projects/spring-cloud-gateway</span><br><span class="line"><span class="bullet">-</span> 这个项目提供了一个在springmvc之上构建API网关的库。springcloudgateway旨在提供一种简单而有效的方法来路由到api，并为api提供横切关注点，比如：安全性、监控/度量和弹性。</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.特性</span></span><br><span class="line"><span class="bullet">-</span> 基于springboot2.x 和 spring webFlux 和 Reactor 构建 响应式异步非阻塞IO模型</span><br><span class="line"><span class="bullet">-</span> 动态路由</span><br><span class="line"><span class="bullet">-</span> 请求过滤</span><br></pre></td></tr></table></figure>

<h6 id="1-开发网关动态路由"><a href="#1-开发网关动态路由" class="headerlink" title="1.开发网关动态路由"></a>1.开发网关动态路由</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.翻译</span></span><br><span class="line"><span class="bullet">-</span> 网关配置有两种方式一种是快捷方式(Java代码编写网关),一种是完全展开方式(配置文件方式)[推荐]</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.创建项目引入网关依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入gateway网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>快捷方式配置路由</strong></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写网关配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span>							<span class="comment"># 指定路由唯一标识</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9999/</span> <span class="comment"># 指定路由服务的地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span>					  <span class="comment"># 指定路由规则</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9998/</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8989</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动gateway网关项目</span></span><br><span class="line"><span class="bullet">-</span> 直接启动报错:</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 在启动日志中发现,gateway为了效率使用webflux进行异步非阻塞模型的实现,因此和原来的web包冲突,去掉原来的web即可</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 再次启动成功启动</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.测试网关路由转发</span></span><br><span class="line"><span class="bullet">-</span> 测试通过网关访问用户服务: http://localhost:8989/user/findOne?productId=21</span><br><span class="line"><span class="bullet">-</span> 测试通过网关访问商品服务: http://localhost:8989/product/findOne?productId=1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>java方式配置路由</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(<span class="string">&quot;order_route&quot;</span>, r -&gt; r.path(<span class="string">&quot;/order/**&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://localhost:9997&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-查看网关路由规则列表"><a href="#2-查看网关路由规则列表" class="headerlink" title="2.查看网关路由规则列表"></a>2.查看网关路由规则列表</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> gateway提供路由访问规则列表的web界面,但是默认是关闭的,如果想要查看服务路由规则可以在配置文件中开启</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>   <span class="comment">#开启所有web端点暴露</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 访问路由管理列表地址</span><br><span class="line"><span class="bullet">-</span> http://localhost:8989/actuator/gateway/routes</span><br></pre></td></tr></table></figure>

<h6 id="3-配置路由服务负载均衡"><a href="#3-配置路由服务负载均衡" class="headerlink" title="3.配置路由服务负载均衡"></a>3.配置路由服务负载均衡</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 现有路由配置方式,都是基于服务地址写死的路由转发,能不能根据服务名称进行路由转发同时实现负载均衡的呢?</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.动态路由以及负载均衡转发配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9999/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://users</span>							<span class="comment"># lb代表转发后台服务使用负载均衡,users代表服务注册中心上的服务名</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9998/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://products</span>          <span class="comment"># lb(loadbalance)代表负载均衡转发路由</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product/**</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> 							<span class="comment">#开启根据服务名动态获取路由</span></span><br></pre></td></tr></table></figure>

<h6 id="4-常用路由predicate-断言-验证"><a href="#4-常用路由predicate-断言-验证" class="headerlink" title="4.常用路由predicate(断言,验证)"></a>4.常用路由predicate(断言,验证)</h6><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.Gateway支持多种方式的predicate</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> After=2020-07-21T11:33:33.993+08:00[Asia/Shanghai]  			`指定日期之后的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Before=2020-07-21T11:33:33.993+08:00[Asia/Shanghai]       `指定日期之前的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]</span><br><span class="line"><span class="bullet">-</span> Cookie=username,chenyn																		`基于指定cookie的请求进行路由</span><br><span class="line"><span class="bullet">-</span> Cookie=username,[A-Za-z0-9]+															`基于指定cookie的请求进行路由	</span><br><span class="line"><span class="code">	`curl http://localhost:8989/user/findAll --cookie &quot;username=zhangsna&quot;</span></span><br><span class="line"><span class="code">- Header=X-Request-Id, \d+																 ``基于请求头中的指定属性的正则匹配路由(这里全是整数)</span></span><br><span class="line"><span class="code">	`curl http://localhost:8989/user/findAll -H &quot;X-Request-Id:11&quot;</span></span><br><span class="line"><span class="code">- Method=GET,POST																						 `基于指定的请求方式请求进行路由</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 官方更多: https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/#the-cookie-route-predicate-factory</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.使用predicate</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user_route</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:9999/</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://users</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">After=2020-07-21T11:39:33.993+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Cookie=username,[A-Za-z0-9]+</span></span><br><span class="line">            <span class="bullet">-</span>  <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<h6 id="5-常用的Filter以及自定义filter"><a href="#5-常用的Filter以及自定义filter" class="headerlink" title="5.常用的Filter以及自定义filter"></a>5.常用的Filter以及自定义filter</h6><p>Route filters allow the modification of the incoming HTTP request or outgoing HTTP response in some manner. Route filters are scoped to a particular route. Spring Cloud Gateway includes many built-in GatewayFilter Factories.</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.原文翻译</span></span><br><span class="line"><span class="bullet">-</span> 官网: </span><br><span class="line"><span class="code">	https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/#gatewayfilter-factories</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">- 路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。路由筛选器的作用域是特定路由。springcloudgateway包括许多内置的GatewayFilter工厂。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.作用</span></span><br><span class="line"><span class="bullet">-</span> 当我们有很多个服务时，比如下图中的user-service、order-service、product-service等服务，客户端请求各个服务的Api时，每个服务都需要做相同的事情，比如鉴权、限流、日志输出等。</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.使用内置过滤器</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> AddRequestHeader=X-Request-red, blue						<span class="code">`增加请求头的filter`</span></span><br><span class="line"><span class="bullet">-</span> AddRequestParameter=red, blue										<span class="code">`增加请求参数的filterr`</span></span><br><span class="line"><span class="bullet">-</span> AddResponseHeader=X-Response-Red, AAA						<span class="code">`增加响应头filter`</span></span><br><span class="line"><span class="bullet">-</span> PrefixPath=/emp																	<span class="code">`增加前缀的filter`</span></span><br><span class="line"><span class="bullet">-</span> StripPrefix=2																		<span class="code">`去掉前缀的filter`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.使用自定义filter</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;进入自定义的filter&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(exchange.getRequest().getQueryParams().get(<span class="string">&quot;username&quot;</span>)!=<span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户身份信息合法,放行请求继续执行!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;非法用户,拒绝访问!!!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="11-Config组件使用"><a href="#11-Config组件使用" class="headerlink" title="11.Config组件使用"></a>11.Config组件使用</h2><h3 id="什么是Config"><a href="#什么是Config" class="headerlink" title="什么是Config"></a>什么是Config</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.说明</span></span><br><span class="line"><span class="bullet">-</span> https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.3.RELEASE/reference/html/#<span class="emphasis">_spring_</span>cloud<span class="emphasis">_config_</span>server</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> config(配置)又称为 统一配置中心顾名思义,就是将配置统一管理,配置统一管理的好处是在日后大规模集群部署服务应用时相同的服务配置一致,日后再修改配置只需要统一修改全部同步,不需要一个一个服务手动维护。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 1.统一配置中心组件流程图</span></span><br></pre></td></tr></table></figure>

<h3 id="Config-Server-开发"><a href="#Config-Server-开发" class="headerlink" title="Config Server 开发"></a>Config Server 开发</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.引入依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入统一配置中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.开启统一配置中心服务</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configserver7878Application</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(Configserver7878Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.修改配置文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">7878</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">configserver</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.直接启动服务报错</span></span><br><span class="line"><span class="bullet">-</span>  没有指定远程仓库的相关配置</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.创建远程仓库</span></span><br><span class="line"><span class="bullet">-</span> github创建一个仓库</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.复制仓库地址</span></span><br><span class="line"><span class="bullet">-</span> https://github.com/chenyn-java/configservers.git</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.在统一配置中心服务中修改配置文件指向远程仓库地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.config.server.git.uri</span>=<span class="string">https://github.com/chenyn-java/configservers.git   指定仓库的url</span></span><br><span class="line"><span class="attr">spring.cloud.config.server.git.default-label</span>=<span class="string">master									指定访问的分支</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.username=       私有仓库访问用户名</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.password=		私有仓库访问密码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 8.再次启动统一配置中心</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 9.拉取远端配置 [<span class="string">三种方式</span>][<span class="symbol"></span>]</span></span><br><span class="line"><span class="bullet">-</span> 1. http://localhost:7878/test-xxxx.properties</span><br><span class="line"><span class="bullet">-</span> 2. http://localhost:7878/test-xxxx.json</span><br><span class="line"><span class="bullet">-</span> 3. http://localhost:7878/test-xxxx.yml</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.拉取远端配置规则</span></span><br><span class="line"><span class="bullet">-</span> label/name-profiles.yml|properties|json</span><br><span class="line"><span class="code">	`label   代表去那个分支获取 默认使用master分支</span></span><br><span class="line"><span class="code">	`name    代表读取那个具体的配置文件文件名称</span></span><br><span class="line"><span class="code">	`profile 代表读取配置文件环境</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 11.查看拉取配置详细信息</span></span><br><span class="line"><span class="bullet">-</span> http://localhost:7878/client/dev       [<span class="string">client:代表远端配置名称</span>][<span class="symbol">dev:代表远程配置的环境</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 12.指定分支和本地仓库位置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.config.server.git.basedir</span>=<span class="string">/localresp 		#一定要是一个空目录,在首次会将该目录清空</span></span><br><span class="line"><span class="attr">spring.cloud.config.server.git.default-label</span>=<span class="string">master</span></span><br></pre></td></tr></table></figure>

<h3 id="Config-Client-开发"><a href="#Config-Client-开发" class="headerlink" title="Config Client 开发"></a>Config Client 开发</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.项目中引入config client依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入config client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.编写配置文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.config.discovery.enabled</span>=<span class="string">true                #开启统一配置中心服务</span></span><br><span class="line"><span class="attr">spring.cloud.config.discovery.service-id</span>=<span class="string">configserver     #指定统一配置服务中心的服务唯一标识</span></span><br><span class="line"><span class="attr">spring.cloud.config.label</span>=<span class="string">master													#指定从仓库的那个分支拉取配置	</span></span><br><span class="line"><span class="attr">spring.cloud.config.name</span>=<span class="string">client														#指定拉取配置文件的名称</span></span><br><span class="line"><span class="attr">spring.cloud.config.profile</span>=<span class="string">dev														#指定拉取配置文件的环境</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.远程仓库创建配置文件</span></span><br><span class="line"><span class="bullet">-</span> client.properties										[<span class="string">用来存放公共配置</span>][<span class="symbol"></span>]</span><br><span class="line"><span class="code">	spring.application.name=configclient</span></span><br><span class="line"><span class="code">	spring.cloud.consul.host=localhost</span></span><br><span class="line"><span class="code">	spring.cloud.consul.port=8500</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> client-dev.properties  							[<span class="string">用来存放研发相关配置</span>][<span class="symbol">注意:这里端口为例,以后不同配置分别存放</span>]</span><br><span class="line"><span class="code">	server.port=9099</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> client-prod.properties							[<span class="string">用来存放生产相关配置</span>][<span class="symbol"></span>]</span><br><span class="line"><span class="code">	server.port=9098</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动客户端服务进行远程配置拉取测试</span></span><br><span class="line"><span class="bullet">-</span> 直接启动过程中发现无法启动直接报错</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 报错原因</span></span><br><span class="line"><span class="bullet">-</span> 项目中目前使用的是application.properties启动项目,使用这个配置文件在springboot项目启动过程中不会等待远程配置拉取,直接根据配置文件中内容启动,因此当需要注册中心,服务端口等信息时,远程配置还没有拉取到,所以直接报错</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 解决方案</span></span><br><span class="line"><span class="bullet">-</span> 应该在项目启动时先等待拉取远程配置,拉取远程配置成功之后再根据远程配置信息启动即可,为了完成上述要求springboot官方提供了一种解决方案,就是在使用统一配置中心时应该将微服务的配置文件名修改为bootstrap.(properties|yml),bootstrap.properties作为配置启动项目时,会优先拉取远程配置,远程配置拉取成功之后根据远程配置启动当前应用。</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 再次启动服务</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="手动配置刷新"><a href="#手动配置刷新" class="headerlink" title="手动配置刷新"></a>手动配置刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 在生产环境中,微服务可能非常多,每次修改完远端配置之后,不可能对所有服务进行重新启动,这个时候需要让修改配置的服务能够刷新远端修改之后的配置,从而不要每次重启服务才能生效,进一步提高微服务系统的维护效率。在springcloud中也为我们提供了手动刷新配置和自动刷新配置两种策略,这里我们先使用手动配置文件刷新。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.在config client端加入刷新暴露端点</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*          #开启所有web端点暴露</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.在需要刷新代码的类中加入刷新配置的注解</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;当前加载配置文件信息为:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.在远程配置中加入name并启动测试</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.启动之后直接访问</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.修改远程配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.修改之后在访问</span></span><br><span class="line"><span class="bullet">-</span> 发现并没有自动刷新配置?</span><br><span class="line"><span class="bullet">-</span> 必须调用刷新配置接口才能刷新配置</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 8.手动调用刷新配置接口</span></span><br><span class="line"><span class="bullet">-</span> curl -X POST http://localhost:9099/actuator/refresh</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 9.在次访问发现配置已经成功刷新</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-Bus组件的使用"><a href="#12-Bus组件的使用" class="headerlink" title="12.Bus组件的使用"></a>12.Bus组件的使用</h2><h3 id="什么是Bus-AMQP-RibbitMQ、Kafka）"><a href="#什么是Bus-AMQP-RibbitMQ、Kafka）" class="headerlink" title="什么是Bus (AMQP RibbitMQ、Kafka）"></a>什么是Bus (AMQP RibbitMQ、Kafka）</h3><p>Spring Cloud Bus links nodes of a distributed system with a lightweight message broker. This can then be used to broadcast state changes (e.g. configuration changes) or other management instructions. AMQP and Kafka broker implementations are included with the project. Alternatively, any <a href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream</a> binder found on the classpath will work out of the box as a transport.   –摘自官网</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.翻译</span></span><br><span class="line"><span class="bullet">-</span> https://spring.io/projects/spring-cloud-bus</span><br><span class="line"><span class="bullet">-</span> springcloudbus使用轻量级消息代理将分布式系统的节点连接起来。然后，可以使用它来广播状态更改（例如配置更改）或其他管理指令。AMQP和Kafka broker(中间件)实现包含在项目中。或者，在类路径上找到的任何springcloudstream绑定器都可以作为传输使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 通俗定义: bus称之为springcloud中消息总线,主要用来在微服务系统中实现远端配置更新时通过广播形式通知所有客户端刷新配置信息,避免手动重启服务的工作</span><br></pre></td></tr></table></figure>

<h3 id="搭建RabbitMQ服务"><a href="#搭建RabbitMQ服务" class="headerlink" title="搭建RabbitMQ服务"></a>搭建RabbitMQ服务</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.下载rabbitmq安装包 [][可以直接使用docker安装更方便]</span></span><br><span class="line"><span class="bullet">-</span> 官方安装包下载:https://www.rabbitmq.com/install-rpm.html#downloads</span><br><span class="line">[<span class="string">注意:</span>][<span class="symbol">这里安装包只能用于centos7.x系统</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.将rabbitmq安装包上传到linux系统中</span></span><br><span class="line"><span class="code">	erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code">	rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.安装Erlang依赖包</span></span><br><span class="line"><span class="code">	rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.安装RabbitMQ安装包(需要联网)</span></span><br><span class="line"><span class="code">	yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code">		注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要	</span></span><br><span class="line"><span class="code">				将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</span></span><br><span class="line"><span class="code"># 4.复制配置文件</span></span><br><span class="line"><span class="code">	cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.查看配置文件位置</span></span><br><span class="line"><span class="code">	ls /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.修改配置文件(参见下图:)</span></span><br><span class="line"><span class="code">	vim /etc/rabbitmq/rabbitmq.config </span></span><br></pre></td></tr></table></figure>

<p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.执行如下命令,启动rabbitmq中的插件管理</span></span><br><span class="line"><span class="code">	rabbitmq-plugins enable rabbitmq_management</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	出现如下说明:</span></span><br><span class="line"><span class="code">		Enabling plugins on node rabbit@localhost:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    The following plugins have been configured:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code">    Applying plugin configuration to rabbit@localhost...</span></span><br><span class="line"><span class="code">    The following plugins have been enabled:</span></span><br><span class="line"><span class="code">      rabbitmq_management</span></span><br><span class="line"><span class="code">      rabbitmq_management_agent</span></span><br><span class="line"><span class="code">      rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    set 3 plugins.</span></span><br><span class="line"><span class="code">    Offline change; changes will take effect at broker restart.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 8.启动RabbitMQ的服务</span></span><br><span class="line"><span class="code">	systemctl start rabbitmq-server</span></span><br><span class="line"><span class="code">	systemctl restart rabbitmq-server</span></span><br><span class="line"><span class="code">	systemctl stop rabbitmq-server</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.查看服务状态(见下图:)</span></span><br><span class="line"><span class="code">	systemctl status rabbitmq-server</span></span><br><span class="line"><span class="code">  ● rabbitmq-server.service - RabbitMQ broker</span></span><br><span class="line"><span class="code">     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span></span><br><span class="line"><span class="code">     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago</span></span><br><span class="line"><span class="code">   Main PID: 2904 (beam.smp)</span></span><br><span class="line"><span class="code">     Status: &quot;Initialized&quot;</span></span><br><span class="line"><span class="code">     CGroup: /system.slice/rabbitmq-server.service</span></span><br><span class="line"><span class="code">             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -</span></span><br><span class="line"><span class="code">             MBlmbcs...</span></span><br><span class="line"><span class="code">             ├─3220 erl_child_setup 32768</span></span><br><span class="line"><span class="code">             ├─3243 inet_gethost 4</span></span><br><span class="line"><span class="code">             └─3244 inet_gethost 4</span></span><br><span class="line"><span class="code">      .........</span></span><br><span class="line"><span class="code"># 10.启动出现如下错误:</span></span><br><span class="line"><span class="code">- 4月 21 10:10:50 bogon systemd[1]: Starting RabbitMQ broker...</span></span><br><span class="line"><span class="code">- 4月 21 10:11:11 bogon rabbitmq-server[1772]: ERROR: epmd error for host bogon: address (cannot connect to host/port)</span></span><br><span class="line"><span class="code">- 4月 21 10:11:11 bogon systemd[1]: rabbitmq-server.service: main process exited, code=exited, status=1/FAILURE</span></span><br><span class="line"><span class="code"> `解决方案`: </span></span><br><span class="line"><span class="code">   1. 修改主机名   vim /etc/hostname   修改为自己注解名  rabbimq   2.修改完必须重启</span></span><br><span class="line"><span class="code">   3. vim /etc/hosts   在文件中添加:  127.0.0.1   自己主机名(rabbitmq)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 10.关闭防火墙服务</span></span><br><span class="line"><span class="code">	systemctl disable firewalld</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span></span><br><span class="line"><span class="code">	systemctl stop firewalld   </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 11.访问web管理界面</span></span><br><span class="line"><span class="code">	http://10.15.0.8:15672/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 12.登录管理界面</span></span><br><span class="line"><span class="code">	username:  guest</span></span><br><span class="line"><span class="code">	password:  guest</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 13.MQ服务搭建成功</span></span><br></pre></td></tr></table></figure>

<h3 id="实现自动配置刷新"><a href="#实现自动配置刷新" class="headerlink" title="实现自动配置刷新"></a>实现自动配置刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在所有项目中引入bus依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入bus依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.配置统一配置中心连接到mq</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">localhost											#连接主机</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672														#连接mq端口</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">user												#连接mq用户名</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">password										#连接mq密码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.远端配置中加入连接mq配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.启动统一配置中心服务</span></span><br><span class="line"><span class="bullet">-</span> 正常启动</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 5.启动客户端服务</span></span><br><span class="line"><span class="bullet">-</span> 加入bus组件之后客户端启动报错</span><br><span class="line"><span class="bullet">-</span> 原因springcloud中默认链接不到远程服务器不会报错,但是在使用bus消息总线时必须开启连接远程服务失败报错</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.config.fail-fast</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 6.修改远程配置后在配置中心服务通过执行post接口刷新配置</span></span><br><span class="line"><span class="bullet">-</span> curl -X POST http://localhost:7878/actuator/bus-refresh</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 7.通过上述配置就实现了配置统一刷新</span></span><br></pre></td></tr></table></figure>

<h3 id="指定服务刷新配置"><a href="#指定服务刷新配置" class="headerlink" title="指定服务刷新配置"></a>指定服务刷新配置</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 默认情况下使用curl -X POST http://localhost:7878/actuator/bus-refresh这种方式刷新配置是全部广播形式,也就是所有的微服务都能接收到刷新配置通知,但有时我们修改的仅仅是某个服务的配置,这个时候对于其他服务的通知是多余的,因此就需要指定服务进行通知</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.指定服务刷新配置实现</span></span><br><span class="line"><span class="bullet">-</span> 指定端口刷新某个具体服务: curl -X POST http://localhost:7878/actuator/bus-refresh/configclient:9090</span><br><span class="line"><span class="bullet">-</span> 指定服务id刷新服务集群节点: curl -X POST http://localhost:7878/actuator/bus-refresh/configclient</span><br><span class="line"> 	[<span class="string">注意:</span>][<span class="symbol">configclient代表刷新服务的唯一标识</span>]</span><br></pre></td></tr></table></figure>

<h3 id="集成webhook实现自动刷新"><a href="#集成webhook实现自动刷新" class="headerlink" title="集成webhook实现自动刷新"></a>集成webhook实现自动刷新</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.配置webhooks</span></span><br><span class="line"><span class="bullet">-</span> 说明: git仓库提供一种特有机制: 这种机制就是一个监听机制    监听就是仓库提交事件 ...  触发对应事件执行</span><br><span class="line"><span class="bullet">-</span> javascript: 事件  事件源 html标签  事件: 触发特定动作click  ...  事件处理程序:函数</span><br><span class="line"><span class="bullet">-</span> 添加webhooks</span><br><span class="line"><span class="bullet">-</span> 在webhooks中添加刷新配置接口</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 内网穿透的网站: https://natapp.cn/</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.解决400错误问题</span></span><br><span class="line"><span class="bullet">-</span> 在配置中心服务端加入过滤器进行解决(springcloud中一个坑)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrlFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest)request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> (HttpServletResponse)response;</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(httpServletRequest.getRequestURI());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//只过滤/actuator/bus-refresh请求</span></span><br><span class="line">        <span class="keyword">if</span> (!url.endsWith(<span class="string">&quot;/bus-refresh&quot;</span>)) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取原始的body</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> readAsChars(httpServletRequest);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;original body:   &quot;</span>+ body);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用HttpServletRequest包装原始请求达到修改post请求中body内容的目的</span></span><br><span class="line">        <span class="type">CustometRequestWrapper</span> <span class="variable">requestWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustometRequestWrapper</span>(httpServletRequest);</span><br><span class="line"> </span><br><span class="line">        chain.doFilter(requestWrapper, response);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CustometRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CustometRequestWrapper</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read() == -<span class="number">1</span> ? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener readListener)</span> &#123;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="keyword">return</span> byteArrayInputStream.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readAsChars</span><span class="params">(HttpServletRequest request)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            br = request.getReader();</span><br><span class="line">            String str;</span><br><span class="line">            <span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != br)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="13-SpringCloud-微服务工具集总结"><a href="#13-SpringCloud-微服务工具集总结" class="headerlink" title="13. SpringCloud  微服务工具集总结"></a>13. SpringCloud  微服务工具集总结</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 服务间通信方式: 		RPC  、 Http 协议 (SpringCloud中)</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 1.服务注册中心组件:  Eureka  、 Consul</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.服务间通信实现 :  </span></span><br><span class="line"><span class="code">	 a.RestTemplate(HttpClient对象) + Ribbon组件(springcloud)</span></span><br><span class="line"><span class="code">	 b.openfegin(伪httpclient客户端组件 底层默认集成Ribbon)  推荐</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.微服务保护组件: 	Hystrix (防止服务雪崩现象)  Hystrix DashBoard 组件  维护状态</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 4.微服务网关组件: 	Zuul1.x  Zuul2.x(netflix组件)、Gateway(Spring 组件)</span></span><br><span class="line"><span class="code">	网关： 路由转发  +  过滤器（前置predicate   后置filter）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.统一配置中心组件:  Config (netflix)</span></span><br><span class="line"><span class="code">	作用: 用来将微服务中所有配置进行远程git仓库统一管理</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.消息总线:         Bus</span></span><br><span class="line"><span class="code">	作用: 用来通过消息中间件将所有微服务连接到一起,利用广播模型实现配置自动刷新机制</span></span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV1S5411c7hM">编程不良人之学习SpringCloud</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《人性的弱点》读书笔记</title>
    <url>/2023/02/03/%E3%80%8A%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>想要拿到高薪，必须在专业技能之外还具备表达能力、领导能力和激发他人工作热情的能力。</p>
<span id="more"></span>

<h1 id="《人性的弱点》"><a href="#《人性的弱点》" class="headerlink" title="《人性的弱点》"></a>《人性的弱点》</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">人际交往三原则</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 原则一：不要批评，不要指责，不要抱怨</span><br><span class="line"><span class="bullet">2.</span> 原则二：真心实意地感谢他人、赞美他人</span><br><span class="line"><span class="bullet">3.</span> 原则三：以他人需求为立足点</span><br><span class="line"></span><br><span class="line">赢得他们喜爱六原则</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 原则一：建立对他人的兴趣，真心诚意地关注他人</span><br><span class="line"><span class="bullet">2.</span> 原则二：微笑</span><br><span class="line"><span class="bullet">3.</span> 原则三：记住他们名字</span><br><span class="line"><span class="bullet">4.</span> 原则四：专注地倾听，鼓励他人谈论自己</span><br><span class="line"><span class="bullet">5.</span> 原则五：谈论对方感兴趣的事情</span><br><span class="line"><span class="bullet">6.</span> 原则六：真心实意地让对方知道他有多重要</span><br></pre></td></tr></table></figure>


<h2 id="人际交往篇"><a href="#人际交往篇" class="headerlink" title="人际交往篇"></a>人际交往篇</h2><h3 id="原则一：不要批评，不要指责，不要抱怨"><a href="#原则一：不要批评，不要指责，不要抱怨" class="headerlink" title="原则一：不要批评，不要指责，不要抱怨"></a>原则一：不要批评，不要指责，不要抱怨</h3><p>批评是无用的，它激起抵触，让人急于辩白；批评是危险的，它伤害自尊，甚至让人萌生恨意。</p>
<h3 id="原则二：真心实意地感谢他人、赞美他人"><a href="#原则二：真心实意地感谢他人、赞美他人" class="headerlink" title="原则二：真心实意地感谢他人、赞美他人"></a>原则二：真心实意地感谢他人、赞美他人</h3><p>该原则的依据是：人们希望“感到自己重要”</p>
<p>西格蒙德·弗洛伊德称，对性和成功的欲望是人类的永恒动机。</p>
<p>人类究竟需要什么呢？<br>人类真正的需求并不多，但都源自最原始最坚定的渴望。下述即是人人都渴求得到的：</p>
<ol>
<li>健康长久的生命</li>
<li>食物</li>
<li>睡眠</li>
<li>金钱，以及金钱能换来的东西</li>
<li>来世灵魂不灭（感情）</li>
<li>性生活的满足</li>
<li>子女幸福安康</li>
<li>被重视的感受</li>
</ol>
<p>夸奖人的方式</p>
<ol>
<li>夸事实（不分黑白的夸奖是阿谀奉承）</li>
<li>夸细节</li>
<li>和其他人对比<br>比如：你今天穿的大衣款式很潮，特别是领口的设计，比模特穿的还带劲</li>
</ol>
<p>为了博得同情和关注，人们有时会假装弱小，从而获得存在感。</p>
<p>拉尔夫·瓦尔多·爱默生曾经说过，“无论以何种语言，你所说出的每一个字都刻着自我的烙印。”</p>
<p>赞美别人不是为了得到别人的赞美，在赞美别人的同时，我们的视角会达到更高的层次，看待人和事的视角提升就是我们咱们他们的得到。</p>
<p>“此生之路，我将走过；走过这一次，便再也无法重来。所有力所能及的善行，所有充盈于心的善意，我将毫不吝惜，即刻倾予。我将再不拖延，再不淡漠，只因此生之路，再也无法重来。”</p>
<h3 id="原则三：以对方的需求为出发点"><a href="#原则三：以对方的需求为出发点" class="headerlink" title="原则三：以对方的需求为出发点"></a>原则三：以对方的需求为出发点</h3><p>想要影响他人，唯一的方法是以对方的需求为出发点。</p>
<p>下一次，你需要说服别人的时候，请先不要冒失地开口，喋喋不休地讲自己想要什么。<br>在开口之前，先问问自己：“怎样才能让对方主动自发地去做这件事？”</p>
<p>如果成功有诀窍的话，这个诀窍就在于洞悉他人的立场，并能够同时兼顾自己和他人的立场。——亨利·福特</p>
<h2 id="赢得他人喜爱篇"><a href="#赢得他人喜爱篇" class="headerlink" title="赢得他人喜爱篇"></a>赢得他人喜爱篇</h2><h3 id="原则一：真心诚意地关心他人"><a href="#原则一：真心诚意地关心他人" class="headerlink" title="原则一：真心诚意地关心他人"></a>原则一：真心诚意地关心他人</h3><p>这条特别适合需要安慰人，但又不知说什么好，态度和言辞要真诚，站在对方角度考虑问题，就简单说，我看你情绪不高呢，是XX这个事让你不开心难过了，要是我遇到我也会被影响，因为……。今天时间、肩膀都留给你，你需要的话随时拿去。</p>
<p>人们真正关心的只有自己，这一点永远不会变，无论今天还是明天，无论现在还是未来。<br>不要为了博取关注而哗众取宠。</p>
<p>漠视同胞之人，生活最为艰辛，给周遭带来的伤害也最为深痛。置身于这样的个体周围，人类命运有如堕入寒冬，生机难复。——阿尔弗雷德·阿德勒</p>
<p>用心的记下别人的事情，比如生日。在他们生日的当天发送一段祝福的话，这很可能是别人一天快来的来源。</p>
<p>热情洋溢的和人打招呼，用热情饱满的语气来说话。</p>
<p>我们对他人的兴趣，以他人对我们的兴趣为前提。（想让别人对自己感兴趣，先要让自己表现出对别人的兴趣才可以）</p>
<p>真诚地对待每个人，但一旦发现对方并不值得，也没必要浪费感情。总之，你怎么对待我，我也怎么对待你。</p>
<h3 id="原则二：微笑"><a href="#原则二：微笑" class="headerlink" title="原则二：微笑"></a>原则二：微笑</h3><p>跟所有人打招呼时，要微笑，真心的。</p>
<p>哪怕你不习惯微笑，也请努力试试看。独自一人的时候，试着吹个口哨，或是哼个小曲，假装很开心——这些举动会令你真的开心起来。</p>
<p>笑容的意义<br>它分文不取，却价值连城；<br>它使人富有，亦于己无妨；<br>它发生于瞬息之间，却令人永难忘怀；<br>它使贫者丰足，令富者匮乏；<br>它为家庭带来欢愉，为事业营造机遇，为友谊立下盟约；<br>它是疲倦者的休憩，是忧虑者的良方，是绝望者的黎明，是哀戚者的阳光；<br>它无法用金钱交换，无法经乞求而得，无法借与他人，也无法被人窃取；只有在给予之时，它才有存在的价值。<br>值此圣诞佳节之际，若我们的店员因过于疲惫，无法以笑容迎接您的莅临，能否请您以笑容相赠？<br>那些无力微笑的人，最需要得到一个微笑。</p>
<h3 id="原则三：记住他们的名字"><a href="#原则三：记住他们的名字" class="headerlink" title="原则三：记住他们的名字"></a>原则三：记住他们的名字</h3><p>记住名字和记住生日类似，都是表达对他们关注的一种方式，并且姓名更有效的体现这一点。</p>
<p>方法可以是彻底弄明白他们的名字是哪几个字、看工牌、写下来并读几遍。</p>
<h3 id="原则四：专注地倾听，并鼓励他们谈论自己"><a href="#原则四：专注地倾听，并鼓励他们谈论自己" class="headerlink" title="原则四：专注地倾听，并鼓励他们谈论自己"></a>原则四：专注地倾听，并鼓励他们谈论自己</h3><p>我很怕跟不熟悉的人单独在一起，空间里只有我们两个人时，我就很担心别人尴尬，继而会拼命找话题，但都不是关于对方如天气电影这类没有重心的，这种费劲相处经常让我紧张，我会害怕两个人相处。今天这条在这件事上给了我点启发，下次我就可以直接问与他有关问题，比如平时都喜欢做什么，最近好吗，最近哪件事让你开心，再不济就夸对方，你今天这条裙子好闪亮，审美不错，平时都在哪买衣服……过程中保持全然专注倾听。</p>
<p>专注倾听是我们给他人的最高赞许。</p>
<p>商务往来并无制胜之道可言，然而在对方说话的时候专注地倾听，是令对方解除戒备的最佳方式。——哈佛前校长查尔斯·艾略特</p>
<p>有几个不错的命题来有助于我们倾听他们：听童年、听抱怨、</p>
<p>人们请医生有时只是需要一个听众而已。——《读者文摘》</p>
<p>愤懑的顾客，不满的员工，或是伤痕累累的朋友，人们有时不是真正需要他人的帮助，而是都迫切地想要对他人倾诉心声。</p>
<p>假如你立志要能言善辩，请先学会专注聆听。做一个有趣的人，并对他人感兴趣。问对方乐于回答的问题，鼓励他们谈论自己的经历。</p>
<p>请记住，你的谈话对象并不关心你和你的问题，而对他们自己、他们的欲望和烦恼要感兴趣得多。他的牙疼远比异国饿殍遍地的饥荒更重要，他脖子上的疖子也远比非洲的四十次地震更让人心烦。所以下次开口之前，请先想想这一点。</p>
<h3 id="原则五：谈论对方感兴趣的事情"><a href="#原则五：谈论对方感兴趣的事情" class="headerlink" title="原则五：谈论对方感兴趣的事情"></a>原则五：谈论对方感兴趣的事情</h3><p>谈论对方最在乎的事情，是直抵对方内心深处的捷径。如何知道对方最在乎的事情呢？当然是提前花费时间了解对方感兴趣的话题啦～</p>
<p>学会闭嘴，切勿一直表达个人观点，想影响他人打开话匣子，听他聊他的“有趣故事” 。</p>
<h3 id="原则六：真心实意地让对方觉得知道他有多重要"><a href="#原则六：真心实意地让对方觉得知道他有多重要" class="headerlink" title="原则六：真心实意地让对方觉得知道他有多重要"></a>原则六：真心实意地让对方觉得知道他有多重要</h3><p>你这么说，我好受了很多。</p>
<p>曾经在一次演讲中提到过这件事。当时一个人问我：“你想从他那儿得到什么？”<br>我想从他那儿得到什么！！！我想从他那儿得到什么！！！<br>如果人人都如此自私阴暗，付出一点小小的善意和一句真诚的称赞都索求回报；如果我们的灵魂渺小如尘沙，那么失败是注定应得的惩罚。</p>
<h3 id="原则一：赢得争论的方法只有一个，那就是避免争论"><a href="#原则一：赢得争论的方法只有一个，那就是避免争论" class="headerlink" title="原则一：赢得争论的方法只有一个，那就是避免争论"></a>原则一：赢得争论的方法只有一个，那就是避免争论</h3><p>不要纵容直觉反应。面对不利处境，人类的本能使我们下意识地进入戒备模式。这时请格外注意。保持冷静，警惕你的本能反应——它会使你成为最糟的那个你，而非状态最好的那个你。<br>控制情绪。观察对方是否易怒，你就能知道他是君子还是小人。<br>先听，后说。给对方说话的机会，听他们把话说完。反驳和争辩只会徒增隔阂。建立沟通的桥梁，不要筑起误解的壁垒。<br>求同存异。听到对方的看法之后，请先想想你认可的部分。<br>诚恳。在能够让步的时候让步，在应该认错的时候认错。这会令对方放下戒心，从而减少摩擦。<br>向对方承诺你会认真考虑他的想法，并且说到做到。对方很有可能是正确的。借这个机会深思熟虑，总好过事后被对方指责“我们告诉过你，可你就是不听”。<br>真心诚意地感谢对方的重视。对方愿意花时间和你争辩，是因为他和你对同一件事感兴趣。将他们视为真心愿意帮助你的人，也许就能化敌为友。<br>给双方足够时间找出症结所在，不要急于采取行动。主动建议推迟讨论时间，将所有细节都考虑清楚。再次交涉之前，请坦诚地问问自己这些关键问题：<br>对方有没有可能是正确的，或是部分正确？他的论点中是否有值得肯定的地方？我的建议能够解决问题，还是只会引发不快？我的行为是会把对方推向对立面，还是拉近我们的关系？我的决策是否能让人们更尊重我？我会赢，还是会输？如果我赢了，我会付出什么代价？如果我保持缄默，纷争是否会就此平息？目前的局面对我而言，是否意味着机会？<br>歌剧男高音简·皮尔斯在金婚之时说：“很早之前，我和妻子就立下了一个规矩——一个人发火的时候，另外一个人必须听着。如果两个人都在大叫大嚷，那不叫沟通，叫噪音。无论我们对彼此有多不满，都不曾违背这个约定。”</p>
<h3 id="原则二：尊重他人的观点，绝不要说“你错了”"><a href="#原则二：尊重他人的观点，绝不要说“你错了”" class="headerlink" title="原则二：尊重他人的观点，绝不要说“你错了”"></a>原则二：尊重他人的观点，绝不要说“你错了”</h3><p>世间理性之人极少，大部分人都充满偏见，其认知被成见、戒备、猜疑、恐惧、妒忌和傲慢所束缚。</p>
<p>不要立即反驳地方对观点。</p>
<h3 id="原则三：如果你错了，请坚决果断地承认错误"><a href="#原则三：如果你错了，请坚决果断地承认错误" class="headerlink" title="原则三：如果你错了，请坚决果断地承认错误"></a>原则三：如果你错了，请坚决果断地承认错误</h3><p>抢先认错！当我抢先开始自责时，唯一能够让他自我感觉良好的方式，是通过对我的怜悯显示他的宽宏大量。</p>
<h3 id="原则四：沟通始于友善"><a href="#原则四：沟通始于友善" class="headerlink" title="原则四：沟通始于友善"></a>原则四：沟通始于友善</h3><p>让我们坐下谈谈，如果我们意见相左，那么这正是了解彼此观点的好机会。</p>
<h3 id="原则五：让对方点头称“是”"><a href="#原则五：让对方点头称“是”" class="headerlink" title="原则五：让对方点头称“是”"></a>原则五：让对方点头称“是”</h3><h3 id="原则六：让对方主导谈话"><a href="#原则六：让对方主导谈话" class="headerlink" title="原则六：让对方主导谈话"></a>原则六：让对方主导谈话</h3>]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>年终总结</title>
    <url>/2022/01/06/yearendsummary/</url>
    <content><![CDATA[<blockquote>
<p>试图通过每一年个人总结来了解过去一年自己的表现、做事的方式方法，从而更好地发现自己的优点和不足，并制定下一年的计划。</p>
</blockquote>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该总结并不是工作上的总结，并不适合作为公司的年终总结来参考，仅仅是为了个人提升而做出的尝试。</p>
<h2 id="总结包含哪些方面"><a href="#总结包含哪些方面" class="headerlink" title="总结包含哪些方面"></a>总结包含哪些方面</h2><ol>
<li>过去规划。过去一年对去年规划的执行情况以及自己做的额外的事情。</li>
<li>个人成长。回顾过去一年自己的表现，分析自己的有哪些做的好的地方。</li>
<li>自我反思。在回顾自己的工作和表现时，要将自我反思贯穿始终，找出自己的不足和需要改进的地方，并提出改进方案和行动计划。</li>
<li>未来规划。根据成长与反思来指定未来一年的新规划。</li>
</ol>
<h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><ol>
<li>Go 编程能力的提升<br>一年来对 Go 知识掌握的更加熟练，对更多底层的东西有了更深的了解。</li>
<li>设计模式的实践<br>在擦神的建议下读了设计模式的书，并将自己理解的一部分运用到工程中。但迷茫的时候占了大多数，主要在于掌握程度低、见识少带来的限制。</li>
<li>与人交往的能力得到提升<br>坚持实践了《人性的弱点》中的原则，切实的体会到了好的沟通方式和交往方式带来的收益。</li>
<li>保持了一段时间的锻炼<br>运动了一段时间，期间体态得到了改善，但是懈怠后再也没动起来过 -_- 身体健康几乎大于一切</li>
</ol>
<h2 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h2><ol>
<li>将大部分时间都花在了工作上<br>工作很重要，它的底层逻辑在于将自己的时间和专业知识卖给公司，公司获取利益的同时自己得到一部分提升。但工作仅仅是生活的一小部分，更应该把时间交给自己，花费时间来做更多有意义的事情，而不是”买卖”。</li>
<li>晚睡晚起<br>去年一整年几乎都是 3 点睡 10 点起，晚睡之前都是在打游戏、看视频，做了太多娱乐活动，现在这个年纪还是需要更多的个人提升的，尝试去改变吧岳小杨！</li>
<li>没能坚持做好锻炼计划<br>没别的，接下来一年能不能做好也说不准，只能说加油吧。</li>
<li>不能为自己已经发现的劣质品质做出有建设性的改变<br>有时候已经发现了自己之前的认知有误，但是介于羞耻心，不去及时承认。类似于这种情况，必须要从底层上发现出现这种情况的原因并解决。</li>
<li>在工作上”不敢”去做<br>比如一个项目快要延期了，</li>
</ol>
<h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><ol>
<li>加深对专业知识的理解<ul>
<li>继续深入学习 Go 语言，有朝一日一定能实现终极目标！</li>
<li>扩宽知识面，学习计算机网络、交换机，并维护相应博客内容</li>
</ul>
</li>
<li>坚持提升与人沟通的能力<ul>
<li>读完《人性的弱点》并复习，真正做到践行其中的原则</li>
</ul>
</li>
<li>践行好锻炼计划，坚持游泳，坚持跑步，坚持改变体态<ul>
<li>指定健身计划并执行</li>
</ul>
</li>
<li>找一本有助于自我认知的书籍<ul>
<li>读帮助自我认知和自我改变的书，并维护到博客中</li>
</ul>
</li>
</ol>
<h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><h2 id="个人成长-1"><a href="#个人成长-1" class="headerlink" title="个人成长"></a>个人成长</h2><ol>
<li>编程水平提升，知识面变宽变广</li>
<li>各个开发工具的熟练使用：Charles，Telepresence</li>
<li>性格上： <ul>
<li>保持着对程序设计的热情，使命感 </li>
<li>责任心进一步提升，能够真正将程序设计当成自己的事情去认真对待 </li>
<li>更加的细心，考虑的更加广泛、周到，比起刚到公司可以说是有较大提升 </li>
</ul>
</li>
<li>能有效的输出开发过程中的文档和发版文档</li>
</ol>
<h2 id="自我反思-1"><a href="#自我反思-1" class="headerlink" title="自我反思"></a>自我反思</h2><h3 id="有什么应对措施"><a href="#有什么应对措施" class="headerlink" title="有什么应对措施"></a>有什么应对措施</h3><ol>
<li>首先，可以花费更多精力和心思去考虑一个产品需求，克服那种”不可见的产出容易懈怠”的心理。其次，能与产品团队和后端团队共同讨论后再做出相对更合理的技术选型和决策，将技术返讲及时的坚定地落实下去。</li>
<li>养成习惯来避免以一种绝对的语气或者态度去描述事物。</li>
<li>缩短项目交付周期，形成稳定的项目部署脚本。</li>
</ol>
<h2 id="未来规划-1"><a href="#未来规划-1" class="headerlink" title="未来规划"></a>未来规划</h2><p>下一小步的安排是：能继续保持现有的活力，提高质量、提高效率的完成产品需求，维护好项目。</p>
<ol>
<li>提升对程序设计的视野和深度，为公司的产品提供更优秀的设计和更高质量的代码。</li>
<li>随着公司产品承接项目越来越多，能够肩负起一部分项目的开发和维护工作，并以<code>客户第一，责任担当，创造价值</code>的价值观反馈于客户。</li>
<li>在个人学习成长的同时，优化自己的学习习惯，形成文档产出和知识分享，为小伙伴提供自己的学习分享：先预计三次（大概 __ ）。</li>
<li>对于自身，提升自身技能的深度与广度，对每一种技术每一类知识都能了解到位。</li>
</ol>
]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>soft&amp;web</title>
    <url>/2021/07/07/soft&amp;web/</url>
    <content><![CDATA[<blockquote>
<p>soft&amp;web for mac/windows/centos</p>
</blockquote>
<span id="more"></span>

<h2 id="git"><a href="#git" class="headerlink" title="git"></a><code>git</code></h2><p><a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">Getting Started - Installing Git</a></p>
<h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a><code>Ruby</code></h2><p><a href="https://www.ruby-lang.org/en/documentation/installation/">Installing Ruby</a></p>
<h2 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a><code>HomeBrew</code></h2><p><a href="https://baijiahao.baidu.com/s?id=1668544039877443967&wfr=spider&for=pc">Homebrew的国内安装脚本</a></p>
<h2 id="keycastr"><a href="#keycastr" class="headerlink" title="keycastr"></a><code>keycastr</code></h2><p><a href="https://github.com/keycastr/keycastr">GitHub keycastr</a></p>
<h2 id="clash-for-mac"><a href="#clash-for-mac" class="headerlink" title="clash for mac"></a><code>clash for mac</code></h2><p><a href="https://github.com/yichengchen/clashX/releases">GitHub clash for mac</a></p>
<h2 id="iCopy"><a href="#iCopy" class="headerlink" title="iCopy"></a><code>iCopy</code></h2><p><a href="https://www.better365.cn/icopy.html">https://www.better365.cn/icopy.html</a></p>
<h2 id="OpenAI"><a href="#OpenAI" class="headerlink" title="OpenAI"></a><code>OpenAI</code></h2><h3 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a><code>ChatGPT</code></h3><ul>
<li><a href="https://chat.openai.com/chat">https://chat.openai.com/chat</a> gpt-3.5</li>
<li><a href="https://ai.bo-e.com/">https://ai.bo-e.com/</a> 仅国内节点</li>
<li><a href="https://geekch.art/#/chat">https://geekch.art/#/chat</a></li>
<li><a href="https://chat.binjie.site:7777/">https://chat.binjie.site:7777/</a> 国内非常快</li>
</ul>
<h3 id="openai-translator"><a href="#openai-translator" class="headerlink" title="openai-translator"></a><code>openai-translator</code></h3><p><a href="https://github.com/yetone/openai-translator/releases">GitHub openai-translator</a></p>
<h3 id="codewhisperer"><a href="#codewhisperer" class="headerlink" title="codewhisperer"></a><code>codewhisperer</code></h3><p><a href="https://www.google.com/aclk?sa=l&ai=DChcSEwiB0Ivqt7b-AhU6Fa0GHcCpCKQYABAAGgJwdg&sig=AOD64_0ru2tVCLoPSorENk8xs0OodzB_tg&q&adurl&ved=2ahUKEwiYy4Xqt7b-AhVBJUQIHX7HDc8Q0Qx6BAgHEAE">AI Code Generator - Amazon CodeWhisperer - AWS</a></p>
<h2 id="Bing"><a href="#Bing" class="headerlink" title="Bing"></a><code>Bing</code></h2><h3 id="Bing-AI-画图"><a href="#Bing-AI-画图" class="headerlink" title="Bing AI 画图"></a><code>Bing AI 画图</code></h3><p><a href="http://bing.com/create">http://bing.com/create</a></p>
<h2 id="charles"><a href="#charles" class="headerlink" title="charles"></a><code>charles</code></h2><ul>
<li><a href="https://www.charlesproxy.com/download/">Charles Download</a></li>
<li><a href="https://www.zzzmode.com/mytools/charles/">Charles 破解</a></li>
</ul>
<h2 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a><code>cursor</code></h2><p><a href="https://www.cursor.so/">https://www.cursor.so/</a></p>
<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a><code>VPN</code></h2><ul>
<li><a href="https://慈善机场.com/#/register?code=C4LrXXTf">慈善机场</a></li>
<li><a href="https://一元机场.com/#/register?code=28YZMFza">一元机场</a></li>
<li><a href="https://paoluz.link/">跑路云</a></li>
</ul>
<h2 id="Goland"><a href="#Goland" class="headerlink" title="Goland"></a><code>Goland</code></h2><p><a href="https://www.ahhhhfs.com/30219">Goland 激活</a><br><a href="https://github.com/YiiGuxing/TranslationPlugin">Goland 翻译插件</a></p>
<h2 id="测网速"><a href="#测网速" class="headerlink" title="测网速"></a><code>测网速</code></h2><p><a href="https://fast.com/">https://fast.com/</a></p>
<h2 id="Excalidraw"><a href="#Excalidraw" class="headerlink" title="Excalidraw"></a>Excalidraw</h2><p><a href="https://excalidraw.com/">https://excalidraw.com/</a></p>
<h2 id="Whimsical-思维导图"><a href="#Whimsical-思维导图" class="headerlink" title="Whimsical 思维导图"></a>Whimsical 思维导图</h2><p><a href="https://whimsical.com/">https://whimsical.com</a></p>
<h2 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h2><p><a href="https://www.notion.so/">https://www.notion.so/</a></p>
<h2 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h2><p><a href="https://pasteapp.io/">https://pasteapp.io/</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/README.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><p>基本信息：岳杨/1996/男</p>
<p>联系方式：17806283435（微信同号）<a href="mailto:&#109;&#109;&#100;&#121;&#x75;&#101;&#121;&#x61;&#110;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#109;&#109;&#100;&#121;&#x75;&#101;&#121;&#x61;&#110;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;</a></p>
<p>籍贯：山东省威海市</p>
<p>学历：本科 山东科技大学 计算机科学与技术专业</p>
<p>工作年限：4年 19年毕业</p>
<p>期望岗位：Go 研发工程师</p>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ol>
<li>两年 <code>Golang</code> 两年<code> Java</code> 开发经验，熟练使用常见第三方库及框架。 </li>
<li>熟练使用 <code>MySQL</code> 、<code>MongoDB</code> 、<code>Redis</code>等中间件并有一定深入了解。 </li>
<li>熟悉计算机原理、数据结构与算法、计算机网络等知识。</li>
<li>熟悉常用设计模式，能够快速分析需求并进行程序设计，产出设计文档。</li>
<li>熟悉<code>Linux</code>常用命令，能够使用<code>docker</code> ，<code>k9s</code> 等工具在服务器中排查问题并发版。</li>
<li>拥有良好的编程习惯，多次独立优化业务代码，负责代码重构，代码 Review。</li>
</ol>
<p>工作经历</p>
<h3 id="北京幂律智能科技有限公司"><a href="#北京幂律智能科技有限公司" class="headerlink" title="北京幂律智能科技有限公司"></a>北京幂律智能科技有限公司</h3><p>任职时间：2021年06月 至 2023年05月31日</p>
<p>任职岗位：Go研发工程师</p>
<h4 id="MeFlow-项目"><a href="#MeFlow-项目" class="headerlink" title="MeFlow 项目"></a>MeFlow 项目</h4><h5 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h5><p>​    MeFlow 项目是一个<code>Gin</code>框架的 Web  服务，自研<code>gormbase</code>为 orm 框架，数据存储为 <code>mysql</code>、<code>mongodb</code> ，代码风格偏向 Go  社区，代码分层架构为 <code>DDD</code>。项目本身基于优秀的算法和智能能力在法律行业中处于龙头地位，有着较为成熟的需求迭代流程。团队有着较为成熟的协作模式，开发以基于项目需求进行迭代的敏捷开发模式。个人以内部框架研发、需求迭代、项目维护为基本的日常工作。</p>
<h5 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h5><p><code>gin</code>,<code>gorm</code>,<code>grpc</code>,<code>mysql</code>,<code>mongodb</code>,<code>redis</code>,<code>docker</code>,<code>k8s</code></p>
<h5 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h5><ol>
<li>负责 MeFlow 的审批、评审、履约等功能模块。</li>
<li>担任项目负责人，协调跨部门团队，及时沟通风险，确保项目按时、高质量交付。</li>
<li>持续优化代码，改善产品性能、稳定性、可扩展性和安全性。</li>
<li>建立和完善流程、标准、文档等相关管理制度，确保项目开发流程的规范化和标准化。</li>
<li>负责技术难点攻关和解决方案的制定，协助团队成员解决技术问题。</li>
</ol>
<h3 id="北京泛钛客科技有限公司"><a href="#北京泛钛客科技有限公司" class="headerlink" title="北京泛钛客科技有限公司"></a>北京泛钛客科技有限公司</h3><p>任职时间：2021 年 03 月 至 2021 年 06 月</p>
<p>任职岗位：Java 研发工程师</p>
<p>离职原因：开发模式为连接远程电脑开发，极其痛苦。</p>
<h3 id="中油龙慧北京信息科技分公司"><a href="#中油龙慧北京信息科技分公司" class="headerlink" title="中油龙慧北京信息科技分公司"></a>中油龙慧北京信息科技分公司</h3><p>任职时间：2019 年 02 月 至 2021 年 03 月</p>
<p>任职岗位：Java 研发工程师</p>
<h4 id="地理信息可视化平台"><a href="#地理信息可视化平台" class="headerlink" title="地理信息可视化平台"></a>地理信息可视化平台</h4><h5 id="项目描述-1"><a href="#项目描述-1" class="headerlink" title="项目描述"></a>项目描述</h5><p>​    公司主营业务为地理信息系统，我参与的主要项目是 gis 项目。主要是对地理信息数据进行点位、线路、面积的计算和绘制，记录路线预测风险，并将计算数据可视化。</p>
<h5 id="技术架构-1"><a href="#技术架构-1" class="headerlink" title="技术架构"></a>技术架构</h5><p><code>springboot</code>,<code>mybatisplus</code>,<code>多数据源</code>,<code>liquibase</code>,<code>rabbitmq</code></p>
<h5 id="主要职责-1"><a href="#主要职责-1" class="headerlink" title="主要职责"></a>主要职责</h5><ol>
<li>设计、开发和维护后端接口，主要设计和维护图层模块，确保其高效稳定地运行，并提供必要的技术支持和解决方案。</li>
<li>研究并集成新兴技术或框架，以优化项目的性能和可扩展性。</li>
<li>负责数据库设计、优化和维护，确保数据的完整性和安全性。</li>
<li>管理项目的部署，确保其正确且及时上线，并负责项目后期的维护工作，及时修复问题，更新代码和文档。</li>
<li>确保代码的质量和可维护性，并积极参与代码审查和改进。</li>
<li>持续关注业内新技术、新趋势，为团队提供技术分享。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>试一试在这里写内容会发生什么</p>
]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>留下你的脚印👣</title>
    <url>/guestbook/index.html</url>
    <content><![CDATA[<p>试一试在这里写内容又会发生什么</p>
]]></content>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/notes/Dubbo.html</url>
    <content><![CDATA[<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h3 id="Dubbo是什么？"><a href="#Dubbo是什么？" class="headerlink" title="Dubbo是什么？"></a>Dubbo是什么？</h3><ul>
<li>一款分布式服务框架</li>
<li>高性能透明化RPC方案</li>
<li>SOA服务治理方案</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/notes/Go%E5%BC%80%E5%8F%91%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html</url>
    <content><![CDATA[<p>包中引用多个其他功能同级目录的包导致的重命名规则</p>
<blockquote>
<p>  功能模块名简写+当前目录层级名简写，全部字母小写；</p>
<p>  当不同功能模块简写重复时，后添加的功能模块包使用易懂的简写代替；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    uc <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/utils/consts/user&quot;</span> <span class="comment">// uc表示userconsts</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包中引用系统级别包和自定义包导致的重命名规则</p>
<blockquote>
<p>  系统级别包使用前缀<code>sys</code>+包名或缩写</p>
<p>  Golang扩展包使用<code>go</code>或扩展包前缀+包名或缩写</p>
<p>  用户自定义包使用原名或缩写，全部字母小写；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    sysctx 	<span class="string">&quot;context&quot;</span></span><br><span class="line">    </span><br><span class="line">   	gouuid <span class="string">&quot;github.com/satori/go.uuid&quot;</span></span><br><span class="line">    gomail <span class="string">&quot;gopkg.in/mail.v2&quot;</span></span><br><span class="line">    </span><br><span class="line">    context <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/domain/contract/entity&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包中引用工具包，可以直接重定义命名</p>
<blockquote>
<p>  引用工具包时，即使没有重名包的情况下，对工具包直接重命名，全部字母小写；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    httputils <span class="string">&quot;powerlaw.ai/meflow/controller/internal/app/utils/http&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  结构体中引用到多个其他其他功能同级目录的类型时，参数名使用功能模块名+目录层级名，小驼峰命名（包名中包含多词时以功能为最小单位）</p>
<p>  引用到系统级别包或自定义系统级功能包时，</p>
<p>  当<code>单词长度≤8</code>时，参数名可以使用单词全拼；</p>
<p>  当<code>单词长度＞8</code>时，参数名使用短命名形式；</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctx 				*context.AppContext	<span class="comment">// AppContext就简写成ctx</span></span><br><span class="line">    workflowDomain 		workflow.Domain		<span class="comment">// workflow长度适宜，使用全拼，且不允许写成workFlow</span></span><br><span class="line">    bcDomain 			bcd.Domain 			<span class="comment">// businesscategory过长，就简写成了bc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/notes/JVM.html</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><ol>
<li>引用计数器</li>
<li>根可达性分析算法</li>
</ol>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><ol>
<li><p>复制算法</p>
</li>
<li><p>标记清除法</p>
</li>
<li><p>标记整理法</p>
</li>
<li><p>分代收集算法</p>
<p>现在</p>
</li>
<li><p>//</p>
</li>
</ol>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ol>
<li>强引用：只要强引用存在，GC永远不会回收被强引用引用的对象。Object obj = new Object();</li>
<li>弱引用：GC工作时，都会回收只被弱引用引用的对象。</li>
<li>软引用：有用，但不完全有用的对象，在系统内存不足时，GC才会回收。</li>
<li>虚引用：最弱的一种引用关系。</li>
</ol>
<blockquote>
<p>GC的可达性分析算法就是看的是强引用</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/notes/MySQL.html</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3>]]></content>
  </entry>
  <entry>
    <title>notes</title>
    <url>/notes/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/notes/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
  </entry>
  <entry>
    <title>面试整理</title>
    <url>/notes/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h3 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h3><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务</p>
<p>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</p>
<p>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>
<h3 id="Zookeeper是什么框架"><a href="#Zookeeper是什么框架" class="headerlink" title="Zookeeper是什么框架"></a>Zookeeper是什么框架</h3><p>Zookeeper是分布式系统协调服务的框架，也叫作服务注册中心</p>
<h3 id="Dubbo一般用什么注册中心？还有别的选择吗？"><a href="#Dubbo一般用什么注册中心？还有别的选择吗？" class="headerlink" title="Dubbo一般用什么注册中心？还有别的选择吗？"></a>Dubbo一般用什么注册中心？还有别的选择吗？</h3><p>Dubbo一般使用Zookeeper，也可以使用Redis，consul，数据库</p>
<h3 id="为什么说Spring是一个容器？"><a href="#为什么说Spring是一个容器？" class="headerlink" title="为什么说Spring是一个容器？"></a>为什么说Spring是一个容器？</h3><p>Spring的核心思想是更方便的管理Java Bean，有Spring创建的Bean放入一个Map中，这个Map就可以理解成装Bean的容器，也就是IOC容器。</p>
<h3 id="JVM生命周期和体系结构"><a href="#JVM生命周期和体系结构" class="headerlink" title="JVM生命周期和体系结构"></a>JVM生命周期和体系结构</h3><p>JVM声明周期是跟随程序一起的，JVM开始运行时就是程序启动时，JVM停止运行程序也随之结束。</p>
<p>JVM体系结构包含：类加载器、内存区、执行引擎、本地方法调用。</p>
]]></content>
  </entry>
</search>
